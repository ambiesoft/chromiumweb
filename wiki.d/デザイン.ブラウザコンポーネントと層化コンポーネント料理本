version=pmwiki-2.2.107 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1532666307
host=192.168.3.2
name=デザイン.ブラウザコンポーネントと層化コンポーネント料理本
rev=1
targets=
text=https://www.chromium.org/developers/design-documents/cookbook%0a%0a!ブラウザコンポーネント / 層化コンポーネント料理本%0a%0a新規コンポーネントの誕生、熟練の機能を依存地獄から救い輝かしいコンポーネントになるまでのストーリー%0a%0a!!概観%0aこの文書はChromiumの機能をコンポーネントあるいは層化コンポーネントに変えるたのめガイドである。コンポーネントと層化コンポーネントのデザイン文書は前提とする。%0a%0a!!動機と層化%0a我々は最初はいくつものトップレベルアプリをもっていた。そのうちの一つ（アンドロイド用Chrome）にとって必要な方法は//chrome内での#ifdefであった。しかし今後のトップレベルアプリではこれは避けたいと思った。%0a%0a//components層はChromiumコードベースからビルドされる追加機能の場所である。もともとは//chromeにあったが、ここに移動されていろいろなトップレベルアプリ（例えば//android_webview）などから利用できるようになっている。%0a%0a新規機能で多くのトップレベルアプリが利用するものはコンポーネントとして記述されるべきである。アンドロイド用Chrome以外のトップレベルアプリの機能で再利用するものは//componentsへ移動すべきである。このドキュメントは新規コンポーネントを作成するための料理本風のドキュメントであり、//chromeからどうやってコンポーネントに移動させるかについて記述する。以下の図は、Chromium階層の中でのコンポーネント位置づけを示している。この図は単純化されていることに注意すること。すべてのコンポーネントが//contentに依存できるわけではない。例えば、iOSで共有されるコンポーネントは//contentに依存できないので、その場合層化コンポネント形態にするしかない。%0a%0ahttps://www.chromium.org/_/rsrc/1467147662826/developers/design-documents/cookbook/layercake.png%0a%0a!!新規ブラウザコンポーネントの作成%0a新規コンポーネントの作成は一直線である。デザイン文書のルールに従い、//componentsディレクトリにある例を参考にする。以下はTL;DRバージョン：%0a%0a* xyzという名前のコンポーネントは//components/xyzに置く。%0a* xyzのコードは名前空間xyz内に書く。%0a* 厳格な//components/xyz/DEPSが存在し、コンポーネントが配下層のみに依存することを強制する。%0a** 配下層モジュール（例えば、//base, //net, もしかしたら //content）%0a** ツリーを構成するような他の//components、循環依存はだめ。%0a* コンポーネントは配下層か他のコンポーネントのみに具体的に依存できる。組込者が利用するなら、そのためのクライアントインタフェースを提供すること。 %0a* iOSから利用されるコンポーネント、または//contentに依存するコンポーネントは層化コンポーネント形態でなければならない。%0a* ブラウザプロセスのみから利用されるコンポーネントはそのディレクトリに直接含まれるコードを含む。%0a* いくつものプロセスタイプで利用されるコンポーネントはプロセスごとにディレクトリをもつ、例えば：%0a** //components/xyz/browser%0a** //components/xyz/renderer%0a** //components/xyz/common%0a* コンポーネントはそのビルドで分離した動的ライブラリになることもできる。%0a* Create, own and configure the component in the embedder layer, e.g. in //chrome/browser.%0a%0a!! 現存する機能を抽出してブラウザコンポーネントを作成%0a機能を抽出するための典型的ステップ：%0a%0a# 抽出する機能を決めて、その機能のオーナーにそのことを伝える。%0a# コンポーネント化に関するデザイン文書を作成し、ファイルを分析して//chrome依存の分析（ユニットテストのコンポーネント化は次のパスでやることもできる）する。機能がiOSで利用される場合は//content依存の分析もする。%0a# ファイルの分析では以下のことを行う：コンポーネント化に含まれるハイレベルタスクのセットを生成（例えば、ProfileからFooServiceを取得する代わりにFooService依存性を直接注入）；もしその機能がiOSで利用されるなら層化コンポーネントにすべきかを決める。また機能のコンポーネント化が他の//chrome機能よってブロックされるかを判断する（その場合はステップ２にもどりブロック機能を追加）%0a# ハイレベルタスクとバグツリーをマップする。バグツリーのリーフは個別CL粒度のバグである。バグツリーのすべてのバグに関連するホットリスト（例えば、Hostlist-Foo-Component）を与える、これによりリストの検索と分析が容易になる。%0a# コンポーネントを作成（最終的なDEPS構造でセットアップ）し、いくつかのリーフファイル（問題のある依存性が殆どないファイル）をその中に移動する。この最初のパスで、コンポーネントのターゲットをスタティックライブラリにすることができることに注意。%0a# バグツリーを燃やす。問題のある依存性を除去しつつ、少しずつファイルをコンポーネントに追加する。%0a# すべてのプロダクションコードがコンポーネント化されたら、第２パスであるユニットテストのコンポーネント化を行う（プロダクションコードがコンポーネント化されたあとなら、一直線にできる）。%0a# コンポーネントのすべてのコードをコンポーネントの名前空間に入れる。（例えば//components/fooにあるコードは名前空間"foo"に入れる）%0a# もし望むなら、.gypiファイルを修正してコンポーネントとしてビルドするようにexport宣言を追加する。%0a** 他のコンポーネントの実例を見る。例えば、//components/webdata/common/webdata_export.hとその利用。%0a%0aファイル移動時にインクルードガートとファイルへの参照（.gyp(i)ファイルで参照される他のソースの#includesと#imports）を更新するツールがある；src/tools/git/{move_source_file.py, mass-rename.py}を参照。Pythonの正規表現を使ってコードベースに渡っての検索と置換を行うツールもある；src/tools/git/mffr.pyを参照。最後に、"git cl format"を使ってリファクタリングの際の再フォーマットを簡単にすることを強く薦める。%0a%0a!!Recipes for Breaking //content Dependencies%0a＜途中＞%0a%0a%0a%0a
time=1532666307
author:1532666307=
diff:1532666307:1532666307:=1,57d0%0a%3c https://www.chromium.org/developers/design-documents/cookbook%0a%3c %0a%3c !ブラウザコンポーネント / 層化コンポーネント料理本%0a%3c %0a%3c 新規コンポーネントの誕生、熟練の機能を依存地獄から救い輝かしいコンポーネントになるまでのストーリー%0a%3c %0a%3c !!概観%0a%3c この文書はChromiumの機能をコンポーネントあるいは層化コンポーネントに変えるたのめガイドである。コンポーネントと層化コンポーネントのデザイン文書は前提とする。%0a%3c %0a%3c !!動機と層化%0a%3c 我々は最初はいくつものトップレベルアプリをもっていた。そのうちの一つ（アンドロイド用Chrome）にとって必要な方法は//chrome内での#ifdefであった。しかし今後のトップレベルアプリではこれは避けたいと思った。%0a%3c %0a%3c //components層はChromiumコードベースからビルドされる追加機能の場所である。もともとは//chromeにあったが、ここに移動されていろいろなトップレベルアプリ（例えば//android_webview）などから利用できるようになっている。%0a%3c %0a%3c 新規機能で多くのトップレベルアプリが利用するものはコンポーネントとして記述されるべきである。アンドロイド用Chrome以外のトップレベルアプリの機能で再利用するものは//componentsへ移動すべきである。このドキュメントは新規コンポーネントを作成するための料理本風のドキュメントであり、//chromeからどうやってコンポーネントに移動させるかについて記述する。以下の図は、Chromium階層の中でのコンポーネント位置づけを示している。この図は単純化されていることに注意すること。すべてのコンポーネントが//contentに依存できるわけではない。例えば、iOSで共有されるコンポーネントは//contentに依存できないので、その場合層化コンポネント形態にするしかない。%0a%3c %0a%3c https://www.chromium.org/_/rsrc/1467147662826/developers/design-documents/cookbook/layercake.png%0a%3c %0a%3c !!新規ブラウザコンポーネントの作成%0a%3c 新規コンポーネントの作成は一直線である。デザイン文書のルールに従い、//componentsディレクトリにある例を参考にする。以下はTL;DRバージョン：%0a%3c %0a%3c * xyzという名前のコンポーネントは//components/xyzに置く。%0a%3c * xyzのコードは名前空間xyz内に書く。%0a%3c * 厳格な//components/xyz/DEPSが存在し、コンポーネントが配下層のみに依存することを強制する。%0a%3c ** 配下層モジュール（例えば、//base, //net, もしかしたら //content）%0a%3c ** ツリーを構成するような他の//components、循環依存はだめ。%0a%3c * コンポーネントは配下層か他のコンポーネントのみに具体的に依存できる。組込者が利用するなら、そのためのクライアントインタフェースを提供すること。 %0a%3c * iOSから利用されるコンポーネント、または//contentに依存するコンポーネントは層化コンポーネント形態でなければならない。%0a%3c * ブラウザプロセスのみから利用されるコンポーネントはそのディレクトリに直接含まれるコードを含む。%0a%3c * いくつものプロセスタイプで利用されるコンポーネントはプロセスごとにディレクトリをもつ、例えば：%0a%3c ** //components/xyz/browser%0a%3c ** //components/xyz/renderer%0a%3c ** //components/xyz/common%0a%3c * コンポーネントはそのビルドで分離した動的ライブラリになることもできる。%0a%3c * Create, own and configure the component in the embedder layer, e.g. in //chrome/browser.%0a%3c %0a%3c !! 現存する機能を抽出してブラウザコンポーネントを作成%0a%3c 機能を抽出するための典型的ステップ：%0a%3c %0a%3c # 抽出する機能を決めて、その機能のオーナーにそのことを伝える。%0a%3c # コンポーネント化に関するデザイン文書を作成し、ファイルを分析して//chrome依存の分析（ユニットテストのコンポーネント化は次のパスでやることもできる）する。機能がiOSで利用される場合は//content依存の分析もする。%0a%3c # ファイルの分析では以下のことを行う：コンポーネント化に含まれるハイレベルタスクのセットを生成（例えば、ProfileからFooServiceを取得する代わりにFooService依存性を直接注入）；もしその機能がiOSで利用されるなら層化コンポーネントにすべきかを決める。また機能のコンポーネント化が他の//chrome機能よってブロックされるかを判断する（その場合はステップ２にもどりブロック機能を追加）%0a%3c # ハイレベルタスクとバグツリーをマップする。バグツリーのリーフは個別CL粒度のバグである。バグツリーのすべてのバグに関連するホットリスト（例えば、Hostlist-Foo-Component）を与える、これによりリストの検索と分析が容易になる。%0a%3c # コンポーネントを作成（最終的なDEPS構造でセットアップ）し、いくつかのリーフファイル（問題のある依存性が殆どないファイル）をその中に移動する。この最初のパスで、コンポーネントのターゲットをスタティックライブラリにすることができることに注意。%0a%3c # バグツリーを燃やす。問題のある依存性を除去しつつ、少しずつファイルをコンポーネントに追加する。%0a%3c # すべてのプロダクションコードがコンポーネント化されたら、第２パスであるユニットテストのコンポーネント化を行う（プロダクションコードがコンポーネント化されたあとなら、一直線にできる）。%0a%3c # コンポーネントのすべてのコードをコンポーネントの名前空間に入れる。（例えば//components/fooにあるコードは名前空間"foo"に入れる）%0a%3c # もし望むなら、.gypiファイルを修正してコンポーネントとしてビルドするようにexport宣言を追加する。%0a%3c ** 他のコンポーネントの実例を見る。例えば、//components/webdata/common/webdata_export.hとその利用。%0a%3c %0a%3c ファイル移動時にインクルードガートとファイルへの参照（.gyp(i)ファイルで参照される他のソースの#includesと#imports）を更新するツールがある；src/tools/git/{move_source_file.py, mass-rename.py}を参照。Pythonの正規表現を使ってコードベースに渡っての検索と置換を行うツールもある；src/tools/git/mffr.pyを参照。最後に、"git cl format"を使ってリファクタリングの際の再フォーマットを簡単にすることを強く薦める。%0a%3c %0a%3c !!Recipes for Breaking //content Dependencies%0a%3c ＜途中＞%0a%3c %0a%3c %0a%3c %0a
host:1532666307=192.168.3.2
