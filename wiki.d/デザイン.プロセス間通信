version=pmwiki-2.2.107 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1530427360
host=192.168.3.2
name=デザイン.プロセス間通信
rev=6
targets=デザイン.マルチプロセスアーキテクチャ,デザイン.IPCの安全性情報,デザイン.マルチプロセスリソースローディング
text=%25target=_blank%25https://www.chromium.org/developers/design-documents/inter-process-communication%0a%0a!!全体像%0aChromiumは[[マルチプロセスアーキテクチャ]]で多くのプロセスもち、それぞれが通信する。基本的に名前付きパイプを使う。LinuxやOS Xでは'''socketpair()'''を使う。通信は非同期でおこわなれる。%0a%0a安全はIPC端点を書くには[[IPCの安全性情報]]を参照。%0a%0a!!ブラウザ内でのIPC%0aブラウザとレンダラの通信は分離されたIOスレッドで行う。メッセージは'''ChannelProxy'''を通じて送受信される。利点としては重たくなるリソース要求（ウェブページなど）がIOスレッドで行われUIがブロックしなくなること。'''RenderProcessHost'''により'''ChannelProxy::MessageFilter'''がインストールされ、このフィルターはIOで動き、リソース要求を横取りし、それをリソースディスパッチャーへ転送する。詳しくは[[マルチプロセスリソースローディング]]を参照。%0a%0a!!レンダラでのIPC%0aそれぞれのレンダラもメッセージを処理するスレッドを持つ（ここの場合はメインスレッド）。レンダリングや他の処理は別スレッドで行う。ほとんどのメッセージはブラウザから送られ、メインスレッドを通じてWebKitに到達する、逆も真。さらに同期通信を行うスレッドもある。%0a%0a!メッセージ%0a!!メッセージの種類%0a大きく'''routed'''と'''control'''の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスは'''MessageRouter'''オブジェクトを持ち、それを登録する。%0a%0a例えばレンダリング中、controlメッセージは特定のビュー対象ではなく、'''RenderProcess'''（レンダラ側）や'''RenderProcessHost'''（ブラウザ側）で処理される。リソース要求やクリップボード操作はビュー特定の操作でないのでcontrolメッセージで行う。routedメッセージの例はビューに対する描画要求である。%0a%0aこれとは別の切り方はどちらからどちらへ送られるかで分ける場合。ドキュメントフレーム関連のメッセージがブラウザから送られれば、Frameメッセージと呼ばれる。なぜならそれは'''RenderFrame'''へ送られるから。逆の場合は'''FrameHost'''メッセージと呼ばれる。[[https://code.google.com/p/chromium/codesearch#chromium/src/content/common/frame_messages.h|frame_messages.h]]を見れば２つのセクションがあり、'''Frame'''と'''FrameHost'''で分けられている。%0a%0aビューやプラグインでも同様に'''View,ViewHost'''そして'''PluginProcess,PluginProcessHost'''となる。%0a%0a!メッセージの宣言%0aマクロが使われる。レンダラからブラウザへのroutedメッセージで引数にURLとintがある場合、以下のようになる。%0a%0a=cpp [= IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int) =]%0a%0a%0aブラウザからレンダラへのコントロールメッセージは以下のように宣言される。%0a%0a=cpp [= IPC_MESSAGE_CONTROL0(FrameMsg_MyMessage) =]%0a%0a!!値を塩漬け%0aパラメータは'''ParamTraits'''テンプレートでメッセージ本文にシリアサイズされる。この場合、テンプレートの特殊化でほとんどの型はすでに定義されている（'''ipc_message_utils.h'''）。自分で型を定義した場合は、その型の'''ParamTraits'''を定義しなければならない。%0a%0aメッセージが非常に多くの値を持つことがある。この場合、値を保持する構造体をつくる。例えば'''FrameMsg_Navigate'''メッセージだと、'''CommonNavigationParams'''構造体が定義される（'''navigation_params.h'''）。'''frame_message.h'''は'''ParamTraits'''の特殊化を定義する、このとき'''IPC_STRUCT_TRAITS'''マクロが使われる。%0a%0a!!メッセージの送信%0aメッセージは'''チャネル'''（下記参照）を通じて送られる。ブラウザでは、'''RenderProcessHost'''がチャネルを保持し、ブラウザのUIスレッドからレンダラへメッセージが送られる。'''RenderWidgetHost'''（'''RenderViewHost'''の基底クラス）は使うのに便利な'''Send'''関数を提供する。%0a%0aメッセージはポインタを使って送られ、配達されたあとIPCレイヤによってdeleteされる。よって適切な'''Send'''関数を見つけたら、'''new'''を使って送信する。%0a%0a=cpp [= Send(new ViewMsg_StopFinding(routing_id)); =]%0a%0aメッセージが適切なView/ViewHostへルートされるようにrouting IDを指定する。'''RenderWidgetHost'''（'''RenderViewHost'''の基底クラス）と'''RenderWidget'''（'''RenderView'''の基底クラス）は'''GetRoutingID()'''メンバをもつ。%0a%0a!!メッセージハンドリング%0aインタフェース"IPC::Listener"を実装することでメッセージをハンドリングする。最も重要な関数は'''OnMessageReceived'''。これを実装するための多様なマクロが用意されている。以下を例を参照。%0a%0a=cpp [=%0aMyClass::OnMessageReceived(const IPC::Message& message) {%0a  IPC_BEGIN_MESSAGE_MAP(MyClass, message)%0a    // Will call OnMyMessage with the message. The parameters of the message will be unpacked for you.%0a    IPC_MESSAGE_HANDLER(ViewHostMsg_MyMessage, OnMyMessage)  %0a    ...%0a    IPC_MESSAGE_UNHANDLED_ERROR()  // This will throw an exception for unhandled messages.%0a  IPC_END_MESSAGE_MAP()%0a}%0a%0a// This function will be called with the parameters extracted from the ViewHostMsg_MyMessage message.%0aMyClass::OnMyMessage(const GURL& url, int something) {%0a  ...%0a}%0a=]%0a'''IPC_DEFINE_MESSAGE_MAP'''を使って関数を実装することもできる。この場合、メッセージ変数名を指定しない。与えられたクラスの'''OnMessageReceived'''関数を宣言し実装する。%0a%0a他のマクロ：%0a*'''OPC_MESSAGE_FORWARD''':これは'''IPC_MESSAGE_HANDLER'''と同じだが自分のクラスを指定しメッセージを受け取れる。通常は現在のクラスに送られる。%0a%0a=cpp [= IPC_MESSAGE_FORWARD(ViewHostMsg_MyMessage, some_object_pointer, SomeObject::OnMyMessage) =]%0a%0a*'''OPC_MESSAGE_HANDLER_GENERIC''':これは自分でコードを書ける。しかし自分でメッセージパラメータをアンパックしなければならない：%0a%0a=cpp [= IPC_MESSAGE_HANDLER_GENERIC(ViewHostMsg_MyMessage, printf("Hello, world, I got the message.")) =]%0a%0a!!セキュリティの考慮%0aIPCのセキュリティバグは[[https://blog.chromium.org/2012/05/tale-of-two-pwnies-part-1.html|ひどい]]結果をもたらす（ファイル窃盗、サンドボックス脱出、リモートコード実行）。[[https://www.chromium.org/Home/chromium-security/education/security-tips-for-ipc|IPCのセキュリティ]]を調べて、落とし穴に落ちないように。%0a%0a!チャネル%0a'''IPC::Channle'''（'''ipc/ipc_channel.h'''で定義）はパイプで通信するメソッドを定義する。'''IPC::SyncChannel'''はメッセージ返信を待つための追加機能を提供する（レンダラプロセスはこれを使用するが（下記参照）、ブラウザプロセスは決して使わない）。%0a%0aチェネルはスレッドセーフではない。ときには他のスレッドにあるチャネルでメッセージを送信したくなる（例えば、IOスレッドを経由しなければならないメッセージをUIスレッドが送信したい場合）。このために、'''IPC::ChannelProxy'''を使う。これは通常のチャネルオブジェクトと同様のAPIをもつが、他のスレッドを使ったメッセージ送信のためのプロキシとなり、戻り値のためのプロキシになる。これによりオブジェクト（通常UIスレッドの）が'''IPC::ChannelProxy::Listener'''をインストールし（通常IOスレッドに）、メッセージをフィルタできる。今はこれをリソース要求や他のIOスレッドでハンドルされる要求に使っている。'''RenderProcessHost'''は'''RenderMessageFilter'''オブジェクトをインストールしフィルタリングを行う。%0a%0a!同期メッセージ%0aレンダラにとってはいくつかのメッセージは同期しなければならない。'''WebKit'''がブラウザからの返信を受け取りたい場合はだいたい当てはまる。スペルチェックや'''JavasScript'''によるクッキーの取得が当てはまる。ブラウザからレンダラへの非同期は許されない。ユーザインタフェースがブロックされ、レンダラがカクカク（flaky）になる。%0a%0a'''危険'''：UIスレッドで同期メッセージを処理しないこと！IOスレッドのみで行うこと。そうしないとアプリはデッドロックするかもしれない。プラグインはUIスレッドから同期描画を要求するので、レンダラが同期メッセージを待っているときブロックされることがあるから。%0a%0a!!同期メッセージの宣言%0a同期メッセージは'''IPC_SYNC_MESSAGE_*'''マクロで宣言される。これらのマクロは入力と戻り値をもつ（非同期メッセージは戻り値の概念がない）。２つの入力をもち、１つの戻り値をもつコントロール関数は'''2_1'''をマクロ名につけて宣言する：%0a=cpp [=%0aIPC_SYNC_MESSAGE_CONTROL2_1(SomeMessage,  // Message name%0a                            GURL, //input_param1%0a                            int, //input_param2%0a                            std::string); //result%0a=]%0a%0a同様に、ビューに回されるメッセージは'''control'''を'''routed'''に変えて'''IPC_SYNC_MESSAGE_ROUTED2_1'''のように宣言する。入力と戻り値のないものも宣言できる。戻り値がないものはレンダラがブラウザの処理を待つときに使う。ペインティングやクリップボード操作で使う。%0a%0aIssuing synchronous messages%0a
time=1531045651
author:1531045651=
diff:1531045651:1531043232:=101d100%0a%3c Issuing synchronous messages%0a
host:1531045651=192.168.3.2
author:1531043232=
diff:1531043232:1531042871:=88,99c88%0a%3c '''危険'''：UIスレッドで同期メッセージを処理しないこと！IOスレッドのみで行うこと。そうしないとアプリはデッドロックするかもしれない。プラグインはUIスレッドから同期描画を要求するので、レンダラが同期メッセージを待っているときブロックされることがあるから。%0a%3c %0a%3c !!同期メッセージの宣言%0a%3c 同期メッセージは'''IPC_SYNC_MESSAGE_*'''マクロで宣言される。これらのマクロは入力と戻り値をもつ（非同期メッセージは戻り値の概念がない）。２つの入力をもち、１つの戻り値をもつコントロール関数は'''2_1'''をマクロ名につけて宣言する：%0a%3c =cpp [=%0a%3c IPC_SYNC_MESSAGE_CONTROL2_1(SomeMessage,  // Message name%0a%3c                             GURL, //input_param1%0a%3c                             int, //input_param2%0a%3c                             std::string); //result%0a%3c =]%0a%3c %0a%3c 同様に、ビューに回されるメッセージは'''control'''を'''routed'''に変えて'''IPC_SYNC_MESSAGE_ROUTED2_1'''のように宣言する。入力と戻り値のないものも宣言できる。戻り値がないものはレンダラがブラウザの処理を待つときに使う。ペインティングやクリップボード操作で使う。%0a---%0a> 危険：UIスレッドで同期メッセージを処理しないこと！IOスレッドのみで行うこと。そうしないとアプリはデッドロックするかもしれない。プラグインはUIスレッドから同期描画を要求するので、レンダラが同期メッセージを待っているときブロックされることがあるから。%0a
host:1531043232=192.168.3.2
author:1531042871=
diff:1531042871:1531042437:=84,88d83%0a%3c %0a%3c !同期メッセージ%0a%3c レンダラにとってはいくつかのメッセージは同期しなければならない。'''WebKit'''がブラウザからの返信を受け取りたい場合はだいたい当てはまる。スペルチェックや'''JavasScript'''によるクッキーの取得が当てはまる。ブラウザからレンダラへの非同期は許されない。ユーザインタフェースがブロックされ、レンダラがカクカク（flaky）になる。%0a%3c %0a%3c 危険：UIスレッドで同期メッセージを処理しないこと！IOスレッドのみで行うこと。そうしないとアプリはデッドロックするかもしれない。プラグインはUIスレッドから同期描画を要求するので、レンダラが同期メッセージを待っているときブロックされることがあるから。%0a
host:1531042871=192.168.3.2
author:1531042437=
diff:1531042437:1531041483:=81,84d80%0a%3c '''IPC::Channle'''（'''ipc/ipc_channel.h'''で定義）はパイプで通信するメソッドを定義する。'''IPC::SyncChannel'''はメッセージ返信を待つための追加機能を提供する（レンダラプロセスはこれを使用するが（下記参照）、ブラウザプロセスは決して使わない）。%0a%3c %0a%3c チェネルはスレッドセーフではない。ときには他のスレッドにあるチャネルでメッセージを送信したくなる（例えば、IOスレッドを経由しなければならないメッセージをUIスレッドが送信したい場合）。このために、'''IPC::ChannelProxy'''を使う。これは通常のチャネルオブジェクトと同様のAPIをもつが、他のスレッドを使ったメッセージ送信のためのプロキシとなり、戻り値のためのプロキシになる。これによりオブジェクト（通常UIスレッドの）が'''IPC::ChannelProxy::Listener'''をインストールし（通常IOスレッドに）、メッセージをフィルタできる。今はこれをリソース要求や他のIOスレッドでハンドルされる要求に使っている。'''RenderProcessHost'''は'''RenderMessageFilter'''オブジェクトをインストールしフィルタリングを行う。%0a%3c %0a
host:1531042437=192.168.3.2
author:1531041483=
diff:1531041483:1530427360:=1c1%0a%3c %25target=_blank%25https://www.chromium.org/developers/design-documents/inter-process-communication%0a---%0a> [[https://www.chromium.org/developers/design-documents/inter-process-communication|オリジナル]]%0a
host:1531041483=192.168.3.2
author:1530427360=
diff:1530427360:1530427360:=1,80d0%0a%3c [[https://www.chromium.org/developers/design-documents/inter-process-communication|オリジナル]]%0a%3c %0a%3c !!全体像%0a%3c Chromiumは[[マルチプロセスアーキテクチャ]]で多くのプロセスもち、それぞれが通信する。基本的に名前付きパイプを使う。LinuxやOS Xでは'''socketpair()'''を使う。通信は非同期でおこわなれる。%0a%3c %0a%3c 安全はIPC端点を書くには[[IPCの安全性情報]]を参照。%0a%3c %0a%3c !!ブラウザ内でのIPC%0a%3c ブラウザとレンダラの通信は分離されたIOスレッドで行う。メッセージは'''ChannelProxy'''を通じて送受信される。利点としては重たくなるリソース要求（ウェブページなど）がIOスレッドで行われUIがブロックしなくなること。'''RenderProcessHost'''により'''ChannelProxy::MessageFilter'''がインストールされ、このフィルターはIOで動き、リソース要求を横取りし、それをリソースディスパッチャーへ転送する。詳しくは[[マルチプロセスリソースローディング]]を参照。%0a%3c %0a%3c !!レンダラでのIPC%0a%3c それぞれのレンダラもメッセージを処理するスレッドを持つ（ここの場合はメインスレッド）。レンダリングや他の処理は別スレッドで行う。ほとんどのメッセージはブラウザから送られ、メインスレッドを通じてWebKitに到達する、逆も真。さらに同期通信を行うスレッドもある。%0a%3c %0a%3c !メッセージ%0a%3c !!メッセージの種類%0a%3c 大きく'''routed'''と'''control'''の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスは'''MessageRouter'''オブジェクトを持ち、それを登録する。%0a%3c %0a%3c 例えばレンダリング中、controlメッセージは特定のビュー対象ではなく、'''RenderProcess'''（レンダラ側）や'''RenderProcessHost'''（ブラウザ側）で処理される。リソース要求やクリップボード操作はビュー特定の操作でないのでcontrolメッセージで行う。routedメッセージの例はビューに対する描画要求である。%0a%3c %0a%3c これとは別の切り方はどちらからどちらへ送られるかで分ける場合。ドキュメントフレーム関連のメッセージがブラウザから送られれば、Frameメッセージと呼ばれる。なぜならそれは'''RenderFrame'''へ送られるから。逆の場合は'''FrameHost'''メッセージと呼ばれる。[[https://code.google.com/p/chromium/codesearch#chromium/src/content/common/frame_messages.h|frame_messages.h]]を見れば２つのセクションがあり、'''Frame'''と'''FrameHost'''で分けられている。%0a%3c %0a%3c ビューやプラグインでも同様に'''View,ViewHost'''そして'''PluginProcess,PluginProcessHost'''となる。%0a%3c %0a%3c !メッセージの宣言%0a%3c マクロが使われる。レンダラからブラウザへのroutedメッセージで引数にURLとintがある場合、以下のようになる。%0a%3c %0a%3c =cpp [= IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int) =]%0a%3c %0a%3c %0a%3c ブラウザからレンダラへのコントロールメッセージは以下のように宣言される。%0a%3c %0a%3c =cpp [= IPC_MESSAGE_CONTROL0(FrameMsg_MyMessage) =]%0a%3c %0a%3c !!値を塩漬け%0a%3c パラメータは'''ParamTraits'''テンプレートでメッセージ本文にシリアサイズされる。この場合、テンプレートの特殊化でほとんどの型はすでに定義されている（'''ipc_message_utils.h'''）。自分で型を定義した場合は、その型の'''ParamTraits'''を定義しなければならない。%0a%3c %0a%3c メッセージが非常に多くの値を持つことがある。この場合、値を保持する構造体をつくる。例えば'''FrameMsg_Navigate'''メッセージだと、'''CommonNavigationParams'''構造体が定義される（'''navigation_params.h'''）。'''frame_message.h'''は'''ParamTraits'''の特殊化を定義する、このとき'''IPC_STRUCT_TRAITS'''マクロが使われる。%0a%3c %0a%3c !!メッセージの送信%0a%3c メッセージは'''チャネル'''（下記参照）を通じて送られる。ブラウザでは、'''RenderProcessHost'''がチャネルを保持し、ブラウザのUIスレッドからレンダラへメッセージが送られる。'''RenderWidgetHost'''（'''RenderViewHost'''の基底クラス）は使うのに便利な'''Send'''関数を提供する。%0a%3c %0a%3c メッセージはポインタを使って送られ、配達されたあとIPCレイヤによってdeleteされる。よって適切な'''Send'''関数を見つけたら、'''new'''を使って送信する。%0a%3c %0a%3c =cpp [= Send(new ViewMsg_StopFinding(routing_id)); =]%0a%3c %0a%3c メッセージが適切なView/ViewHostへルートされるようにrouting IDを指定する。'''RenderWidgetHost'''（'''RenderViewHost'''の基底クラス）と'''RenderWidget'''（'''RenderView'''の基底クラス）は'''GetRoutingID()'''メンバをもつ。%0a%3c %0a%3c !!メッセージハンドリング%0a%3c インタフェース"IPC::Listener"を実装することでメッセージをハンドリングする。最も重要な関数は'''OnMessageReceived'''。これを実装するための多様なマクロが用意されている。以下を例を参照。%0a%3c %0a%3c =cpp [=%0a%3c MyClass::OnMessageReceived(const IPC::Message& message) {%0a%3c   IPC_BEGIN_MESSAGE_MAP(MyClass, message)%0a%3c     // Will call OnMyMessage with the message. The parameters of the message will be unpacked for you.%0a%3c     IPC_MESSAGE_HANDLER(ViewHostMsg_MyMessage, OnMyMessage)  %0a%3c     ...%0a%3c     IPC_MESSAGE_UNHANDLED_ERROR()  // This will throw an exception for unhandled messages.%0a%3c   IPC_END_MESSAGE_MAP()%0a%3c }%0a%3c %0a%3c // This function will be called with the parameters extracted from the ViewHostMsg_MyMessage message.%0a%3c MyClass::OnMyMessage(const GURL& url, int something) {%0a%3c   ...%0a%3c }%0a%3c =]%0a%3c '''IPC_DEFINE_MESSAGE_MAP'''を使って関数を実装することもできる。この場合、メッセージ変数名を指定しない。与えられたクラスの'''OnMessageReceived'''関数を宣言し実装する。%0a%3c %0a%3c 他のマクロ：%0a%3c *'''OPC_MESSAGE_FORWARD''':これは'''IPC_MESSAGE_HANDLER'''と同じだが自分のクラスを指定しメッセージを受け取れる。通常は現在のクラスに送られる。%0a%3c %0a%3c =cpp [= IPC_MESSAGE_FORWARD(ViewHostMsg_MyMessage, some_object_pointer, SomeObject::OnMyMessage) =]%0a%3c %0a%3c *'''OPC_MESSAGE_HANDLER_GENERIC''':これは自分でコードを書ける。しかし自分でメッセージパラメータをアンパックしなければならない：%0a%3c %0a%3c =cpp [= IPC_MESSAGE_HANDLER_GENERIC(ViewHostMsg_MyMessage, printf("Hello, world, I got the message.")) =]%0a%3c %0a%3c !!セキュリティの考慮%0a%3c IPCのセキュリティバグは[[https://blog.chromium.org/2012/05/tale-of-two-pwnies-part-1.html|ひどい]]結果をもたらす（ファイル窃盗、サンドボックス脱出、リモートコード実行）。[[https://www.chromium.org/Home/chromium-security/education/security-tips-for-ipc|IPCのセキュリティ]]を調べて、落とし穴に落ちないように。%0a%3c %0a%3c !チャネル%0a
host:1530427360=192.168.3.2
