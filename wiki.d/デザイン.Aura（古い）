version=pmwiki-2.2.102 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1530316223
host=192.168.3.2
name=デザイン.Aura（古い）
rev=10
targets=
text=https://www.chromium.org/developers/design-documents/aura-desktop-window-manager%0a%0a''このドキュメントは外観には使えるが古い''%0a%0a!プロジェクトの目的%0a新しいウィンドウマネージャとシェル環境を作る。ハードウェアアクセラレーションを使ったリッチな見栄えで、アニメイテッドなエフェクトのUIを構築する。%0a%0a制限や目標%0a*クロスプラットフォーム%0a*ハードウェアの利用による拡大可能なパフォーマンス%0a*ChromeとChromeOSの基礎%0a%0a初期の目標じゃないもの%0a*マルチモニター%0a*ソフトウェアレンダリングとリモートデスクトップ%0a*NPAPIプラグインサポート、これは決して必要ない。Pepperプラグインのみサポートされる。%0a%0a!UIデザイン%0aOwner: Nicholas Jitkoff (alcor@) (UX) and Kan Liu (kanliu@) (PM)%0a%0a!Quick Chrome UI Implementation Backgrounder%0aWindowsのChromeとChrome OSのUIは''src/views''にあるView UI frameworkを使う。ウインドウのコンテントはビューの階層により構築される。ビューのサブクラスはいろいろなコントロールやコンポーネント（ボタンやツールバーなどの）を実装する。いままでは、見栄えをカスタムするためには手作りのコントロールを使っていた（ブラウザのツールバーやタブストリップ）し、OSが提供するコントロールを使っていた。Win32 APIやGtk（Chrome OSの場合）。%0a%0aビュー階層はWidgetによってホストされる。Widgetはクロスプラットフォームの型で、プラットフォーム依存のNativeWidgetに依存する。WindowsではNativeWidgetはHWNDをラップし（WindowImpl経由で）Windowsメッセージを処理する。GtkではNativeWidgetGtkがGtkWidgetをラップしシグナルを処理する。%0a%0aChromeのUIはもともとWindows用に書かれていた。ビューはもともとプラットフォームニュートラル的だがコードはWin32に深く依存していた。Chromeチームの哲学”完全を善の敵にしない”に従い、短期の成功のための道が選択された。MacとLinuxのChromeはUIに対して別の戦略をとった。積極的にプラットフォームが提供するツールキット（CocoaとGtk）を使った。なのでChrome OSはWin32の影響がifdefによってGtk的に補強された。%0a%0aプラットフォーム部品に頼ったことでハードウェア加速が利用しづらくなった。ここからAuraが始まった。%0a%0a!Platform Native Control (aka Gtk/HWND) Elimination%0aOwner: Emmanuel Saint-Loubert-Bié (saintlou@)%0aGtk/HWNDの使用が行き渡っている。それらを除去するためにやるべき仕事は以下のようなもの：%0a*Options UIからWebUIへの変換。オプションダイアログは多くのGtkを使っている。WebUIに置き換えることでコントロールの数を減らす。%0a*他のダイアログのWebUIへの変換。%0a*Textfiledなどをビューベースで書く。%0a*Auraベースの''RenderWidgetHostView''を書く。%0a%0a!ハードウェア加速によるレンダリング・合成%0aOwner: Antoine Labour (piman@)%0a%0aChromeが始まったときには２つの合成機があった。WebKitで使われたCSS遷移をハードウェア加速させた合成機、ブラウザプロセスのUIスレッドで動くブラウザ合成機（フルスクリーン回転などのビュー変換の実装）。%0a%0aいろいろな理由により、合成機の統合が望まれた。主要な理由はハードに合わせたパフォーマンスの実現である。それには１つの合成機と描画パスが必要である。ある時点でレイヤツリーの統合も実現したいがこれは大きな問題になることはない。%0a%0aブラウザ合成機は''ui::Compositor''の実装により実現している。WebKit-CC合成機を使った実装であるAntoineも進行している。このようにUIは引き続き''ui::Layer''APIを利用している。述べたようにこれらを１つにする予定である。%0a%0a合成機は明確に区別されたChromeコードのコンポーネントである。ずっと後になればWebKit合成機はWebKitから抜き出され、WebKitすべてをAuraやViewsで使う必要はなくなる。%0a%0ahttps://www.chromium.org/developers/design-documents/aura-desktop-window-manager/Chrome%2520Graphics%2520Infrastructure.png%0a%0a!Aura WMとシェル%0aOwner: Ben Goodger (beng@) and Scott Violet (sky@)%0a!!Aura%0aOwner: Ben Goodger (beng@) and Scott Violet (sky@)%0a%0a大規模なウインドウ変遷を実演するするには、合成機レイヤがWindowsを背負わなければならない、そうすることにより再描画することなくアニメートできる。これを実現するためには単純ウインドウ型を開発し、それはビューのNativeWiget型と互換APIをサポートする必要がある。最初はビューが背負ったビューデスクトップと呼ばれるNativeWidget実装（NativeWidgetViewsと呼ばれる）を試みた。しかしそれでもその階層をホストするためプラットフォーム依存の部品（NativeWidgetWinやNativeWidgetGtk）を必要とした。大きな挑戦の対象はChromeコードに普及している''gfx::NativeView/NativeWindow''である。これがGtkWidgetやHWNDを解決するものと期待されている。この考えから''NativeWidgetWin/NativeWidgetGtkが生まれ、ウインドウを適切に扱うための多くの挑戦にさらされている。%0aいままではコードに対してNativeViewを期待するトップレベルウインドウしか提供しておらずローカライズされたウインドウはなかった。''views::View''はNativeViewになれないためである。このような問題と大きいビュー階層問題がシンプルな''aura::Window''型へ導いた。''aura::Window''は我々が''NativeView/NativeWindow''と考えるものである（このようにtypedefされている）。ビューシステムに於いて、この型''NativeWidgetAura''をターゲットとした新しい''NativeWidget''が実装され、''GetNativeView()''からの戻り値で返られなければならない。''aura::Window''は合成機レイヤをラップし、イベント処理やレイヤの描画処理を持つ代表者をもつ。%0a%0a''aura::Windows''は''Views''と似ていが単純化されている。''aura::Desktop''内の１階層である。''aura::Desktop''は''aura::DesktopHost''に拘束され、そこにプラットフォーム特有のコードがある。HWNDをラップする''DesktopHost''もあれば、X windowをラップするそれもある、この考え方からはGtkは存在しない。これはこのように考えられる。つまりプラットフォーム固有のコードはビューから離れ１つのレイヤに押し込められ、画面に描画される。その中に存在するすべてのウインドウは合成している。''DesktopHost''ウインドウは、低レベルのプラットフォームイベントを受け取り、''aura::Events''に変形し、auraウインドウへ送る。auraウインドウは代表者へ送る。ビュー側では、''NativeWidgetAura''が''aura::Window''の代表者であり、''aura::Event''を受け取り（それはプラットフォーム固有イベントとみなされる）、関連する''views::Event''型が構築され、組み込まれたビュー階層へ伝達される。Auraはウインドウ階層、イベント変形と伝達にに責任を持ち、フォーカスやアクティブ化の機能に責任を持つ。Auraがビューに利用されるからと言って、ビューそのものを使うものではないことに注意すること。それは玉ねぎの仮想での話で、HWNDやGtkWidgetの用に考えること。%0a%0a!!The Aura Shell and Chrome Integration%0aOwner: Zelidrag Hornung (zelidrag@) and David Moore (davemoore@)%0aデスクトップ環境は単なるウインドウ型ではない。移動やサイズ変更などのウインドウマネージャ機能を実装した遊び場が必要であっし、画面下部のランチャー機能やステータスエリアであった。これを直接構築するよりも、別コンポーネントとして構築することに決定した。それらはUIコンポーネントやランチャのウインドウ枠から構成されるため、AuraだけでなくViewに依存する必要があるからである。%0a%0a生産物は''aura_shell''と呼ばれるシェルライブラリで、Chromeで使えるものである。テスト機能ももち''aura_shell.exe''と呼ばれる。これはシェルを作成し、いくつかのサンプルウインドウを起動し、機能をテストする。シェル内では、本来ならユーザデータから展開されるモデルは偽装モデルにより提供される。Chromeで実行されたときは本当のデータが提供される。%0a%0aChromeOSのUIチームが特にこの機能のために働いている。%0a%0a!実装戦略%0a%0a複雑なプロジェクトなので、副作用も生じる。作業を分解すると、合成機、Gtk除去、Aura、AuraシェルとChromeの統合になる。%0a%0aやることが多いので並行して行う。２つの合成機があってはプロジェクトが始まらないので、ウインドウシステムと１つの合成機の作業から始まる。同様に、組み込みビューでの基本シェル動作により、ランチャのようなシェルコンポーネント作業が始まる。同時にウインドウシステムを拡張する。同様に、その背後でApp ListのようなWebUIコンポーネントも始まる。%0a%0a新しいWidgetシステムの構築なので、新しいターゲットプラットフォームのためのUIと考えるべきである。よってportと考えるべきである。%0a%0a''use_aura=1''設定でビルドできる。LinuxとWindowsで動く、このフラグでコンポーネントもビルドされるべきである。%0a
time=1530325059
author:1530325059=
diff:1530325059:1530324301:=68,77d67%0a%3c %0a%3c !実装戦略%0a%3c %0a%3c 複雑なプロジェクトなので、副作用も生じる。作業を分解すると、合成機、Gtk除去、Aura、AuraシェルとChromeの統合になる。%0a%3c %0a%3c やることが多いので並行して行う。２つの合成機があってはプロジェクトが始まらないので、ウインドウシステムと１つの合成機の作業から始まる。同様に、組み込みビューでの基本シェル動作により、ランチャのようなシェルコンポーネント作業が始まる。同時にウインドウシステムを拡張する。同様に、その背後でApp ListのようなWebUIコンポーネントも始まる。%0a%3c %0a%3c 新しいWidgetシステムの構築なので、新しいターゲットプラットフォームのためのUIと考えるべきである。よってportと考えるべきである。%0a%3c %0a%3c ''use_aura=1''設定でビルドできる。LinuxとWindowsで動く、このフラグでコンポーネントもビルドされるべきである。%0a
host:1530325059=192.168.3.2
author:1530324301=
diff:1530324301:1530319606:=53,67c53%0a%3c !!Aura%0a%3c Owner: Ben Goodger (beng@) and Scott Violet (sky@)%0a%3c %0a%3c 大規模なウインドウ変遷を実演するするには、合成機レイヤがWindowsを背負わなければならない、そうすることにより再描画することなくアニメートできる。これを実現するためには単純ウインドウ型を開発し、それはビューのNativeWiget型と互換APIをサポートする必要がある。最初はビューが背負ったビューデスクトップと呼ばれるNativeWidget実装（NativeWidgetViewsと呼ばれる）を試みた。しかしそれでもその階層をホストするためプラットフォーム依存の部品（NativeWidgetWinやNativeWidgetGtk）を必要とした。大きな挑戦の対象はChromeコードに普及している''gfx::NativeView/NativeWindow''である。これがGtkWidgetやHWNDを解決するものと期待されている。この考えから''NativeWidgetWin/NativeWidgetGtkが生まれ、ウインドウを適切に扱うための多くの挑戦にさらされている。%0a%3c いままではコードに対してNativeViewを期待するトップレベルウインドウしか提供しておらずローカライズされたウインドウはなかった。''views::View''はNativeViewになれないためである。このような問題と大きいビュー階層問題がシンプルな''aura::Window''型へ導いた。''aura::Window''は我々が''NativeView/NativeWindow''と考えるものである（このようにtypedefされている）。ビューシステムに於いて、この型''NativeWidgetAura''をターゲットとした新しい''NativeWidget''が実装され、''GetNativeView()''からの戻り値で返られなければならない。''aura::Window''は合成機レイヤをラップし、イベント処理やレイヤの描画処理を持つ代表者をもつ。%0a%3c %0a%3c ''aura::Windows''は''Views''と似ていが単純化されている。''aura::Desktop''内の１階層である。''aura::Desktop''は''aura::DesktopHost''に拘束され、そこにプラットフォーム特有のコードがある。HWNDをラップする''DesktopHost''もあれば、X windowをラップするそれもある、この考え方からはGtkは存在しない。これはこのように考えられる。つまりプラットフォーム固有のコードはビューから離れ１つのレイヤに押し込められ、画面に描画される。その中に存在するすべてのウインドウは合成している。''DesktopHost''ウインドウは、低レベルのプラットフォームイベントを受け取り、''aura::Events''に変形し、auraウインドウへ送る。auraウインドウは代表者へ送る。ビュー側では、''NativeWidgetAura''が''aura::Window''の代表者であり、''aura::Event''を受け取り（それはプラットフォーム固有イベントとみなされる）、関連する''views::Event''型が構築され、組み込まれたビュー階層へ伝達される。Auraはウインドウ階層、イベント変形と伝達にに責任を持ち、フォーカスやアクティブ化の機能に責任を持つ。Auraがビューに利用されるからと言って、ビューそのものを使うものではないことに注意すること。それは玉ねぎの仮想での話で、HWNDやGtkWidgetの用に考えること。%0a%3c %0a%3c !!The Aura Shell and Chrome Integration%0a%3c Owner: Zelidrag Hornung (zelidrag@) and David Moore (davemoore@)%0a%3c デスクトップ環境は単なるウインドウ型ではない。移動やサイズ変更などのウインドウマネージャ機能を実装した遊び場が必要であっし、画面下部のランチャー機能やステータスエリアであった。これを直接構築するよりも、別コンポーネントとして構築することに決定した。それらはUIコンポーネントやランチャのウインドウ枠から構成されるため、AuraだけでなくViewに依存する必要があるからである。%0a%3c %0a%3c 生産物は''aura_shell''と呼ばれるシェルライブラリで、Chromeで使えるものである。テスト機能ももち''aura_shell.exe''と呼ばれる。これはシェルを作成し、いくつかのサンプルウインドウを起動し、機能をテストする。シェル内では、本来ならユーザデータから展開されるモデルは偽装モデルにより提供される。Chromeで実行されたときは本当のデータが提供される。%0a%3c %0a%3c ChromeOSのUIチームが特にこの機能のために働いている。%0a---%0a> To allow us to perform large scale window transitions, we need to back Windows by compositor layers so that we can animate them without redrawing. This led to the development of a simple window type that supported an API compatible with (i.e. implementing the other side of the contract expected by) the Views NativeWidget type. We had initially tried to do this with a View-backed NativeWidget implementation (called NativeWidgetViews) called the views-desktop. However we still needed a platform-native widget (NativeWidgetWin/NativeWidgetGtk) to host the hierarchy. A big challenge was that pervasive in Chrome code is the concept of a gfx::NativeView/NativeWindow, which on Chrome OS and Windows was expected to resolve to a GtkWidget or an HWND. This assumption is also baked into NativeWidgetWin/NativeWidgetGtk and thus we were presented with many challenges parenting windows properly, since we could only ever offer the top level (desktop/screen-level window) as a parent to code that expected a NativeView, rather than a more localized (and probably more correct) window, because a views::View couldn't be a NativeView.%0a
host:1530324301=192.168.3.2
author:1530319606=
diff:1530319606:1530319556:=
host:1530319606=192.168.3.2
author:1530319556=
diff:1530319556:1530319460:=51,53d50%0a%3c !Aura WMとシェル%0a%3c Owner: Ben Goodger (beng@) and Scott Violet (sky@)%0a%3c To allow us to perform large scale window transitions, we need to back Windows by compositor layers so that we can animate them without redrawing. This led to the development of a simple window type that supported an API compatible with (i.e. implementing the other side of the contract expected by) the Views NativeWidget type. We had initially tried to do this with a View-backed NativeWidget implementation (called NativeWidgetViews) called the views-desktop. However we still needed a platform-native widget (NativeWidgetWin/NativeWidgetGtk) to host the hierarchy. A big challenge was that pervasive in Chrome code is the concept of a gfx::NativeView/NativeWindow, which on Chrome OS and Windows was expected to resolve to a GtkWidget or an HWND. This assumption is also baked into NativeWidgetWin/NativeWidgetGtk and thus we were presented with many challenges parenting windows properly, since we could only ever offer the top level (desktop/screen-level window) as a parent to code that expected a NativeView, rather than a more localized (and probably more correct) window, because a views::View couldn't be a NativeView.%0a
host:1530319556=192.168.3.2
author:1530319460=
diff:1530319460:1530318910:=44,49d43%0a%3c %0a%3c ブラウザ合成機は''ui::Compositor''の実装により実現している。WebKit-CC合成機を使った実装であるAntoineも進行している。このようにUIは引き続き''ui::Layer''APIを利用している。述べたようにこれらを１つにする予定である。%0a%3c %0a%3c 合成機は明確に区別されたChromeコードのコンポーネントである。ずっと後になればWebKit合成機はWebKitから抜き出され、WebKitすべてをAuraやViewsで使う必要はなくなる。%0a%3c %0a%3c https://www.chromium.org/developers/design-documents/aura-desktop-window-manager/Chrome%2520Graphics%2520Infrastructure.png%0a
host:1530319460=192.168.3.2
author:1530318910=
diff:1530318910:1530317817:=32,44d31%0a%3c Gtk/HWNDの使用が行き渡っている。それらを除去するためにやるべき仕事は以下のようなもの：%0a%3c *Options UIからWebUIへの変換。オプションダイアログは多くのGtkを使っている。WebUIに置き換えることでコントロールの数を減らす。%0a%3c *他のダイアログのWebUIへの変換。%0a%3c *Textfiledなどをビューベースで書く。%0a%3c *Auraベースの''RenderWidgetHostView''を書く。%0a%3c %0a%3c !ハードウェア加速によるレンダリング・合成%0a%3c Owner: Antoine Labour (piman@)%0a%3c %0a%3c Chromeが始まったときには２つの合成機があった。WebKitで使われたCSS遷移をハードウェア加速させた合成機、ブラウザプロセスのUIスレッドで動くブラウザ合成機（フルスクリーン回転などのビュー変換の実装）。%0a%3c %0a%3c いろいろな理由により、合成機の統合が望まれた。主要な理由はハードに合わせたパフォーマンスの実現である。それには１つの合成機と描画パスが必要である。ある時点でレイヤツリーの統合も実現したいがこれは大きな問題になることはない。%0a%3c %0a
host:1530318910=192.168.3.2
author:1530317817=
diff:1530317817:1530316657:=19,31d18%0a%3c Owner: Nicholas Jitkoff (alcor@) (UX) and Kan Liu (kanliu@) (PM)%0a%3c %0a%3c !Quick Chrome UI Implementation Backgrounder%0a%3c WindowsのChromeとChrome OSのUIは''src/views''にあるView UI frameworkを使う。ウインドウのコンテントはビューの階層により構築される。ビューのサブクラスはいろいろなコントロールやコンポーネント（ボタンやツールバーなどの）を実装する。いままでは、見栄えをカスタムするためには手作りのコントロールを使っていた（ブラウザのツールバーやタブストリップ）し、OSが提供するコントロールを使っていた。Win32 APIやGtk（Chrome OSの場合）。%0a%3c %0a%3c ビュー階層はWidgetによってホストされる。Widgetはクロスプラットフォームの型で、プラットフォーム依存のNativeWidgetに依存する。WindowsではNativeWidgetはHWNDをラップし（WindowImpl経由で）Windowsメッセージを処理する。GtkではNativeWidgetGtkがGtkWidgetをラップしシグナルを処理する。%0a%3c %0a%3c ChromeのUIはもともとWindows用に書かれていた。ビューはもともとプラットフォームニュートラル的だがコードはWin32に深く依存していた。Chromeチームの哲学”完全を善の敵にしない”に従い、短期の成功のための道が選択された。MacとLinuxのChromeはUIに対して別の戦略をとった。積極的にプラットフォームが提供するツールキット（CocoaとGtk）を使った。なのでChrome OSはWin32の影響がifdefによってGtk的に補強された。%0a%3c %0a%3c プラットフォーム部品に頼ったことでハードウェア加速が利用しづらくなった。ここからAuraが始まった。%0a%3c %0a%3c !Platform Native Control (aka Gtk/HWND) Elimination%0a%3c Owner: Emmanuel Saint-Loubert-Bié (saintlou@)%0a
host:1530317817=192.168.3.2
author:1530316657=
diff:1530316657:1530316281:=6,18d5%0a%3c 新しいウィンドウマネージャとシェル環境を作る。ハードウェアアクセラレーションを使ったリッチな見栄えで、アニメイテッドなエフェクトのUIを構築する。%0a%3c %0a%3c 制限や目標%0a%3c *クロスプラットフォーム%0a%3c *ハードウェアの利用による拡大可能なパフォーマンス%0a%3c *ChromeとChromeOSの基礎%0a%3c %0a%3c 初期の目標じゃないもの%0a%3c *マルチモニター%0a%3c *ソフトウェアレンダリングとリモートデスクトップ%0a%3c *NPAPIプラグインサポート、これは決して必要ない。Pepperプラグインのみサポートされる。%0a%3c %0a%3c !UIデザイン%0a
host:1530316657=192.168.3.2
author:1530316281=
diff:1530316281:1530316223:=1,5c1%0a%3c https://www.chromium.org/developers/design-documents/aura-desktop-window-manager%0a%3c %0a%3c ''このドキュメントは外観には使えるが古い''%0a%3c %0a%3c !プロジェクトの目的%0a---%0a> https://www.chromium.org/developers/design-documents/aura-desktop-window-manager%0a\ No newline at end of file%0a
host:1530316281=192.168.3.2
author:1530316223=
diff:1530316223:1530316223:=1d0%0a%3c https://www.chromium.org/developers/design-documents/aura-desktop-window-manager%0a\ No newline at end of file%0a
host:1530316223=192.168.3.2
