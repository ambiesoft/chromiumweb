version=pmwiki-2.2.102 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1503827782
host=192.168.3.2
name=開発者向け.抽象化とデータ構造
rev=9
targets=
text=https://www.chromium.org/developers/coding-style/important-abstractions-and-data-structures%0a%0a!''TaskRunner''と''SequencedTaskRunner''と''SingleThreadTaskRunner''%0a''base::Callbacks''のタスクを''TaskRunner''で実行するためのインターフェース。''TaskRunner''は実行を保証しない（順序、同期、または全く実行されないなど）。''SequencedTaskRunnder''は実行の順序をあるていど保証する（大まかにいえばFIFO、でも詳細はコードを見て）。''SingleThreadTaskRunner''は''SequencedTaskRunner''と同じくらい保証するが、すべてのタスクは同じスレッドで行われる。''MessageLoopProxy''は規範的な''SingleThreadTaskRunner''の実例。これらのインターフェースは独立性投入経由でテストをするのに役立つ。注：''TaskRunner''のポストに成功したからといって実行されるとは限らない。%0a%0a注：TaskRunnerのメンバ関数PostTaskAndReply()は'''とても'''役に立つ。仕事が終わったら元の人にリプライを返してくれる。%0a%0a!''MessageLoop''と''MessageLoopProxy''と''BrowserThread''と''RunLoop''%0aこれらはタスクをポストするための様々なAPI。''MessageLoop''は''MessageLoopProxy''によって使われる具体オブジェクト（Chromiumでもっとも広く使われるコード）。''MessageLoop''の代わりに''MessageLoopProxy''を使うべき、もし''chrome/''や''content/''のコードの中なら、''BrowserThread''を使うことができる。''MessageLoop''デストラクト時に起こるレーシングも回避している。''MessageLoopProxy''と''BrowserThread''は配下の''MessageLoop''が消えた後はタスクを削除する。注：''MessageLoop(Proxy)''へのポストが成功したからといって、タスクが実行されるとは限らない。%0a%0a追記：''SequencedTaskRunner''や''MessageLoopProxy'',''BrowserThread''をいつ使うべきかには議論がある。インタフェースクァすである''SequencedTaskRunner''はコードをより抽象化・再利用化・テスト可能化する。一方直接性が失われるため、コードが明白でなくなる。具体クラスの''BrowserThread''IDは直接的明白で、そのスレッドで実行されることがわかる。もっとも''SequencedTaskRunner''変数を適切に命名することでより明白にはなる。現時点での決定は、必要に応じて、''BrowserThread''のコードを''TaskRunner''サブクラスに変えていくことのみである。''MessageLoopProxy''は''SingleThreadTaskRunner''または''SequencedTaskRunner''インタフェースとしてやり取りされるべきだろうと思われる。%0a%0a!''base::SequencedWorkerPool''と''base::WorkerPool''%0aChromiumでの２つの主要なワーカプール。''SequencedWorderPool''はもっとも複雑なワーカプールで''TaskRunner''から継承し、シーケンスにタスクを処理する方法を提供する（''SequenceToken''の共有により）。それからシャットダウン時の動作も指定できる（タスク実行時はシャットダウンをブロック、ブラウザがシャットダウン時はタスクを実行しないか実行していたならシャットダウンをブロック、ブラウザのシャットダウンに関わりなく実行を許可してシャットダウンをブロックしない、など）。%0aSequencedWorkerPool also provides a facility to return a SequencedTaskRunner based on a SequenceToken. The Chromium browser process will shutdown base::SequencedWorkerPool after all main browser threads (other than the main thread) have stopped. base::WorkerPool is a global object that is not shutdown on browser process shutdown, so all the tasks running on it will not be joined. It's generally unadvisable to use base::WorkerPool since tasks may have dependencies on other objects that may be in the process of being destroyed during browser shutdown.%0a%0a%0a%0a!''base::Callback''と''base::Bind()''%0a''base::Callback''は内部的に参照カウントされたコールバッククラス、可変長引数で任意の戻り値のコールバックに対応。コピー可能だが関数ポインタとバインドされた引数は共有する。''base::Bind()''は引数と関数ポインタをバインドして（内部では関数ポインタと引数を参照カウンタオブジェクトで管理）''base::Callback''を返す。''base::Bind()''にメンバ関数が渡されたときは魔法のように自動的に最初の引数に対して''AddRef()/Release()''が実行される。もしそれが参照カウンタオブジェクトでないなら怒られる（これを防ぐには''base::WeakPtr''か''base::Unretained''を使う。また引数については、''COMPILE_ASSERT''を使いそれらが参照カウンタ対象への生ポインタでないかを検証する（forwardされていない完全型情報のときのみ可能）。バグを防ぐためには、''scoped_refptrs''か''make_scoped_refptr()''を使うこと。更に、''base::Bind()''は''base::WeakPtr''を理解している。もし関数がメンバ関数で最初の引数が''base::WeakPtr''なら、''base::Bind()''はラッパ関数を挿入し、WeakPtrがNULLでないときのみ実行する。''base::Bind()''は引数のために以下のようなヘルパ関数を提供する。%0a*''base::Unretained()''はメンバ関数のオブジェクト（それは参照カウントされていないタイプかもしれない）の参照カウントを無効にし、引数の''COMPILE_ASSERT''を無効にする。オブジェクトの生存時間に注意して使うこと。この点''base::WeakPtr''の方が安全である。%0a*''base::Owned()''は生ポインタのオーナーを戻り値の''base::Callback''ストレージに移転する。''TaskRunner''はシャットダウン時の実行を保証しないため（そこでオブジェクトを削除したいかもしれない）コールバックが所有権を持てば、シャットダウン時のリークを防げる。%0a*''base::Passed()''は%0abase::Passed() - useful for passing a scoped object (scoped_ptr/ScopedVector/etc) to a callback. The primary difference between base::Owned() and base::Passed() is base::Passed() requires the function signature take the scoped type as a parameter, and thus allows for transferring ownership via .release(). NOTE: since the scope of the scoped type is the function scope, that means the base::Callback must only be called once. Otherwise, it would be a potential use after free and a definite double delete. Given the complexity of base::Passed()'s semantics in comparison to base::Owned(), you should prefer base::Owned() to base::Passed() in general.%0abase::ConstRef() - passes an argument as a const reference instead of copying it into the internal callback storage. Useful for obvious performance reasons, but generally should not be used, since it requires that the lifetime of the referent must live beyond when the callback can be invoked.%0abase::IgnoreResult() - use this with the function pointer passed to base::Bind() to ignore the result. Useful to make the callback usable with a TaskRunner which only takes Closures (callbacks with no parameters nor return values).%0ascoped_refptr%3cT> & base::RefCounted & base::RefCountedThreadSafe%0aReference counting is occasionally useful but is more often a sign that someone isn't thinking carefully about ownership. Use it when ownership is truly shared (for example, multiple tabs sharing the same renderer process), not for when lifetime management is difficult to reason about.%0aSingleton & base::LazyInstance%0aThey're globals, so you generally should avoid using them, as per the style guide. That said, when you use globals in Chromium code, it's often good to use one of these, and in general, prefer base::LazyInstance over Singleton. The reason to use these classes is construction is lazy (thereby preventing startup slowdown due to static initializers) and destruction order is well-defined. They are all destroyed in opposite order as construction when the AtExitManager is destroyed. In the Chromium browser process, the AtExitManager is instantiated early on in the main thread (the UI thread), so all of these objects will be destroyed on the main thread, even if constructed on a different thread. The reason to prefer base::LazyInstance over base::Singleton is base::LazyInstance reduces heap fragmentation by reserving space in the data segment and using placement new to construct the object in that memory location. NOTE: Both Singleton and base::LazyInstance provide "leaky" traits to leak the global on shutdown. This is often advisable (except potentially in library code where the code may be dynamically loaded into another process's address space or when data needs to be flushed on process shutdown) in order to not to slow down shutdown. There are valgrind suppressions for these "leaky" traits.%0abase::Thread & base::PlatformThread%0aGenerally you shouldn't use these, since you should usually post tasks to an existing TaskRunner. PlatformThread is a platform-specific thread. base::Thread contains a MessageLoop running on a PlatformThread.%0abase::WeakPtr & base::WeakPtrFactory%0aMostly thread-unsafe weak pointer that returns NULL if the referent has been destroyed. It's safe to pass across threads (and to destroy on other threads), but it should only be used on the original thread it was created on. base::WeakPtrFactory is useful for automatically canceling base::Callbacks when the referent of the base::WeakPtr gets destroyed.%0aFilePath%0aA cross-platform representation of a file path. You should generally use this instead of platform-specific representations.%0aObserverList & ObserverListThreadSafe%0aObserverList is a thread-unsafe object that is intended to be used as a member variable of a class. It provides a simple interface for iterating on a bunch of Observer objects and invoking a notification method.%0a%0aObserverListThreadSafe similar. It contains multiple ObserverLists, and observer notifications are invoked on the same PlatformThreadId that the observer was registered on, thereby allowing proxying notifications across threads and allowing the individual observers to receive notifications in a single threaded manner.%0aPickle%0aPickle provides a basic facility for object serialization and deserialization in binary form.%0aValue%0aValues allow for specifying recursive data classes (lists and dictionaries) containing simple values (bool/int/string/etc). These values can also be serialized to JSON and back.%0aLOG%0aThis is the basic interface for logging in Chromium.%0aFileUtilProxy%0aGenerally you should not do file I/O on jank-sensitive threads (BrowserThread::UI and BrowserThread::IO), so you can proxy them to another thread (such as BrowserThread::FILE) via these utilities.%0aTime, TimeDelta, TimeTicks, Timer%0aGenerally use TimeTicks instead of Time to keep a stable tick counter (Time may change if the user changes the computer clock).%0aPrefService, ExtensionPrefs%0aContainers for persistent state associated with a user Profile.
time=1530266425
author:1530266425=
diff:1530266425:1530234638:=
host:1530266425=192.168.3.2
author:1530234638=
diff:1530234638:1530233340:=20,23c20,24%0a%3c ''base::Callback''は内部的に参照カウントされたコールバッククラス、可変長引数で任意の戻り値のコールバックに対応。コピー可能だが関数ポインタとバインドされた引数は共有する。''base::Bind()''は引数と関数ポインタをバインドして（内部では関数ポインタと引数を参照カウンタオブジェクトで管理）''base::Callback''を返す。''base::Bind()''にメンバ関数が渡されたときは魔法のように自動的に最初の引数に対して''AddRef()/Release()''が実行される。もしそれが参照カウンタオブジェクトでないなら怒られる（これを防ぐには''base::WeakPtr''か''base::Unretained''を使う。また引数については、''COMPILE_ASSERT''を使いそれらが参照カウンタ対象への生ポインタでないかを検証する（forwardされていない完全型情報のときのみ可能）。バグを防ぐためには、''scoped_refptrs''か''make_scoped_refptr()''を使うこと。更に、''base::Bind()''は''base::WeakPtr''を理解している。もし関数がメンバ関数で最初の引数が''base::WeakPtr''なら、''base::Bind()''はラッパ関数を挿入し、WeakPtrがNULLでないときのみ実行する。''base::Bind()''は引数のために以下のようなヘルパ関数を提供する。%0a%3c *''base::Unretained()''はメンバ関数のオブジェクト（それは参照カウントされていないタイプかもしれない）の参照カウントを無効にし、引数の''COMPILE_ASSERT''を無効にする。オブジェクトの生存時間に注意して使うこと。この点''base::WeakPtr''の方が安全である。%0a%3c *''base::Owned()''は生ポインタのオーナーを戻り値の''base::Callback''ストレージに移転する。''TaskRunner''はシャットダウン時の実行を保証しないため（そこでオブジェクトを削除したいかもしれない）コールバックが所有権を持てば、シャットダウン時のリークを防げる。%0a%3c *''base::Passed()''は%0a---%0a> ''base::Callback''は内部的に参照カウントされたコールバッククラス、可変長引数で任意の戻り値のコールバックに対応。コピー可能だが関数ポインタとバインドされた引数は共有する。''base::Bind()''は引数と関数ポインタをバインドして（内部では関数ポインタと引数を参照カウンタオブジェクトで管理）''base::Callback''を返す。''base::Bind()''にメンバ関数が渡されたときは魔法のように自動的に最初の引数に対して''AddRef()/Release()''が実行される。もしそれが参照カウンタオブジェクトでないなら怒られる（これを防ぐには''base::WeakPtr''か''base::Unretained''を使う。%0a> %0a>  and will complain if the type is not refcounted (avoid this problem with base::WeakPtr or base::Unretained()). Also, for the function arguments, it will use a COMPILE_ASSERT to try to verify they are not raw pointers to a refcounted type (only possible with full type information, not forward declarations). Instead, use scoped_refptrs or call make_scoped_refptr() to prevent bugs. In addition, base::Bind() understands base::WeakPtr. If the function is a member function and the first argument is a base::WeakPtr to the object, base::Bind() will inject a wrapper function that only invokes the function pointer if the base::WeakPtr is non-NULL. base::Bind() also has the following helper wrappers for arguments.%0a> base::Unretained() - disables the refcounting of member function receiver objects (which may not be of refcounted types) and the COMPILE_ASSERT on function arguments. Use with care, since it implies you need to make sure the lifetime of the object lasts beyond when the callback can be invoked. For the member function receiver object, it's probably better to use a base::WeakPtr instead.%0a> base::Owned() - transfer ownership of a raw pointer to the returned base::Callback storage. Very useful because TaskRunners are not guaranteed to run callbacks (which may want to delete the object) on shutdown, so by making the callback take ownership, this prevents annoying shutdown leaks when the callback is not run.%0a
host:1530234638=192.168.3.2
author:1530233340=
diff:1530233340:1530228886:=13,53d12%0a%3c !''base::SequencedWorkerPool''と''base::WorkerPool''%0a%3c Chromiumでの２つの主要なワーカプール。''SequencedWorderPool''はもっとも複雑なワーカプールで''TaskRunner''から継承し、シーケンスにタスクを処理する方法を提供する（''SequenceToken''の共有により）。それからシャットダウン時の動作も指定できる（タスク実行時はシャットダウンをブロック、ブラウザがシャットダウン時はタスクを実行しないか実行していたならシャットダウンをブロック、ブラウザのシャットダウンに関わりなく実行を許可してシャットダウンをブロックしない、など）。%0a%3c SequencedWorkerPool also provides a facility to return a SequencedTaskRunner based on a SequenceToken. The Chromium browser process will shutdown base::SequencedWorkerPool after all main browser threads (other than the main thread) have stopped. base::WorkerPool is a global object that is not shutdown on browser process shutdown, so all the tasks running on it will not be joined. It's generally unadvisable to use base::WorkerPool since tasks may have dependencies on other objects that may be in the process of being destroyed during browser shutdown.%0a%3c %0a%3c %0a%3c %0a%3c !''base::Callback''と''base::Bind()''%0a%3c ''base::Callback''は内部的に参照カウントされたコールバッククラス、可変長引数で任意の戻り値のコールバックに対応。コピー可能だが関数ポインタとバインドされた引数は共有する。''base::Bind()''は引数と関数ポインタをバインドして（内部では関数ポインタと引数を参照カウンタオブジェクトで管理）''base::Callback''を返す。''base::Bind()''にメンバ関数が渡されたときは魔法のように自動的に最初の引数に対して''AddRef()/Release()''が実行される。もしそれが参照カウンタオブジェクトでないなら怒られる（これを防ぐには''base::WeakPtr''か''base::Unretained''を使う。%0a%3c %0a%3c  and will complain if the type is not refcounted (avoid this problem with base::WeakPtr or base::Unretained()). Also, for the function arguments, it will use a COMPILE_ASSERT to try to verify they are not raw pointers to a refcounted type (only possible with full type information, not forward declarations). Instead, use scoped_refptrs or call make_scoped_refptr() to prevent bugs. In addition, base::Bind() understands base::WeakPtr. If the function is a member function and the first argument is a base::WeakPtr to the object, base::Bind() will inject a wrapper function that only invokes the function pointer if the base::WeakPtr is non-NULL. base::Bind() also has the following helper wrappers for arguments.%0a%3c base::Unretained() - disables the refcounting of member function receiver objects (which may not be of refcounted types) and the COMPILE_ASSERT on function arguments. Use with care, since it implies you need to make sure the lifetime of the object lasts beyond when the callback can be invoked. For the member function receiver object, it's probably better to use a base::WeakPtr instead.%0a%3c base::Owned() - transfer ownership of a raw pointer to the returned base::Callback storage. Very useful because TaskRunners are not guaranteed to run callbacks (which may want to delete the object) on shutdown, so by making the callback take ownership, this prevents annoying shutdown leaks when the callback is not run.%0a%3c base::Passed() - useful for passing a scoped object (scoped_ptr/ScopedVector/etc) to a callback. The primary difference between base::Owned() and base::Passed() is base::Passed() requires the function signature take the scoped type as a parameter, and thus allows for transferring ownership via .release(). NOTE: since the scope of the scoped type is the function scope, that means the base::Callback must only be called once. Otherwise, it would be a potential use after free and a definite double delete. Given the complexity of base::Passed()'s semantics in comparison to base::Owned(), you should prefer base::Owned() to base::Passed() in general.%0a%3c base::ConstRef() - passes an argument as a const reference instead of copying it into the internal callback storage. Useful for obvious performance reasons, but generally should not be used, since it requires that the lifetime of the referent must live beyond when the callback can be invoked.%0a%3c base::IgnoreResult() - use this with the function pointer passed to base::Bind() to ignore the result. Useful to make the callback usable with a TaskRunner which only takes Closures (callbacks with no parameters nor return values).%0a%3c scoped_refptr%3cT> & base::RefCounted & base::RefCountedThreadSafe%0a%3c Reference counting is occasionally useful but is more often a sign that someone isn't thinking carefully about ownership. Use it when ownership is truly shared (for example, multiple tabs sharing the same renderer process), not for when lifetime management is difficult to reason about.%0a%3c Singleton & base::LazyInstance%0a%3c They're globals, so you generally should avoid using them, as per the style guide. That said, when you use globals in Chromium code, it's often good to use one of these, and in general, prefer base::LazyInstance over Singleton. The reason to use these classes is construction is lazy (thereby preventing startup slowdown due to static initializers) and destruction order is well-defined. They are all destroyed in opposite order as construction when the AtExitManager is destroyed. In the Chromium browser process, the AtExitManager is instantiated early on in the main thread (the UI thread), so all of these objects will be destroyed on the main thread, even if constructed on a different thread. The reason to prefer base::LazyInstance over base::Singleton is base::LazyInstance reduces heap fragmentation by reserving space in the data segment and using placement new to construct the object in that memory location. NOTE: Both Singleton and base::LazyInstance provide "leaky" traits to leak the global on shutdown. This is often advisable (except potentially in library code where the code may be dynamically loaded into another process's address space or when data needs to be flushed on process shutdown) in order to not to slow down shutdown. There are valgrind suppressions for these "leaky" traits.%0a%3c base::Thread & base::PlatformThread%0a%3c Generally you shouldn't use these, since you should usually post tasks to an existing TaskRunner. PlatformThread is a platform-specific thread. base::Thread contains a MessageLoop running on a PlatformThread.%0a%3c base::WeakPtr & base::WeakPtrFactory%0a%3c Mostly thread-unsafe weak pointer that returns NULL if the referent has been destroyed. It's safe to pass across threads (and to destroy on other threads), but it should only be used on the original thread it was created on. base::WeakPtrFactory is useful for automatically canceling base::Callbacks when the referent of the base::WeakPtr gets destroyed.%0a%3c FilePath%0a%3c A cross-platform representation of a file path. You should generally use this instead of platform-specific representations.%0a%3c ObserverList & ObserverListThreadSafe%0a%3c ObserverList is a thread-unsafe object that is intended to be used as a member variable of a class. It provides a simple interface for iterating on a bunch of Observer objects and invoking a notification method.%0a%3c %0a%3c ObserverListThreadSafe similar. It contains multiple ObserverLists, and observer notifications are invoked on the same PlatformThreadId that the observer was registered on, thereby allowing proxying notifications across threads and allowing the individual observers to receive notifications in a single threaded manner.%0a%3c Pickle%0a%3c Pickle provides a basic facility for object serialization and deserialization in binary form.%0a%3c Value%0a%3c Values allow for specifying recursive data classes (lists and dictionaries) containing simple values (bool/int/string/etc). These values can also be serialized to JSON and back.%0a%3c LOG%0a%3c This is the basic interface for logging in Chromium.%0a%3c FileUtilProxy%0a%3c Generally you should not do file I/O on jank-sensitive threads (BrowserThread::UI and BrowserThread::IO), so you can proxy them to another thread (such as BrowserThread::FILE) via these utilities.%0a%3c Time, TimeDelta, TimeTicks, Timer%0a%3c Generally use TimeTicks instead of Time to keep a stable tick counter (Time may change if the user changes the computer clock).%0a%3c PrefService, ExtensionPrefs%0a%3c Containers for persistent state associated with a user Profile.%0a\ No newline at end of file%0a
host:1530233340=192.168.3.2
author:1530228886=
diff:1530228886:1530228830:=4c4%0a%3c ''base::Callbacks''のタスクを''TaskRunner''で実行するためのインターフェース。''TaskRunner''は実行を保証しない（順序、同期、または全く実行されないなど）。''SequencedTaskRunnder''は実行の順序をあるていど保証する（大まかにいえばFIFO、でも詳細はコードを見て）。''SingleThreadTaskRunner''は''SequencedTaskRunner''と同じくらい保証するが、すべてのタスクは同じスレッドで行われる。''MessageLoopProxy''は規範的な''SingleThreadTaskRunner''の実例。これらのインターフェースは独立性投入経由でテストをするのに役立つ。注：''TaskRunner''のポストに成功したからといって実行されるとは限らない。%0a---%0a> base::CallbacksのタスクをTaskRunnerで実行するためのインターフェース。TaskRunnerは実行を保証しない（順序、同期、または全く実行されないなど）。SequencedTaskRunnderは実行の順序をあるていど保証する（大まかにいえばFIFO、でも詳細はコードを見て）。SingleThreadTaskRunnerはSequencedTaskRunnerと同じくらい保証するが、すべてのタスクは同じスレッドで行われる。MessageLoopProxyは規範的なSingleThreadTaskRunnerの実例。これらのインターフェースは独立性投入経由でテストをするのに役立つ。注：TaskRunnerのポストに成功したからといって実行されるとは限らない。%0a
host:1530228886=192.168.3.2
author:1530228830=
diff:1530228830:1530228110:=9,12c9,12%0a%3c これらはタスクをポストするための様々なAPI。''MessageLoop''は''MessageLoopProxy''によって使われる具体オブジェクト（Chromiumでもっとも広く使われるコード）。''MessageLoop''の代わりに''MessageLoopProxy''を使うべき、もし''chrome/''や''content/''のコードの中なら、''BrowserThread''を使うことができる。''MessageLoop''デストラクト時に起こるレーシングも回避している。''MessageLoopProxy''と''BrowserThread''は配下の''MessageLoop''が消えた後はタスクを削除する。注：''MessageLoop(Proxy)''へのポストが成功したからといって、タスクが実行されるとは限らない。%0a%3c %0a%3c 追記：''SequencedTaskRunner''や''MessageLoopProxy'',''BrowserThread''をいつ使うべきかには議論がある。インタフェースクァすである''SequencedTaskRunner''はコードをより抽象化・再利用化・テスト可能化する。一方直接性が失われるため、コードが明白でなくなる。具体クラスの''BrowserThread''IDは直接的明白で、そのスレッドで実行されることがわかる。もっとも''SequencedTaskRunner''変数を適切に命名することでより明白にはなる。現時点での決定は、必要に応じて、''BrowserThread''のコードを''TaskRunner''サブクラスに変えていくことのみである。''MessageLoopProxy''は''SingleThreadTaskRunner''または''SequencedTaskRunner''インタフェースとしてやり取りされるべきだろうと思われる。%0a%3c %0a---%0a> これらはタスクをポストするための様々なAPI。MessageLoopはMessageLoopProxyによって使われる具体オブジェクト（Chromiumでもっとも広く使われるコード）。MessageLoopの代わりにMessageLoopProxyを使うべき、もしchrome/やcontent/のコードの中なら、BrowserThreadを使うことができる。MessageLoopデストラクト時に起こるレーシングも回避している。MessageLoopProxyとBrowserThreadは配下のMessageLoopが消えた後はタスクを削除する。注：MessageLoop(Proxy)へのポストが成功したからといって、タスクが実行されるとは限らない。%0a> %0a> TODO%0a> PS: There's some debate about when to use SequencedTaskRunner vs MessageLoopProxy vs BrowserThread. Using an interface class like SequencedTaskRunner makes the code more abstract/reusable/testable. On the other hand, due to the extra layer of indirection, it makes the code less obvious. Using a concrete BrowserThread ID makes it immediately obvious which thread it's running on, although arguably you could name the SequencedTaskRunner variable appropriately to make it more clear. The current decision is to only convert code from BrowserThread to a TaskRunner subtype when necessary. MessageLoopProxy should probably always be passed around as a SingleThreadTaskRunner or a parent interface like SequencedTaskRunner.%0a\ No newline at end of file%0a
host:1530228830=192.168.3.2
author:1530228110=
diff:1530228110:1530227987:=8c8%0a%3c !''MessageLoop''と''MessageLoopProxy''と''BrowserThread''と''RunLoop''%0a---%0a> [[MessageLoop]]と[[MessageLoopProxy]]と[[BrowserThread]]と[[RunLoop]]%0a
host:1530228110=192.168.3.2
author:1530227987=
diff:1530227987:1503828291:=3c3%0a%3c !''TaskRunner''と''SequencedTaskRunner''と''SingleThreadTaskRunner''%0a---%0a> [[TaskRunner]]と[[SequencedTaskRunner]]と[[SingleThreadTaskRunner]]%0a
host:1530227987=192.168.3.2
author:1503828291=
diff:1503828291:1503827782:=9,12d8%0a%3c これらはタスクをポストするための様々なAPI。MessageLoopはMessageLoopProxyによって使われる具体オブジェクト（Chromiumでもっとも広く使われるコード）。MessageLoopの代わりにMessageLoopProxyを使うべき、もしchrome/やcontent/のコードの中なら、BrowserThreadを使うことができる。MessageLoopデストラクト時に起こるレーシングも回避している。MessageLoopProxyとBrowserThreadは配下のMessageLoopが消えた後はタスクを削除する。注：MessageLoop(Proxy)へのポストが成功したからといって、タスクが実行されるとは限らない。%0a%3c %0a%3c TODO%0a%3c PS: There's some debate about when to use SequencedTaskRunner vs MessageLoopProxy vs BrowserThread. Using an interface class like SequencedTaskRunner makes the code more abstract/reusable/testable. On the other hand, due to the extra layer of indirection, it makes the code less obvious. Using a concrete BrowserThread ID makes it immediately obvious which thread it's running on, although arguably you could name the SequencedTaskRunner variable appropriately to make it more clear. The current decision is to only convert code from BrowserThread to a TaskRunner subtype when necessary. MessageLoopProxy should probably always be passed around as a SingleThreadTaskRunner or a parent interface like SequencedTaskRunner.%0a\ No newline at end of file%0a
host:1503828291=192.168.0.2
author:1503827782=
diff:1503827782:1503827782:=1,8d0%0a%3c https://www.chromium.org/developers/coding-style/important-abstractions-and-data-structures%0a%3c %0a%3c [[TaskRunner]]と[[SequencedTaskRunner]]と[[SingleThreadTaskRunner]]%0a%3c base::CallbacksのタスクをTaskRunnerで実行するためのインターフェース。TaskRunnerは実行を保証しない（順序、同期、または全く実行されないなど）。SequencedTaskRunnderは実行の順序をあるていど保証する（大まかにいえばFIFO、でも詳細はコードを見て）。SingleThreadTaskRunnerはSequencedTaskRunnerと同じくらい保証するが、すべてのタスクは同じスレッドで行われる。MessageLoopProxyは規範的なSingleThreadTaskRunnerの実例。これらのインターフェースは独立性投入経由でテストをするのに役立つ。注：TaskRunnerのポストに成功したからといって実行されるとは限らない。%0a%3c %0a%3c 注：TaskRunnerのメンバ関数PostTaskAndReply()は'''とても'''役に立つ。仕事が終わったら元の人にリプライを返してくれる。%0a%3c %0a%3c [[MessageLoop]]と[[MessageLoopProxy]]と[[BrowserThread]]と[[RunLoop]]%0a
host:1503827782=192.168.0.2
