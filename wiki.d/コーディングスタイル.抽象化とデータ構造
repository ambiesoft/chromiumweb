version=pmwiki-2.2.109 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1530427632
host=192.168.3.2
name=コーディングスタイル.抽象化とデータ構造
rev=6
targets=
text=https://www.chromium.org/developers/coding-style/important-abstractions-and-data-structures%0a%0a!''TaskRunner''と''SequencedTaskRunner''と''SingleThreadTaskRunner''%0a''base::Callbacks''のタスクを''TaskRunner''で実行するためのインターフェース。''TaskRunner''は実行を保証しない（順序、同期、または全く実行されないなど）。''SequencedTaskRunnder''は実行の順序をあるていど保証する（大まかにいえばFIFO、でも詳細はコードを見て）。''SingleThreadTaskRunner''は''SequencedTaskRunner''と同じくらい保証するが、すべてのタスクは同じスレッドで行われる。''MessageLoopProxy''は規範的な''SingleThreadTaskRunner''の実例。これらのインターフェースは独立性投入経由でテストをするのに役立つ。注：''TaskRunner''のポストに成功したからといって実行されるとは限らない。%0a%0a注：TaskRunnerのメンバ関数PostTaskAndReply()は'''とても'''役に立つ。仕事が終わったら元の人にリプライを返してくれる。%0a%0a!''MessageLoop''と''MessageLoopProxy''と''BrowserThread''と''RunLoop''%0aこれらはタスクをポストするための様々なAPI。''MessageLoop''は''MessageLoopProxy''によって使われる具体オブジェクト（Chromiumでもっとも広く使われるコード）。''MessageLoop''の代わりに''MessageLoopProxy''を使うべき、もし''chrome/''や''content/''のコードの中なら、''BrowserThread''を使うことができる。''MessageLoop''デストラクト時に起こるレーシングも回避している。''MessageLoopProxy''と''BrowserThread''は配下の''MessageLoop''が消えた後はタスクを削除する。注：''MessageLoop(Proxy)''へのポストが成功したからといって、タスクが実行されるとは限らない。%0a%0a追記：''SequencedTaskRunner''や''MessageLoopProxy'',''BrowserThread''をいつ使うべきかには議論がある。インタフェースクァすである''SequencedTaskRunner''はコードをより抽象化・再利用化・テスト可能化する。一方直接性が失われるため、コードが明白でなくなる。具体クラスの''BrowserThread''IDは直接的明白で、そのスレッドで実行されることがわかる。もっとも''SequencedTaskRunner''変数を適切に命名することでより明白にはなる。現時点での決定は、必要に応じて、''BrowserThread''のコードを''TaskRunner''サブクラスに変えていくことのみである。''MessageLoopProxy''は''SingleThreadTaskRunner''または''SequencedTaskRunner''インタフェースとしてやり取りされるべきだろうと思われる。%0a%0a!''base::SequencedWorkerPool''と''base::WorkerPool''%0aChromiumでの２つの主要なワーカプール。''SequencedWorderPool''はもっとも複雑なワーカプールで''TaskRunner''から継承し、シーケンスにタスクを処理する方法を提供する（''SequenceToken''の共有により）。それからシャットダウン時の動作も指定できる（タスク実行時はシャットダウンをブロック、ブラウザがシャットダウン時はタスクを実行しないか実行していたならシャットダウンをブロック、ブラウザのシャットダウンに関わりなく実行を許可してシャットダウンをブロックしない、など）。%0aSequencedWorkerPool also provides a facility to return a SequencedTaskRunner based on a SequenceToken. The Chromium browser process will shutdown base::SequencedWorkerPool after all main browser threads (other than the main thread) have stopped. base::WorkerPool is a global object that is not shutdown on browser process shutdown, so all the tasks running on it will not be joined. It's generally unadvisable to use base::WorkerPool since tasks may have dependencies on other objects that may be in the process of being destroyed during browser shutdown.%0a%0a%0a%0a!''base::Callback''と''base::Bind()''%0a''base::Callback''は内部的に参照カウントされたコールバッククラス、可変長引数で任意の戻り値のコールバックに対応。コピー可能だが関数ポインタとバインドされた引数は共有する。''base::Bind()''は引数と関数ポインタをバインドして（内部では関数ポインタと引数を参照カウンタオブジェクトで管理）''base::Callback''を返す。''base::Bind()''にメンバ関数が渡されたときは魔法のように自動的に最初の引数に対して''AddRef()/Release()''が実行される。もしそれが参照カウンタオブジェクトでないなら怒られる（これを防ぐには''base::WeakPtr''か''base::Unretained''を使う。また引数については、''COMPILE_ASSERT''を使いそれらが参照カウンタ対象への生ポインタでないかを検証する（forwardされていない完全型情報のときのみ可能）。バグを防ぐためには、''scoped_refptrs''か''make_scoped_refptr()''を使うこと。更に、''base::Bind()''は''base::WeakPtr''を理解している。もし関数がメンバ関数で最初の引数が''base::WeakPtr''なら、''base::Bind()''はラッパ関数を挿入し、WeakPtrがNULLでないときのみ実行する。''base::Bind()''は引数のために以下のようなヘルパ関数を提供する。%0a*''base::Unretained()''はメンバ関数のオブジェクト（それは参照カウントされていないタイプかもしれない）の参照カウントを無効にし、引数の''COMPILE_ASSERT''を無効にする。オブジェクトの生存時間に注意して使うこと。この点''base::WeakPtr''の方が安全である。%0a*''base::Owned()''は生ポインタのオーナーを戻り値の''base::Callback''ストレージに移転する。''TaskRunner''はシャットダウン時の実行を保証しないため（そこでオブジェクトを削除したいかもしれない）コールバックが所有権を持てば、シャットダウン時のリークを防げる。%0a*''base::Passed()''は範囲付されたオブジェクト(scoped_ptr/ScopedVector/etc)をコールバックに渡すのに便利。base::Owned()とbase::Passed()の違いは、base::Passed()は関数署名が範囲付された型のパラメータを取ることを要求し、これによりrelease()経由で所有権を移転できる。'''注意'''：範囲付タイプの範囲は関数範囲なので、base::Callbackは一度のみ呼ぶことができる。base::Owned()の方を使うべき。%0a*''base::ConstRef()''はコールバックが引数をコピーして保持するのではなくコンスト参照として保持する。パフォーマンス改善が期待できるが、使うべきではない。オブジェクトがコールバックがコールされるまで生存していることを保証しなければならないため。%0a*''base::IgnoreResult()''は関数ポインタをともに使い戻り値を無視する。Closureしか取らないTaskRunnerで使える（Closureは引数を持たず値を返さないもの）。%0a%0a!scoped_refptr%3cT> & base::RefCounted & base::RefCountedThreadSafe%0a参照カウントは便利だが、所有権がちゃんと考えられていない場合が多い。所有権が本当に共有されている時に使うこと（例えば、複数のタブが同じレンダラプロセスを共有する時）。オブジェクトの生涯管理が難しいときは使わないこと。%0a%0a!Singleton & base::LazyInstance%0aこれらはグーロバルなので一般的には使用を避けるべき。しかしグローバルを使うときはこれらを使ったほうが良い。base::LazyInstanceの方がSingletonよりもよい。これらのクラスを使う理由は、構築が遅延するからである。これにより初期化時に遅くなることを防止できる。破壊の順番もちゃんと定義されている。破壊は構築の逆順で行われる（AtExitManagerが破壊された時）。Chromiumのブラウザプロセスでは、AtExitManagerはメインスレッド（UIスレッド）でのみインスタンス化されるので、破壊はメインスレッドで行われる（たとえ構築が別スレッドで行われても）。base::LazyInstanceのようが好ましい理由は、データセグメントでスペースを予約しヒープの断片化を避けるからである。注意：Singletonとbase::LazyInstanceの両方とも"leaky"トレイトを提供しシャットダウン時にリークさせることができ、シャットダウン時に動作を遅くしないためにしていできる。valgrindにはこのトレイトに関する抑止機能がある。%0a%0a!base::Thread & base::PlatformThread%0aタスクはすでに存在しているTaskRunnerにポストするので、一般的にはこれらを使用すべきでない。PlatformThreadはプラットフォーム固有のスレッド。base::ThreadはPlatformThreadで動作するMessageLoopを含む。%0a%0a!base::WeakPtr & base::WeakPtrFactory%0aほとんどのスレッドセーフの弱いポインタは参照が破壊されていたならNULLを返す。スレッド間で渡すこともでき他のスレッドで破壊することもできる。しかし通常はそれを作成したスレッドで使うべき。base::WeakPtrFactoryはbase::WeakPtrが破棄されたとき自動でbase::Callbacksをキャンセルする。%0a%0a!FilePath%0aクロスプラットフォームのファイルパス。プラットフォーム固有の方法は使わずこれを使うべき。%0a%0a!ObserverList & ObserverListThreadSafe%0aObserverListはスレッドセーフなオブジェクトで、クラスのメンバ変数として使用されることを想定している。Observerオブジェクトのイテレートを行う簡単なインタフェースを提供するし、通知メソッドを呼び出す。%0a%0aObserverListThreadSafeも同様。これは複数のObserverListを保持し、オブザーバ通知はオブザーバが登録されたのと同じPlatformThreadIdで呼び出される。よってスレッド間の通知のプロキシとなり個々のオブザーバにとってはシングルスレッドでオブザーバを扱える。%0a%0a!Pickle%0aPickleはオブジェクトの連続化と脱連続化機能を提供する。%0a%0a!Value%0aValueは再帰的データクラスで基本型を持つ時使える。JSONへの連続化ができる。%0a%0a!LOG%0aログの基本インタフェース%0a%0a!FileUtilProxy%0a基本的にはファイル操作をjank-sensitiveなスレッド（BrowserThread::UIとBrowserThread::IO）で行うべきではない。他のスレッド(BrowserThread::FILEのような）で行いプロキシにすべきである。%0a%0a!Time, TimeDelta, TimeTicks, Timer%0a安定したティックカウンタ（Timeはユーザがコンピュータのクロックを変えると変わる）のために一般的にはTimeの代わりにTimeTicksを使うべき。%0a%0a!PrefService, ExtensionPrefs%0aユーザプロファイルの永続状態のためのコンテナ%0a%0a---%0aDone:2018/09/30 (日) 19:22:43
time=1538302968
author:1538302968=
diff:1538302968:1538302943:=64,66d63%0a%3c %0a%3c ---%0a%3c Done:2018/09/30 (日) 19:22:43%0a\ No newline at end of file%0a
host:1538302968=192.168.3.2
author:1538302943=
diff:1538302943:1538302257:=57,63c57,62%0a%3c 基本的にはファイル操作をjank-sensitiveなスレッド（BrowserThread::UIとBrowserThread::IO）で行うべきではない。他のスレッド(BrowserThread::FILEのような）で行いプロキシにすべきである。%0a%3c %0a%3c !Time, TimeDelta, TimeTicks, Timer%0a%3c 安定したティックカウンタ（Timeはユーザがコンピュータのクロックを変えると変わる）のために一般的にはTimeの代わりにTimeTicksを使うべき。%0a%3c %0a%3c !PrefService, ExtensionPrefs%0a%3c ユーザプロファイルの永続状態のためのコンテナ%0a---%0a> 基本的葉にはファイル操作を%0a> Generally you should not do file I/O on jank-sensitive threads (BrowserThread::UI and BrowserThread::IO), so you can proxy them to another thread (such as BrowserThread::FILE) via these utilities.%0a> Time, TimeDelta, TimeTicks, Timer%0a> Generally use TimeTicks instead of Time to keep a stable tick counter (Time may change if the user changes the computer clock).%0a> PrefService, ExtensionPrefs%0a> Containers for persistent state associated with a user Profile.%0a\ No newline at end of file%0a
host:1538302943=192.168.3.2
author:1538302257=
diff:1538302257:1538300688:=34,57c34,49%0a%3c タスクはすでに存在しているTaskRunnerにポストするので、一般的にはこれらを使用すべきでない。PlatformThreadはプラットフォーム固有のスレッド。base::ThreadはPlatformThreadで動作するMessageLoopを含む。%0a%3c %0a%3c !base::WeakPtr & base::WeakPtrFactory%0a%3c ほとんどのスレッドセーフの弱いポインタは参照が破壊されていたならNULLを返す。スレッド間で渡すこともでき他のスレッドで破壊することもできる。しかし通常はそれを作成したスレッドで使うべき。base::WeakPtrFactoryはbase::WeakPtrが破棄されたとき自動でbase::Callbacksをキャンセルする。%0a%3c %0a%3c !FilePath%0a%3c クロスプラットフォームのファイルパス。プラットフォーム固有の方法は使わずこれを使うべき。%0a%3c %0a%3c !ObserverList & ObserverListThreadSafe%0a%3c ObserverListはスレッドセーフなオブジェクトで、クラスのメンバ変数として使用されることを想定している。Observerオブジェクトのイテレートを行う簡単なインタフェースを提供するし、通知メソッドを呼び出す。%0a%3c %0a%3c ObserverListThreadSafeも同様。これは複数のObserverListを保持し、オブザーバ通知はオブザーバが登録されたのと同じPlatformThreadIdで呼び出される。よってスレッド間の通知のプロキシとなり個々のオブザーバにとってはシングルスレッドでオブザーバを扱える。%0a%3c %0a%3c !Pickle%0a%3c Pickleはオブジェクトの連続化と脱連続化機能を提供する。%0a%3c %0a%3c !Value%0a%3c Valueは再帰的データクラスで基本型を持つ時使える。JSONへの連続化ができる。%0a%3c %0a%3c !LOG%0a%3c ログの基本インタフェース%0a%3c %0a%3c !FileUtilProxy%0a%3c 基本的葉にはファイル操作を%0a---%0a> Generally you shouldn't use these, since you should usually post tasks to an existing TaskRunner. PlatformThread is a platform-specific thread. base::Thread contains a MessageLoop running on a PlatformThread.%0a> base::WeakPtr & base::WeakPtrFactory%0a> Mostly thread-unsafe weak pointer that returns NULL if the referent has been destroyed. It's safe to pass across threads (and to destroy on other threads), but it should only be used on the original thread it was created on. base::WeakPtrFactory is useful for automatically canceling base::Callbacks when the referent of the base::WeakPtr gets destroyed.%0a> FilePath%0a> A cross-platform representation of a file path. You should generally use this instead of platform-specific representations.%0a> ObserverList & ObserverListThreadSafe%0a> ObserverList is a thread-unsafe object that is intended to be used as a member variable of a class. It provides a simple interface for iterating on a bunch of Observer objects and invoking a notification method.%0a> %0a> ObserverListThreadSafe similar. It contains multiple ObserverLists, and observer notifications are invoked on the same PlatformThreadId that the observer was registered on, thereby allowing proxying notifications across threads and allowing the individual observers to receive notifications in a single threaded manner.%0a> Pickle%0a> Pickle provides a basic facility for object serialization and deserialization in binary form.%0a> Value%0a> Values allow for specifying recursive data classes (lists and dictionaries) containing simple values (bool/int/string/etc). These values can also be serialized to JSON and back.%0a> LOG%0a> This is the basic interface for logging in Chromium.%0a> FileUtilProxy%0a
host:1538302257=192.168.3.2
author:1538300688=
diff:1538300688:1538299955:=28,33c28,33%0a%3c 参照カウントは便利だが、所有権がちゃんと考えられていない場合が多い。所有権が本当に共有されている時に使うこと（例えば、複数のタブが同じレンダラプロセスを共有する時）。オブジェクトの生涯管理が難しいときは使わないこと。%0a%3c %0a%3c !Singleton & base::LazyInstance%0a%3c これらはグーロバルなので一般的には使用を避けるべき。しかしグローバルを使うときはこれらを使ったほうが良い。base::LazyInstanceの方がSingletonよりもよい。これらのクラスを使う理由は、構築が遅延するからである。これにより初期化時に遅くなることを防止できる。破壊の順番もちゃんと定義されている。破壊は構築の逆順で行われる（AtExitManagerが破壊された時）。Chromiumのブラウザプロセスでは、AtExitManagerはメインスレッド（UIスレッド）でのみインスタンス化されるので、破壊はメインスレッドで行われる（たとえ構築が別スレッドで行われても）。base::LazyInstanceのようが好ましい理由は、データセグメントでスペースを予約しヒープの断片化を避けるからである。注意：Singletonとbase::LazyInstanceの両方とも"leaky"トレイトを提供しシャットダウン時にリークさせることができ、シャットダウン時に動作を遅くしないためにしていできる。valgrindにはこのトレイトに関する抑止機能がある。%0a%3c %0a%3c !base::Thread & base::PlatformThread%0a---%0a> %0a> %0a> Reference counting is occasionally useful but is more often a sign that someone isn't thinking carefully about ownership. Use it when ownership is truly shared (for example, multiple tabs sharing the same renderer process), not for when lifetime management is difficult to reason about.%0a> Singleton & base::LazyInstance%0a> They're globals, so you generally should avoid using them, as per the style guide. That said, when you use globals in Chromium code, it's often good to use one of these, and in general, prefer base::LazyInstance over Singleton. The reason to use these classes is construction is lazy (thereby preventing startup slowdown due to static initializers) and destruction order is well-defined. They are all destroyed in opposite order as construction when the AtExitManager is destroyed. In the Chromium browser process, the AtExitManager is instantiated early on in the main thread (the UI thread), so all of these objects will be destroyed on the main thread, even if constructed on a different thread. The reason to prefer base::LazyInstance over base::Singleton is base::LazyInstance reduces heap fragmentation by reserving space in the data segment and using placement new to construct the object in that memory location. NOTE: Both Singleton and base::LazyInstance provide "leaky" traits to leak the global on shutdown. This is often advisable (except potentially in library code where the code may be dynamically loaded into another process's address space or when data needs to be flushed on process shutdown) in order to not to slow down shutdown. There are valgrind suppressions for these "leaky" traits.%0a> base::Thread & base::PlatformThread%0a
host:1538300688=192.168.3.2
author:1538299955=
diff:1538299955:1530427632:=23,29c23,27%0a%3c *''base::Passed()''は範囲付されたオブジェクト(scoped_ptr/ScopedVector/etc)をコールバックに渡すのに便利。base::Owned()とbase::Passed()の違いは、base::Passed()は関数署名が範囲付された型のパラメータを取ることを要求し、これによりrelease()経由で所有権を移転できる。'''注意'''：範囲付タイプの範囲は関数範囲なので、base::Callbackは一度のみ呼ぶことができる。base::Owned()の方を使うべき。%0a%3c *''base::ConstRef()''はコールバックが引数をコピーして保持するのではなくコンスト参照として保持する。パフォーマンス改善が期待できるが、使うべきではない。オブジェクトがコールバックがコールされるまで生存していることを保証しなければならないため。%0a%3c *''base::IgnoreResult()''は関数ポインタをともに使い戻り値を無視する。Closureしか取らないTaskRunnerで使える（Closureは引数を持たず値を返さないもの）。%0a%3c %0a%3c !scoped_refptr%3cT> & base::RefCounted & base::RefCountedThreadSafe%0a%3c %0a%3c %0a---%0a> *''base::Passed()''は%0a> base::Passed() - useful for passing a scoped object (scoped_ptr/ScopedVector/etc) to a callback. The primary difference between base::Owned() and base::Passed() is base::Passed() requires the function signature take the scoped type as a parameter, and thus allows for transferring ownership via .release(). NOTE: since the scope of the scoped type is the function scope, that means the base::Callback must only be called once. Otherwise, it would be a potential use after free and a definite double delete. Given the complexity of base::Passed()'s semantics in comparison to base::Owned(), you should prefer base::Owned() to base::Passed() in general.%0a> base::ConstRef() - passes an argument as a const reference instead of copying it into the internal callback storage. Useful for obvious performance reasons, but generally should not be used, since it requires that the lifetime of the referent must live beyond when the callback can be invoked.%0a> base::IgnoreResult() - use this with the function pointer passed to base::Bind() to ignore the result. Useful to make the callback usable with a TaskRunner which only takes Closures (callbacks with no parameters nor return values).%0a> scoped_refptr%3cT> & base::RefCounted & base::RefCountedThreadSafe%0a
host:1538299955=192.168.3.2
author:1530427632=
diff:1530427632:1530427632:=1,52d0%0a%3c https://www.chromium.org/developers/coding-style/important-abstractions-and-data-structures%0a%3c %0a%3c !''TaskRunner''と''SequencedTaskRunner''と''SingleThreadTaskRunner''%0a%3c ''base::Callbacks''のタスクを''TaskRunner''で実行するためのインターフェース。''TaskRunner''は実行を保証しない（順序、同期、または全く実行されないなど）。''SequencedTaskRunnder''は実行の順序をあるていど保証する（大まかにいえばFIFO、でも詳細はコードを見て）。''SingleThreadTaskRunner''は''SequencedTaskRunner''と同じくらい保証するが、すべてのタスクは同じスレッドで行われる。''MessageLoopProxy''は規範的な''SingleThreadTaskRunner''の実例。これらのインターフェースは独立性投入経由でテストをするのに役立つ。注：''TaskRunner''のポストに成功したからといって実行されるとは限らない。%0a%3c %0a%3c 注：TaskRunnerのメンバ関数PostTaskAndReply()は'''とても'''役に立つ。仕事が終わったら元の人にリプライを返してくれる。%0a%3c %0a%3c !''MessageLoop''と''MessageLoopProxy''と''BrowserThread''と''RunLoop''%0a%3c これらはタスクをポストするための様々なAPI。''MessageLoop''は''MessageLoopProxy''によって使われる具体オブジェクト（Chromiumでもっとも広く使われるコード）。''MessageLoop''の代わりに''MessageLoopProxy''を使うべき、もし''chrome/''や''content/''のコードの中なら、''BrowserThread''を使うことができる。''MessageLoop''デストラクト時に起こるレーシングも回避している。''MessageLoopProxy''と''BrowserThread''は配下の''MessageLoop''が消えた後はタスクを削除する。注：''MessageLoop(Proxy)''へのポストが成功したからといって、タスクが実行されるとは限らない。%0a%3c %0a%3c 追記：''SequencedTaskRunner''や''MessageLoopProxy'',''BrowserThread''をいつ使うべきかには議論がある。インタフェースクァすである''SequencedTaskRunner''はコードをより抽象化・再利用化・テスト可能化する。一方直接性が失われるため、コードが明白でなくなる。具体クラスの''BrowserThread''IDは直接的明白で、そのスレッドで実行されることがわかる。もっとも''SequencedTaskRunner''変数を適切に命名することでより明白にはなる。現時点での決定は、必要に応じて、''BrowserThread''のコードを''TaskRunner''サブクラスに変えていくことのみである。''MessageLoopProxy''は''SingleThreadTaskRunner''または''SequencedTaskRunner''インタフェースとしてやり取りされるべきだろうと思われる。%0a%3c %0a%3c !''base::SequencedWorkerPool''と''base::WorkerPool''%0a%3c Chromiumでの２つの主要なワーカプール。''SequencedWorderPool''はもっとも複雑なワーカプールで''TaskRunner''から継承し、シーケンスにタスクを処理する方法を提供する（''SequenceToken''の共有により）。それからシャットダウン時の動作も指定できる（タスク実行時はシャットダウンをブロック、ブラウザがシャットダウン時はタスクを実行しないか実行していたならシャットダウンをブロック、ブラウザのシャットダウンに関わりなく実行を許可してシャットダウンをブロックしない、など）。%0a%3c SequencedWorkerPool also provides a facility to return a SequencedTaskRunner based on a SequenceToken. The Chromium browser process will shutdown base::SequencedWorkerPool after all main browser threads (other than the main thread) have stopped. base::WorkerPool is a global object that is not shutdown on browser process shutdown, so all the tasks running on it will not be joined. It's generally unadvisable to use base::WorkerPool since tasks may have dependencies on other objects that may be in the process of being destroyed during browser shutdown.%0a%3c %0a%3c %0a%3c %0a%3c !''base::Callback''と''base::Bind()''%0a%3c ''base::Callback''は内部的に参照カウントされたコールバッククラス、可変長引数で任意の戻り値のコールバックに対応。コピー可能だが関数ポインタとバインドされた引数は共有する。''base::Bind()''は引数と関数ポインタをバインドして（内部では関数ポインタと引数を参照カウンタオブジェクトで管理）''base::Callback''を返す。''base::Bind()''にメンバ関数が渡されたときは魔法のように自動的に最初の引数に対して''AddRef()/Release()''が実行される。もしそれが参照カウンタオブジェクトでないなら怒られる（これを防ぐには''base::WeakPtr''か''base::Unretained''を使う。また引数については、''COMPILE_ASSERT''を使いそれらが参照カウンタ対象への生ポインタでないかを検証する（forwardされていない完全型情報のときのみ可能）。バグを防ぐためには、''scoped_refptrs''か''make_scoped_refptr()''を使うこと。更に、''base::Bind()''は''base::WeakPtr''を理解している。もし関数がメンバ関数で最初の引数が''base::WeakPtr''なら、''base::Bind()''はラッパ関数を挿入し、WeakPtrがNULLでないときのみ実行する。''base::Bind()''は引数のために以下のようなヘルパ関数を提供する。%0a%3c *''base::Unretained()''はメンバ関数のオブジェクト（それは参照カウントされていないタイプかもしれない）の参照カウントを無効にし、引数の''COMPILE_ASSERT''を無効にする。オブジェクトの生存時間に注意して使うこと。この点''base::WeakPtr''の方が安全である。%0a%3c *''base::Owned()''は生ポインタのオーナーを戻り値の''base::Callback''ストレージに移転する。''TaskRunner''はシャットダウン時の実行を保証しないため（そこでオブジェクトを削除したいかもしれない）コールバックが所有権を持てば、シャットダウン時のリークを防げる。%0a%3c *''base::Passed()''は%0a%3c base::Passed() - useful for passing a scoped object (scoped_ptr/ScopedVector/etc) to a callback. The primary difference between base::Owned() and base::Passed() is base::Passed() requires the function signature take the scoped type as a parameter, and thus allows for transferring ownership via .release(). NOTE: since the scope of the scoped type is the function scope, that means the base::Callback must only be called once. Otherwise, it would be a potential use after free and a definite double delete. Given the complexity of base::Passed()'s semantics in comparison to base::Owned(), you should prefer base::Owned() to base::Passed() in general.%0a%3c base::ConstRef() - passes an argument as a const reference instead of copying it into the internal callback storage. Useful for obvious performance reasons, but generally should not be used, since it requires that the lifetime of the referent must live beyond when the callback can be invoked.%0a%3c base::IgnoreResult() - use this with the function pointer passed to base::Bind() to ignore the result. Useful to make the callback usable with a TaskRunner which only takes Closures (callbacks with no parameters nor return values).%0a%3c scoped_refptr%3cT> & base::RefCounted & base::RefCountedThreadSafe%0a%3c Reference counting is occasionally useful but is more often a sign that someone isn't thinking carefully about ownership. Use it when ownership is truly shared (for example, multiple tabs sharing the same renderer process), not for when lifetime management is difficult to reason about.%0a%3c Singleton & base::LazyInstance%0a%3c They're globals, so you generally should avoid using them, as per the style guide. That said, when you use globals in Chromium code, it's often good to use one of these, and in general, prefer base::LazyInstance over Singleton. The reason to use these classes is construction is lazy (thereby preventing startup slowdown due to static initializers) and destruction order is well-defined. They are all destroyed in opposite order as construction when the AtExitManager is destroyed. In the Chromium browser process, the AtExitManager is instantiated early on in the main thread (the UI thread), so all of these objects will be destroyed on the main thread, even if constructed on a different thread. The reason to prefer base::LazyInstance over base::Singleton is base::LazyInstance reduces heap fragmentation by reserving space in the data segment and using placement new to construct the object in that memory location. NOTE: Both Singleton and base::LazyInstance provide "leaky" traits to leak the global on shutdown. This is often advisable (except potentially in library code where the code may be dynamically loaded into another process's address space or when data needs to be flushed on process shutdown) in order to not to slow down shutdown. There are valgrind suppressions for these "leaky" traits.%0a%3c base::Thread & base::PlatformThread%0a%3c Generally you shouldn't use these, since you should usually post tasks to an existing TaskRunner. PlatformThread is a platform-specific thread. base::Thread contains a MessageLoop running on a PlatformThread.%0a%3c base::WeakPtr & base::WeakPtrFactory%0a%3c Mostly thread-unsafe weak pointer that returns NULL if the referent has been destroyed. It's safe to pass across threads (and to destroy on other threads), but it should only be used on the original thread it was created on. base::WeakPtrFactory is useful for automatically canceling base::Callbacks when the referent of the base::WeakPtr gets destroyed.%0a%3c FilePath%0a%3c A cross-platform representation of a file path. You should generally use this instead of platform-specific representations.%0a%3c ObserverList & ObserverListThreadSafe%0a%3c ObserverList is a thread-unsafe object that is intended to be used as a member variable of a class. It provides a simple interface for iterating on a bunch of Observer objects and invoking a notification method.%0a%3c %0a%3c ObserverListThreadSafe similar. It contains multiple ObserverLists, and observer notifications are invoked on the same PlatformThreadId that the observer was registered on, thereby allowing proxying notifications across threads and allowing the individual observers to receive notifications in a single threaded manner.%0a%3c Pickle%0a%3c Pickle provides a basic facility for object serialization and deserialization in binary form.%0a%3c Value%0a%3c Values allow for specifying recursive data classes (lists and dictionaries) containing simple values (bool/int/string/etc). These values can also be serialized to JSON and back.%0a%3c LOG%0a%3c This is the basic interface for logging in Chromium.%0a%3c FileUtilProxy%0a%3c Generally you should not do file I/O on jank-sensitive threads (BrowserThread::UI and BrowserThread::IO), so you can proxy them to another thread (such as BrowserThread::FILE) via these utilities.%0a%3c Time, TimeDelta, TimeTicks, Timer%0a%3c Generally use TimeTicks instead of Time to keep a stable tick counter (Time may change if the user changes the computer clock).%0a%3c PrefService, ExtensionPrefs%0a%3c Containers for persistent state associated with a user Profile.%0a\ No newline at end of file%0a
host:1530427632=192.168.3.2
