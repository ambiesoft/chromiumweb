version=pmwiki-2.2.102 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1502860362
host=192.168.3.2
name=開発者向け.どのようにをウェブページ表示するか
rev=4
targets=
text=
time=1530427041
author:1530427041=
diff:1530427041:1503355875:=0a1,93%0a> https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome%0a> %0a> Chromiumがどのようにウェブページを表示するかをボトムアップに記述。[[マルチプロセスアーキテクチャ]]も読む。[[マルチプロセスリソースローディング]]も面白い。%0a> %0a> !概念的アプリケーションレイヤー%0a> %0a> Attach:ConceptualApplicationLayers.png%0a> (The original Google Doc for this illustration is http://goo.gl/MsEJX which is open for editing by any @chromium.org)%0a> %0a> %0a> %0a> 各階層は概念的アプリケーションレイヤー。下位レイヤーは上位レイヤに依存せず情報も持たない。%0a> *'''WebKit''': Safari, Chromiumその他WebKitベースのブラウザで使われる共用レンダリングエンジン。'''Port'''はWebKitの一部でプラットフォーム依存のシステムサービス（リソースロードやグラフィック）を統合する。%0a> *'''Glue''': WebKitの型をChromiumの型に変換する。これが我々のWebKit組み込みレイヤ。%0a> *'''Renderer / Render host: Chromiumのマルチプロセス組み込みレイヤ。相互の通知やコマンドのプロキシ。%0a> *'''WebContents''': Contentモジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスのHTMLレンダリングをビューへ容易に組み込み可能。[[コンテントモジュール]]のページ参照%0a> *'''Browser''': ブラウザウインドウを表す。多数のWebContentsからなる。%0a> *'''Tab Helpers''': 個別のオブジェクトでWebContentsと結びつく（WebContentsUserData混合）。ブラウザはこれらをWebContentsに結び付ける（faviconやinfobarなど）%0a> %0a> !WebKit%0a> 我々はオープンソースのWebKitをウェブページのレイアウトに使っている。コードはアップルからプルされ、/third_party/WebKitディレクトリにある。WebKitは主にWebCoreから構成されコアレイアウト機能をもつ。Javascriptを実行するJavaScriptCoreももつ。JavaScriptCoreはテスト目的で実行する。通常これはハイパフォーマンスなV8 JavaScriptエンジンに置き換えられている。AppleがWebKitと呼ぶレイヤでSafariなどではWebCoreとOS X間の組み込みAPIは実際には使っていない。我々はAppleからプルしたコードを一般にWebKitと呼んでいる。%0a> %0a> !WebKit port%0a> 最下位に我々のWebKit "port"がある。プラットフォーム固有の機能の実装でプラットフォーム独立のWebCoreとのインターフェースになる。ファイルはWebKitツリーにあり、chromiumディレクトリまたはChromiumサフィックスのファイルである。フォントレンダリングなどはプラットフォームごとに処理されなければならない。%0a> %0a> *ネットワークトラフィックはマルチプロセスリソースローディングで処理され、レンダープロセスからOSを利用しない。%0a> *グラフィックはAndroid用に開発されたSkiaグラフィックライブラリを利用する。これはクロスプラットフォームのグラフィックライブラリですべてのイメージと基本グラフィックを処理する（テキストは除く）。Skiaは/third_party/skiaにある。%0a> %0a> !WebKit glue%0a> ChromiumとWebKitは型などを含め別のコーディングルールで記述されている。WebKit glueはその間に入りChromiumにとってやりやすいインターフェースを提供する。/WebKit/glueにある。ネーミングはWebKitオブジェクトと同じようになっているが"Web"が初めにつく。例えばWebCore::FrameはWebFrameになる。%0a> %0a> "test shell"はベアボーンのウェブブラウザでWebKit portとglueのテストをする。%0a> %0a> !レンダープロセス%0a> https://www.chromium.org/_/rsrc/1342584100941/developers/design-documents/displaying-a-web-page-in-chrome/Renderingintherenderer-v2.png%0a> Chromiumのレンダープロセスはglueインタフェースを使いWebKit portを組み込む。多量のコードは含んでいない。その仕事はブラウザとのIPCチャネルのレンダラーサイドになることである。%0a> %0a> レンダラーのもっとも重要なクラスはRenderViewである。/content/renderer/render_view_impl.ccにある。これがウェブページを表す。ブラウザから、またブラウザへのナビゲーション関連のコマンドを処理する。これはRenderWidgetから継承されるがこれは描画や入力を処理する。RenderViewはブラウザとの通信に（レンダープロセスごとに）グローバルなRenderProcessを使う。%0a> %0a> !FAQ:RenderWidgetとRenderViewの違いは？%0a> RenderWidgetはWebCore::Widgetオブジェクトとマップされる。それは抽象インターフェースWebWidgetDelegateを実装することにより行う。RenderWidgetは基本的に１つのウインドウであり、入力と受け取り、描画の出力になる。RenderViewはRenderWidgetから継承され、タブやポップアップウインドウのコンテンツになり、ナビゲーション関連の命令を受け取る。RenderViewなしにRenderWidgetが存在するケースが１つだけありウェブページ上のセレクトボックスである。%0a> %0a> !レンダラー内のスレッド%0a> レンダラーは２つのスレッドを持つ。１つはRenderViewやWebKitが動くものである。（途中）%0a> %0a> !ブラウザプロセス%0a> https://www.chromium.org/_/rsrc/1220197831473/developers/design-documents/displaying-a-web-page-in-chrome/rendering%2520browser.png%0a> %0a> !下位レベルのブラウザプロセスのオブジェクト%0a> ブラウザのIOスレッド上でレンダープロセスとのIPC通信が行われる。このスレッド上ですべてのネットワーク通信も扱われる。%0a> %0a> メインスレッド（UIが動いている）でRenderProcessHostが初期化されるとき、新しくレンダラープロセスとChannelProxyというIPCオブジェクト（名前付きパイプ）がつくられる。このIPCオブジェクトはブラウザのIOスレッドで動き、名前付きパイプをリッスンし、メッセージをRenderProcessHostに返す。ResourceMessageFilterがこのチャネルにインストールされれば、メッセージをフィルタ出来る。%0a> %0a> RenderProcessHostはビュー関連のメッセージを適切なRenderViewHostにディスパッチする責任がある。%0a> %0a> !上位レベルのブラウザプロセスのオブジェクト%0a> ビュー固有のメッセージはRenderViewHost::OnMessageReceivedに到着する。ほとんどのメッセージはここで処理され残りはRenderWidgetHostへ回される。それぞれのプラットフォームでビュークラスがあり(RenderWidgetHostView[Aura|Gtk|Mac|Win])、ネイティブのビューシステムを実装する。%0a> %0a> RenderView/Widgetの上位にWebContentsオブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。WebContentsはウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[[コンテントモジュール]]のページを参照。%0a> %0a> WebContentsオブジェクトはTabContentsWrapperに含まれる。chromeディレクトリにありタブに責任を持つ。%0a> %0a> !イラストでの実例%0a> ナビゲーションやスタートアップのさらなる実例は[[Chromiumソースコードへの取り掛かり]]を参照。%0a> %0a> !"set cursor"メッセージの生涯%0a> カーソルの切り替えはレンダラーからブラウザへ送られる典型的メッセージである。レンダラでは以下のことが起こる。%0a> *Set cursorメッセージは入力イベントへの応答として内部的にWebKitが生成する。set cursorメッセージはRenderWidget::SetCursorから始まる。%0a> *それはRenderWidget::Sendを呼び、メッセージをディスパッチする。このメソッドはRenderViewからもブラウザにメッセージを送るために使用される。そしてRenderThread::Sendを呼ぶ。%0a> *これはIPC::SyncChannelを呼びブラウザへ送られる。%0a> %0a> そしたらブラウザは次のことを行う。%0a> *RenderProcessHost内にあるIPC::ChannelProxyはIOスレッドでこのメッセージを受け取る。%0a> *RenderProcessHost::OnMessageReceivedがメッセージを受け取る。いくつかのメッセージはここで直接処理され、残りはRenderViewHostへ送られる。%0a> *RenderViewHost::OnMessageReceivedにメッセージが到着する。多くのメッセージはここで処理される、我々のメッセージはここでは処理されない。%0a> *処理されなかったメッセージは自動的にRenderWidgetHostに送られる。我々のメッセージもここに送られる。%0a> *メッセージマップがついにメッセージを受け取るりRenderWidgetHost::OnMsgSetCurorが呼ばれる。ここで適切なUI関数が呼ばれマウスカーソルがセットされる。%0a> %0a> !"mouse click"メッセージの生涯%0a> マウスクリックメッセージはブラウザからレンダラーに送られる典型的メッセージ。%0a> *RederWidgetHostViewWin::OnMouseEventがブラウザのUIスレッドで呼ばれる。これはForwardMouseEventToRendererを呼ぶ。%0a> *このときマウス入力をプラットフォーム独立なWebMouseEventにまとめ、RenderWidgetHostに送る。%0a> *RenderWidgetHost::ForwardInputEventはIPCメッセージViewMsg_HandleInputEventを作成、WebInputEventをその中にシリアライズする。そしてRenderWidgetHost::Sendする。%0a> *RenderProcessHost::Sendに送られIPC::ChannelProxyで送られる。%0a> *内部的にはIPC:ChannelProxyはIOスレッドへのプロキシで、そこで名前付きパイプでレンダラーに送られる。%0a> %0a> 他のタイプのメッセージはWebContentsで作成されることに注意。例えばナビゲーション関連など。WebContentsからRenderViewHostへは同じような経路をたどる。%0a> %0a> そしてレンダラーでは：%0a> *メインスレッドのIPC::Channelがメッセージを受信し、IPC::ChannelProxyがレンダラースレッドでのプロキシになる。%0a> *RenderView::OnMessageReceivedがメッセージを受け取る。多くのメッセージはここで処理される。ただしマウスクリックは別で、RenderWidget::OnMessageReceivedに転送されその後RederWidget::OnHandleInputEventへ転送される。%0a> *WebWidgetImpl::HandleInputEventへ進み、WebKitのPlatformMouseEvnetクラスへ変換される。その後、WebCore::Widgetへ進む。%0a> %0a
host:1530427041=192.168.3.2
author:1503355875=
diff:1503355875:1502925244:=1,2d0%0a%3c https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome%0a%3c %0a
host:1503355875=192.168.0.2
author:1502925244=
diff:1502925244:1502860362:=1c1%0a%3c Chromiumがどのようにウェブページを表示するかをボトムアップに記述。[[マルチプロセスアーキテクチャ]]も読む。[[マルチプロセスリソースローディング]]も面白い。%0a---%0a> Chromiumがどのようにウェブページを表示するかをボトムアップに記述する。[[マルチプロセスアーキテクチャ]]を読んでおいてください。[[マルチプロセスリソースローディング]]にも興味があると思います。%0a
host:1502925244=192.168.0.2
author:1502860362=
diff:1502860362:1502860362:=1,91d0%0a%3c Chromiumがどのようにウェブページを表示するかをボトムアップに記述する。[[マルチプロセスアーキテクチャ]]を読んでおいてください。[[マルチプロセスリソースローディング]]にも興味があると思います。%0a%3c %0a%3c !概念的アプリケーションレイヤー%0a%3c %0a%3c Attach:ConceptualApplicationLayers.png%0a%3c (The original Google Doc for this illustration is http://goo.gl/MsEJX which is open for editing by any @chromium.org)%0a%3c %0a%3c %0a%3c %0a%3c 各階層は概念的アプリケーションレイヤー。下位レイヤーは上位レイヤに依存せず情報も持たない。%0a%3c *'''WebKit''': Safari, Chromiumその他WebKitベースのブラウザで使われる共用レンダリングエンジン。'''Port'''はWebKitの一部でプラットフォーム依存のシステムサービス（リソースロードやグラフィック）を統合する。%0a%3c *'''Glue''': WebKitの型をChromiumの型に変換する。これが我々のWebKit組み込みレイヤ。%0a%3c *'''Renderer / Render host: Chromiumのマルチプロセス組み込みレイヤ。相互の通知やコマンドのプロキシ。%0a%3c *'''WebContents''': Contentモジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスのHTMLレンダリングをビューへ容易に組み込み可能。[[コンテントモジュール]]のページ参照%0a%3c *'''Browser''': ブラウザウインドウを表す。多数のWebContentsからなる。%0a%3c *'''Tab Helpers''': 個別のオブジェクトでWebContentsと結びつく（WebContentsUserData混合）。ブラウザはこれらをWebContentsに結び付ける（faviconやinfobarなど）%0a%3c %0a%3c !WebKit%0a%3c 我々はオープンソースのWebKitをウェブページのレイアウトに使っている。コードはアップルからプルされ、/third_party/WebKitディレクトリにある。WebKitは主にWebCoreから構成されコアレイアウト機能をもつ。Javascriptを実行するJavaScriptCoreももつ。JavaScriptCoreはテスト目的で実行する。通常これはハイパフォーマンスなV8 JavaScriptエンジンに置き換えられている。AppleがWebKitと呼ぶレイヤでSafariなどではWebCoreとOS X間の組み込みAPIは実際には使っていない。我々はAppleからプルしたコードを一般にWebKitと呼んでいる。%0a%3c %0a%3c !WebKit port%0a%3c 最下位に我々のWebKit "port"がある。プラットフォーム固有の機能の実装でプラットフォーム独立のWebCoreとのインターフェースになる。ファイルはWebKitツリーにあり、chromiumディレクトリまたはChromiumサフィックスのファイルである。フォントレンダリングなどはプラットフォームごとに処理されなければならない。%0a%3c %0a%3c *ネットワークトラフィックはマルチプロセスリソースローディングで処理され、レンダープロセスからOSを利用しない。%0a%3c *グラフィックはAndroid用に開発されたSkiaグラフィックライブラリを利用する。これはクロスプラットフォームのグラフィックライブラリですべてのイメージと基本グラフィックを処理する（テキストは除く）。Skiaは/third_party/skiaにある。%0a%3c %0a%3c !WebKit glue%0a%3c ChromiumとWebKitは型などを含め別のコーディングルールで記述されている。WebKit glueはその間に入りChromiumにとってやりやすいインターフェースを提供する。/WebKit/glueにある。ネーミングはWebKitオブジェクトと同じようになっているが"Web"が初めにつく。例えばWebCore::FrameはWebFrameになる。%0a%3c %0a%3c "test shell"はベアボーンのウェブブラウザでWebKit portとglueのテストをする。%0a%3c %0a%3c !レンダープロセス%0a%3c https://www.chromium.org/_/rsrc/1342584100941/developers/design-documents/displaying-a-web-page-in-chrome/Renderingintherenderer-v2.png%0a%3c Chromiumのレンダープロセスはglueインタフェースを使いWebKit portを組み込む。多量のコードは含んでいない。その仕事はブラウザとのIPCチャネルのレンダラーサイドになることである。%0a%3c %0a%3c レンダラーのもっとも重要なクラスはRenderViewである。/content/renderer/render_view_impl.ccにある。これがウェブページを表す。ブラウザから、またブラウザへのナビゲーション関連のコマンドを処理する。これはRenderWidgetから継承されるがこれは描画や入力を処理する。RenderViewはブラウザとの通信に（レンダープロセスごとに）グローバルなRenderProcessを使う。%0a%3c %0a%3c !FAQ:RenderWidgetとRenderViewの違いは？%0a%3c RenderWidgetはWebCore::Widgetオブジェクトとマップされる。それは抽象インターフェースWebWidgetDelegateを実装することにより行う。RenderWidgetは基本的に１つのウインドウであり、入力と受け取り、描画の出力になる。RenderViewはRenderWidgetから継承され、タブやポップアップウインドウのコンテンツになり、ナビゲーション関連の命令を受け取る。RenderViewなしにRenderWidgetが存在するケースが１つだけありウェブページ上のセレクトボックスである。%0a%3c %0a%3c !レンダラー内のスレッド%0a%3c レンダラーは２つのスレッドを持つ。１つはRenderViewやWebKitが動くものである。（途中）%0a%3c %0a%3c !ブラウザプロセス%0a%3c https://www.chromium.org/_/rsrc/1220197831473/developers/design-documents/displaying-a-web-page-in-chrome/rendering%2520browser.png%0a%3c %0a%3c !下位レベルのブラウザプロセスのオブジェクト%0a%3c ブラウザのIOスレッド上でレンダープロセスとのIPC通信が行われる。このスレッド上ですべてのネットワーク通信も扱われる。%0a%3c %0a%3c メインスレッド（UIが動いている）でRenderProcessHostが初期化されるとき、新しくレンダラープロセスとChannelProxyというIPCオブジェクト（名前付きパイプ）がつくられる。このIPCオブジェクトはブラウザのIOスレッドで動き、名前付きパイプをリッスンし、メッセージをRenderProcessHostに返す。ResourceMessageFilterがこのチャネルにインストールされれば、メッセージをフィルタ出来る。%0a%3c %0a%3c RenderProcessHostはビュー関連のメッセージを適切なRenderViewHostにディスパッチする責任がある。%0a%3c %0a%3c !上位レベルのブラウザプロセスのオブジェクト%0a%3c ビュー固有のメッセージはRenderViewHost::OnMessageReceivedに到着する。ほとんどのメッセージはここで処理され残りはRenderWidgetHostへ回される。それぞれのプラットフォームでビュークラスがあり(RenderWidgetHostView[Aura|Gtk|Mac|Win])、ネイティブのビューシステムを実装する。%0a%3c %0a%3c RenderView/Widgetの上位にWebContentsオブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。WebContentsはウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[[コンテントモジュール]]のページを参照。%0a%3c %0a%3c WebContentsオブジェクトはTabContentsWrapperに含まれる。chromeディレクトリにありタブに責任を持つ。%0a%3c %0a%3c !イラストでの実例%0a%3c ナビゲーションやスタートアップのさらなる実例は[[Chromiumソースコードへの取り掛かり]]を参照。%0a%3c %0a%3c !"set cursor"メッセージの生涯%0a%3c カーソルの切り替えはレンダラーからブラウザへ送られる典型的メッセージである。レンダラでは以下のことが起こる。%0a%3c *Set cursorメッセージは入力イベントへの応答として内部的にWebKitが生成する。set cursorメッセージはRenderWidget::SetCursorから始まる。%0a%3c *それはRenderWidget::Sendを呼び、メッセージをディスパッチする。このメソッドはRenderViewからもブラウザにメッセージを送るために使用される。そしてRenderThread::Sendを呼ぶ。%0a%3c *これはIPC::SyncChannelを呼びブラウザへ送られる。%0a%3c %0a%3c そしたらブラウザは次のことを行う。%0a%3c *RenderProcessHost内にあるIPC::ChannelProxyはIOスレッドでこのメッセージを受け取る。%0a%3c *RenderProcessHost::OnMessageReceivedがメッセージを受け取る。いくつかのメッセージはここで直接処理され、残りはRenderViewHostへ送られる。%0a%3c *RenderViewHost::OnMessageReceivedにメッセージが到着する。多くのメッセージはここで処理される、我々のメッセージはここでは処理されない。%0a%3c *処理されなかったメッセージは自動的にRenderWidgetHostに送られる。我々のメッセージもここに送られる。%0a%3c *メッセージマップがついにメッセージを受け取るりRenderWidgetHost::OnMsgSetCurorが呼ばれる。ここで適切なUI関数が呼ばれマウスカーソルがセットされる。%0a%3c %0a%3c !"mouse click"メッセージの生涯%0a%3c マウスクリックメッセージはブラウザからレンダラーに送られる典型的メッセージ。%0a%3c *RederWidgetHostViewWin::OnMouseEventがブラウザのUIスレッドで呼ばれる。これはForwardMouseEventToRendererを呼ぶ。%0a%3c *このときマウス入力をプラットフォーム独立なWebMouseEventにまとめ、RenderWidgetHostに送る。%0a%3c *RenderWidgetHost::ForwardInputEventはIPCメッセージViewMsg_HandleInputEventを作成、WebInputEventをその中にシリアライズする。そしてRenderWidgetHost::Sendする。%0a%3c *RenderProcessHost::Sendに送られIPC::ChannelProxyで送られる。%0a%3c *内部的にはIPC:ChannelProxyはIOスレッドへのプロキシで、そこで名前付きパイプでレンダラーに送られる。%0a%3c %0a%3c 他のタイプのメッセージはWebContentsで作成されることに注意。例えばナビゲーション関連など。WebContentsからRenderViewHostへは同じような経路をたどる。%0a%3c %0a%3c そしてレンダラーでは：%0a%3c *メインスレッドのIPC::Channelがメッセージを受信し、IPC::ChannelProxyがレンダラースレッドでのプロキシになる。%0a%3c *RenderView::OnMessageReceivedがメッセージを受け取る。多くのメッセージはここで処理される。ただしマウスクリックは別で、RenderWidget::OnMessageReceivedに転送されその後RederWidget::OnHandleInputEventへ転送される。%0a%3c *WebWidgetImpl::HandleInputEventへ進み、WebKitのPlatformMouseEvnetクラスへ変換される。その後、WebCore::Widgetへ進む。%0a%3c %0a
host:1502860362=192.168.0.2
