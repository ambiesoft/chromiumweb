version=pmwiki-2.2.102 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.78 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1502794483
host=192.168.0.2
name=デザイン文書.どのようにをウェブページ表示するか
rev=24
targets=
text=
time=1502860370
author:1502860370=
diff:1502860370:1502845646:=0a1,91%0a> Chromiumがどのようにウェブページを表示するかをボトムアップに記述する。[[マルチプロセスアーキテクチャ]]を読んでおいてください。[[マルチプロセスリソースローディング]]にも興味があると思います。%0a> %0a> !概念的アプリケーションレイヤー%0a> %0a> Attach:ConceptualApplicationLayers.png%0a> (The original Google Doc for this illustration is http://goo.gl/MsEJX which is open for editing by any @chromium.org)%0a> %0a> %0a> %0a> 各階層は概念的アプリケーションレイヤー。下位レイヤーは上位レイヤに依存せず情報も持たない。%0a> *'''WebKit''': Safari, Chromiumその他WebKitベースのブラウザで使われる共用レンダリングエンジン。'''Port'''はWebKitの一部でプラットフォーム依存のシステムサービス（リソースロードやグラフィック）を統合する。%0a> *'''Glue''': WebKitの型をChromiumの型に変換する。これが我々のWebKit組み込みレイヤ。%0a> *'''Renderer / Render host: Chromiumのマルチプロセス組み込みレイヤ。相互の通知やコマンドのプロキシ。%0a> *'''WebContents''': Contentモジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスのHTMLレンダリングをビューへ容易に組み込み可能。[[コンテントモジュール]]のページ参照%0a> *'''Browser''': ブラウザウインドウを表す。多数のWebContentsからなる。%0a> *'''Tab Helpers''': 個別のオブジェクトでWebContentsと結びつく（WebContentsUserData混合）。ブラウザはこれらをWebContentsに結び付ける（faviconやinfobarなど）%0a> %0a> !WebKit%0a> 我々はオープンソースのWebKitをウェブページのレイアウトに使っている。コードはアップルからプルされ、/third_party/WebKitディレクトリにある。WebKitは主にWebCoreから構成されコアレイアウト機能をもつ。Javascriptを実行するJavaScriptCoreももつ。JavaScriptCoreはテスト目的で実行する。通常これはハイパフォーマンスなV8 JavaScriptエンジンに置き換えられている。AppleがWebKitと呼ぶレイヤでSafariなどではWebCoreとOS X間の組み込みAPIは実際には使っていない。我々はAppleからプルしたコードを一般にWebKitと呼んでいる。%0a> %0a> !WebKit port%0a> 最下位に我々のWebKit "port"がある。プラットフォーム固有の機能の実装でプラットフォーム独立のWebCoreとのインターフェースになる。ファイルはWebKitツリーにあり、chromiumディレクトリまたはChromiumサフィックスのファイルである。フォントレンダリングなどはプラットフォームごとに処理されなければならない。%0a> %0a> *ネットワークトラフィックはマルチプロセスリソースローディングで処理され、レンダープロセスからOSを利用しない。%0a> *グラフィックはAndroid用に開発されたSkiaグラフィックライブラリを利用する。これはクロスプラットフォームのグラフィックライブラリですべてのイメージと基本グラフィックを処理する（テキストは除く）。Skiaは/third_party/skiaにある。%0a> %0a> !WebKit glue%0a> ChromiumとWebKitは型などを含め別のコーディングルールで記述されている。WebKit glueはその間に入りChromiumにとってやりやすいインターフェースを提供する。/WebKit/glueにある。ネーミングはWebKitオブジェクトと同じようになっているが"Web"が初めにつく。例えばWebCore::FrameはWebFrameになる。%0a> %0a> "test shell"はベアボーンのウェブブラウザでWebKit portとglueのテストをする。%0a> %0a> !レンダープロセス%0a> https://www.chromium.org/_/rsrc/1342584100941/developers/design-documents/displaying-a-web-page-in-chrome/Renderingintherenderer-v2.png%0a> Chromiumのレンダープロセスはglueインタフェースを使いWebKit portを組み込む。多量のコードは含んでいない。その仕事はブラウザとのIPCチャネルのレンダラーサイドになることである。%0a> %0a> レンダラーのもっとも重要なクラスはRenderViewである。/content/renderer/render_view_impl.ccにある。これがウェブページを表す。ブラウザから、またブラウザへのナビゲーション関連のコマンドを処理する。これはRenderWidgetから継承されるがこれは描画や入力を処理する。RenderViewはブラウザとの通信に（レンダープロセスごとに）グローバルなRenderProcessを使う。%0a> %0a> !FAQ:RenderWidgetとRenderViewの違いは？%0a> RenderWidgetはWebCore::Widgetオブジェクトとマップされる。それは抽象インターフェースWebWidgetDelegateを実装することにより行う。RenderWidgetは基本的に１つのウインドウであり、入力と受け取り、描画の出力になる。RenderViewはRenderWidgetから継承され、タブやポップアップウインドウのコンテンツになり、ナビゲーション関連の命令を受け取る。RenderViewなしにRenderWidgetが存在するケースが１つだけありウェブページ上のセレクトボックスである。%0a> %0a> !レンダラー内のスレッド%0a> レンダラーは２つのスレッドを持つ。１つはRenderViewやWebKitが動くものである。（途中）%0a> %0a> !ブラウザプロセス%0a> https://www.chromium.org/_/rsrc/1220197831473/developers/design-documents/displaying-a-web-page-in-chrome/rendering%2520browser.png%0a> %0a> !下位レベルのブラウザプロセスのオブジェクト%0a> ブラウザのIOスレッド上でレンダープロセスとのIPC通信が行われる。このスレッド上ですべてのネットワーク通信も扱われる。%0a> %0a> メインスレッド（UIが動いている）でRenderProcessHostが初期化されるとき、新しくレンダラープロセスとChannelProxyというIPCオブジェクト（名前付きパイプ）がつくられる。このIPCオブジェクトはブラウザのIOスレッドで動き、名前付きパイプをリッスンし、メッセージをRenderProcessHostに返す。ResourceMessageFilterがこのチャネルにインストールされれば、メッセージをフィルタ出来る。%0a> %0a> RenderProcessHostはビュー関連のメッセージを適切なRenderViewHostにディスパッチする責任がある。%0a> %0a> !上位レベルのブラウザプロセスのオブジェクト%0a> ビュー固有のメッセージはRenderViewHost::OnMessageReceivedに到着する。ほとんどのメッセージはここで処理され残りはRenderWidgetHostへ回される。それぞれのプラットフォームでビュークラスがあり(RenderWidgetHostView[Aura|Gtk|Mac|Win])、ネイティブのビューシステムを実装する。%0a> %0a> RenderView/Widgetの上位にWebContentsオブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。WebContentsはウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[[コンテントモジュール]]のページを参照。%0a> %0a> WebContentsオブジェクトはTabContentsWrapperに含まれる。chromeディレクトリにありタブに責任を持つ。%0a> %0a> !イラストでの実例%0a> ナビゲーションやスタートアップのさらなる実例は[[Chromiumソースコードへの取り掛かり]]を参照。%0a> %0a> !"set cursor"メッセージの生涯%0a> カーソルの切り替えはレンダラーからブラウザへ送られる典型的メッセージである。レンダラでは以下のことが起こる。%0a> *Set cursorメッセージは入力イベントへの応答として内部的にWebKitが生成する。set cursorメッセージはRenderWidget::SetCursorから始まる。%0a> *それはRenderWidget::Sendを呼び、メッセージをディスパッチする。このメソッドはRenderViewからもブラウザにメッセージを送るために使用される。そしてRenderThread::Sendを呼ぶ。%0a> *これはIPC::SyncChannelを呼びブラウザへ送られる。%0a> %0a> そしたらブラウザは次のことを行う。%0a> *RenderProcessHost内にあるIPC::ChannelProxyはIOスレッドでこのメッセージを受け取る。%0a> *RenderProcessHost::OnMessageReceivedがメッセージを受け取る。いくつかのメッセージはここで直接処理され、残りはRenderViewHostへ送られる。%0a> *RenderViewHost::OnMessageReceivedにメッセージが到着する。多くのメッセージはここで処理される、我々のメッセージはここでは処理されない。%0a> *処理されなかったメッセージは自動的にRenderWidgetHostに送られる。我々のメッセージもここに送られる。%0a> *メッセージマップがついにメッセージを受け取るりRenderWidgetHost::OnMsgSetCurorが呼ばれる。ここで適切なUI関数が呼ばれマウスカーソルがセットされる。%0a> %0a> !"mouse click"メッセージの生涯%0a> マウスクリックメッセージはブラウザからレンダラーに送られる典型的メッセージ。%0a> *RederWidgetHostViewWin::OnMouseEventがブラウザのUIスレッドで呼ばれる。これはForwardMouseEventToRendererを呼ぶ。%0a> *このときマウス入力をプラットフォーム独立なWebMouseEventにまとめ、RenderWidgetHostに送る。%0a> *RenderWidgetHost::ForwardInputEventはIPCメッセージViewMsg_HandleInputEventを作成、WebInputEventをその中にシリアライズする。そしてRenderWidgetHost::Sendする。%0a> *RenderProcessHost::Sendに送られIPC::ChannelProxyで送られる。%0a> *内部的にはIPC:ChannelProxyはIOスレッドへのプロキシで、そこで名前付きパイプでレンダラーに送られる。%0a> %0a> 他のタイプのメッセージはWebContentsで作成されることに注意。例えばナビゲーション関連など。WebContentsからRenderViewHostへは同じような経路をたどる。%0a> %0a> そしてレンダラーでは：%0a> *メインスレッドのIPC::Channelがメッセージを受信し、IPC::ChannelProxyがレンダラースレッドでのプロキシになる。%0a> *RenderView::OnMessageReceivedがメッセージを受け取る。多くのメッセージはここで処理される。ただしマウスクリックは別で、RenderWidget::OnMessageReceivedに転送されその後RederWidget::OnHandleInputEventへ転送される。%0a> *WebWidgetImpl::HandleInputEventへ進み、WebKitのPlatformMouseEvnetクラスへ変換される。その後、WebCore::Widgetへ進む。%0a> %0a
host:1502860370=192.168.0.2
author:1502845646=
diff:1502845646:1502845375:=
host:1502845646=192.168.0.2
author:1502845375=
diff:1502845375:1502845155:=1,2c1,2%0a%3c Chromiumがどのようにウェブページを表示するかをボトムアップに記述する。[[マルチプロセスアーキテクチャ]]を読んでおいてください。[[マルチプロセスリソースローディング]]にも興味があると思います。%0a%3c %0a---%0a> Chromiumがどのようにウェブページを表示するかをボトムアップに記述する。[[マルチプロセスアーキテクチャ]]を読んでおいてください。[マルチプロセスリソースローディング]にも興味があると思います。%0a> %0a14c14%0a%3c *'''WebContents''': Contentモジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスのHTMLレンダリングをビューへ容易に組み込み可能。[[コンテントモジュール]]のページ参照%0a---%0a> *'''WebContents''': Contentモジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスのHTMLレンダリングをビューへ容易に組み込み可能。[コンテントモジュール]のページ参照%0a57,58c57,58%0a%3c RenderView/Widgetの上位にWebContentsオブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。WebContentsはウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[[コンテントモジュール]]のページを参照。%0a%3c %0a---%0a> RenderView/Widgetの上位にWebContentsオブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。WebContentsはウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[コンテントモジュール]のページを参照。%0a> %0a62c62%0a%3c ナビゲーションやスタートアップのさらなる実例は[[Chromiumソースコードへの取り掛かり]]を参照。%0a---%0a> ナビゲーションやスタートアップのさらなる実例は[Chromiumソースコードへの取り掛かり]を参照。%0a
host:1502845375=192.168.0.2
author:1502845155=
diff:1502845155:1502845068:=1c1%0a%3c Chromiumがどのようにウェブページを表示するかをボトムアップに記述する。[[マルチプロセスアーキテクチャ]]を読んでおいてください。[マルチプロセスリソースローディング]にも興味があると思います。%0a---%0a> Chromiumがどのようにウェブページを表示するかをボトムアップに記述する。[マルチプロセスアーキテクチャ]を読んでおいてください。[マルチプロセスリソースローディング]にも興味があると思います。%0a
host:1502845155=192.168.0.2
author:1502845068=
diff:1502845068:1502804365:=77,91c77%0a%3c !"mouse click"メッセージの生涯%0a%3c マウスクリックメッセージはブラウザからレンダラーに送られる典型的メッセージ。%0a%3c *RederWidgetHostViewWin::OnMouseEventがブラウザのUIスレッドで呼ばれる。これはForwardMouseEventToRendererを呼ぶ。%0a%3c *このときマウス入力をプラットフォーム独立なWebMouseEventにまとめ、RenderWidgetHostに送る。%0a%3c *RenderWidgetHost::ForwardInputEventはIPCメッセージViewMsg_HandleInputEventを作成、WebInputEventをその中にシリアライズする。そしてRenderWidgetHost::Sendする。%0a%3c *RenderProcessHost::Sendに送られIPC::ChannelProxyで送られる。%0a%3c *内部的にはIPC:ChannelProxyはIOスレッドへのプロキシで、そこで名前付きパイプでレンダラーに送られる。%0a%3c %0a%3c 他のタイプのメッセージはWebContentsで作成されることに注意。例えばナビゲーション関連など。WebContentsからRenderViewHostへは同じような経路をたどる。%0a%3c %0a%3c そしてレンダラーでは：%0a%3c *メインスレッドのIPC::Channelがメッセージを受信し、IPC::ChannelProxyがレンダラースレッドでのプロキシになる。%0a%3c *RenderView::OnMessageReceivedがメッセージを受け取る。多くのメッセージはここで処理される。ただしマウスクリックは別で、RenderWidget::OnMessageReceivedに転送されその後RederWidget::OnHandleInputEventへ転送される。%0a%3c *WebWidgetImpl::HandleInputEventへ進み、WebKitのPlatformMouseEvnetクラスへ変換される。その後、WebCore::Widgetへ進む。%0a%3c %0a---%0a> （途中）%0a\ No newline at end of file%0a
host:1502845068=192.168.0.2
author:1502804365=
diff:1502804365:1502802747:=77d76%0a%3c （途中）%0a\ No newline at end of file%0a
host:1502804365=192.168.0.2
author:1502802747=
diff:1502802747:1502801938:=73,76c73%0a%3c *RenderViewHost::OnMessageReceivedにメッセージが到着する。多くのメッセージはここで処理される、我々のメッセージはここでは処理されない。%0a%3c *処理されなかったメッセージは自動的にRenderWidgetHostに送られる。我々のメッセージもここに送られる。%0a%3c *メッセージマップがついにメッセージを受け取るりRenderWidgetHost::OnMsgSetCurorが呼ばれる。ここで適切なUI関数が呼ばれマウスカーソルがセットされる。%0a%3c %0a---%0a> *%0a\ No newline at end of file%0a
host:1502802747=192.168.0.2
author:1502801938=
diff:1502801938:1502801265:=62,73c62%0a%3c ナビゲーションやスタートアップのさらなる実例は[Chromiumソースコードへの取り掛かり]を参照。%0a%3c %0a%3c !"set cursor"メッセージの生涯%0a%3c カーソルの切り替えはレンダラーからブラウザへ送られる典型的メッセージである。レンダラでは以下のことが起こる。%0a%3c *Set cursorメッセージは入力イベントへの応答として内部的にWebKitが生成する。set cursorメッセージはRenderWidget::SetCursorから始まる。%0a%3c *それはRenderWidget::Sendを呼び、メッセージをディスパッチする。このメソッドはRenderViewからもブラウザにメッセージを送るために使用される。そしてRenderThread::Sendを呼ぶ。%0a%3c *これはIPC::SyncChannelを呼びブラウザへ送られる。%0a%3c %0a%3c そしたらブラウザは次のことを行う。%0a%3c *RenderProcessHost内にあるIPC::ChannelProxyはIOスレッドでこのメッセージを受け取る。%0a%3c *RenderProcessHost::OnMessageReceivedがメッセージを受け取る。いくつかのメッセージはここで直接処理され、残りはRenderViewHostへ送られる。%0a%3c *%0a\ No newline at end of file%0a---%0a> ナビゲーションやスタートアップのさらなる実例は[Chromiumソースコードへの取り掛かり]を参照。%0a\ No newline at end of file%0a
host:1502801938=192.168.0.2
author:1502801265=
diff:1502801265:1502800795:=57,62c57%0a%3c RenderView/Widgetの上位にWebContentsオブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。WebContentsはウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[コンテントモジュール]のページを参照。%0a%3c %0a%3c WebContentsオブジェクトはTabContentsWrapperに含まれる。chromeディレクトリにありタブに責任を持つ。%0a%3c %0a%3c !イラストでの実例%0a%3c ナビゲーションやスタートアップのさらなる実例は[Chromiumソースコードへの取り掛かり]を参照。%0a\ No newline at end of file%0a---%0a> %0a
host:1502801265=192.168.0.2
author:1502800795=
diff:1502800795:1502799224:=42,57c42,44%0a%3c レンダラーは２つのスレッドを持つ。１つはRenderViewやWebKitが動くものである。（途中）%0a%3c %0a%3c !ブラウザプロセス%0a%3c https://www.chromium.org/_/rsrc/1220197831473/developers/design-documents/displaying-a-web-page-in-chrome/rendering%2520browser.png%0a%3c %0a%3c !下位レベルのブラウザプロセスのオブジェクト%0a%3c ブラウザのIOスレッド上でレンダープロセスとのIPC通信が行われる。このスレッド上ですべてのネットワーク通信も扱われる。%0a%3c %0a%3c メインスレッド（UIが動いている）でRenderProcessHostが初期化されるとき、新しくレンダラープロセスとChannelProxyというIPCオブジェクト（名前付きパイプ）がつくられる。このIPCオブジェクトはブラウザのIOスレッドで動き、名前付きパイプをリッスンし、メッセージをRenderProcessHostに返す。ResourceMessageFilterがこのチャネルにインストールされれば、メッセージをフィルタ出来る。%0a%3c %0a%3c RenderProcessHostはビュー関連のメッセージを適切なRenderViewHostにディスパッチする責任がある。%0a%3c %0a%3c !上位レベルのブラウザプロセスのオブジェクト%0a%3c ビュー固有のメッセージはRenderViewHost::OnMessageReceivedに到着する。ほとんどのメッセージはここで処理され残りはRenderWidgetHostへ回される。それぞれのプラットフォームでビュークラスがあり(RenderWidgetHostView[Aura|Gtk|Mac|Win])、ネイティブのビューシステムを実装する。%0a%3c %0a%3c %0a---%0a> レンダラーは２つのスレッドを持つ。１つはRenderViewやWebKitが動くものである。%0a> %0a> https://www.chromium.org/_/rsrc/1220197831473/developers/design-documents/displaying-a-web-page-in-chrome/rendering%2520browser.png%0a\ No newline at end of file%0a
host:1502800795=192.168.0.2
author:1502799224=
diff:1502799224:1502798429:=39,44c39%0a%3c RenderWidgetはWebCore::Widgetオブジェクトとマップされる。それは抽象インターフェースWebWidgetDelegateを実装することにより行う。RenderWidgetは基本的に１つのウインドウであり、入力と受け取り、描画の出力になる。RenderViewはRenderWidgetから継承され、タブやポップアップウインドウのコンテンツになり、ナビゲーション関連の命令を受け取る。RenderViewなしにRenderWidgetが存在するケースが１つだけありウェブページ上のセレクトボックスである。%0a%3c %0a%3c !レンダラー内のスレッド%0a%3c レンダラーは２つのスレッドを持つ。１つはRenderViewやWebKitが動くものである。%0a%3c %0a%3c https://www.chromium.org/_/rsrc/1220197831473/developers/design-documents/displaying-a-web-page-in-chrome/rendering%2520browser.png%0a\ No newline at end of file%0a---%0a> RenderWidgetはWebCore::Widgetオブジェクトとマップされる。それは抽象インターフェースWebWidgetDelegateを実装することにより行う。RenderWidgetは基本的に１つのウインドウであり、入力と受け取り、描画の出力になる。RenderViewはRenderWidgetから継承され、タブやポップアップウインドウのコンテンツになり、ナビゲーション関連の命令を受け取る。RenderViewなしにRenderWidgetが存在する。%0a\ No newline at end of file%0a
host:1502799224=192.168.0.2
author:1502798429=
diff:1502798429:1502798050:=39d38%0a%3c RenderWidgetはWebCore::Widgetオブジェクトとマップされる。それは抽象インターフェースWebWidgetDelegateを実装することにより行う。RenderWidgetは基本的に１つのウインドウであり、入力と受け取り、描画の出力になる。RenderViewはRenderWidgetから継承され、タブやポップアップウインドウのコンテンツになり、ナビゲーション関連の命令を受け取る。RenderViewなしにRenderWidgetが存在する。%0a\ No newline at end of file%0a
host:1502798429=192.168.0.2
author:1502798050=
diff:1502798050:1502797562:=33,38c33%0a%3c https://www.chromium.org/_/rsrc/1342584100941/developers/design-documents/displaying-a-web-page-in-chrome/Renderingintherenderer-v2.png%0a%3c Chromiumのレンダープロセスはglueインタフェースを使いWebKit portを組み込む。多量のコードは含んでいない。その仕事はブラウザとのIPCチャネルのレンダラーサイドになることである。%0a%3c %0a%3c レンダラーのもっとも重要なクラスはRenderViewである。/content/renderer/render_view_impl.ccにある。これがウェブページを表す。ブラウザから、またブラウザへのナビゲーション関連のコマンドを処理する。これはRenderWidgetから継承されるがこれは描画や入力を処理する。RenderViewはブラウザとの通信に（レンダープロセスごとに）グローバルなRenderProcessを使う。%0a%3c %0a%3c !FAQ:RenderWidgetとRenderViewの違いは？%0a---%0a> https://www.chromium.org/_/rsrc/1342584100941/developers/design-documents/displaying-a-web-page-in-chrome/Renderingintherenderer-v2.png%0a\ No newline at end of file%0a
host:1502798050=192.168.0.2
author:1502797562=
diff:1502797562:1502797404:=30,33d29%0a%3c "test shell"はベアボーンのウェブブラウザでWebKit portとglueのテストをする。%0a%3c %0a%3c !レンダープロセス%0a%3c https://www.chromium.org/_/rsrc/1342584100941/developers/design-documents/displaying-a-web-page-in-chrome/Renderingintherenderer-v2.png%0a\ No newline at end of file%0a
host:1502797562=192.168.0.2
author:1502797404=
diff:1502797404:1502797177:=28c28%0a%3c ChromiumとWebKitは型などを含め別のコーディングルールで記述されている。WebKit glueはその間に入りChromiumにとってやりやすいインターフェースを提供する。/WebKit/glueにある。ネーミングはWebKitオブジェクトと同じようになっているが"Web"が初めにつく。例えばWebCore::FrameはWebFrameになる。%0a---%0a> %0a
host:1502797404=192.168.0.2
author:1502797177=
diff:1502797177:1502795026:=10,27d9%0a%3c 各階層は概念的アプリケーションレイヤー。下位レイヤーは上位レイヤに依存せず情報も持たない。%0a%3c *'''WebKit''': Safari, Chromiumその他WebKitベースのブラウザで使われる共用レンダリングエンジン。'''Port'''はWebKitの一部でプラットフォーム依存のシステムサービス（リソースロードやグラフィック）を統合する。%0a%3c *'''Glue''': WebKitの型をChromiumの型に変換する。これが我々のWebKit組み込みレイヤ。%0a%3c *'''Renderer / Render host: Chromiumのマルチプロセス組み込みレイヤ。相互の通知やコマンドのプロキシ。%0a%3c *'''WebContents''': Contentモジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスのHTMLレンダリングをビューへ容易に組み込み可能。[コンテントモジュール]のページ参照%0a%3c *'''Browser''': ブラウザウインドウを表す。多数のWebContentsからなる。%0a%3c *'''Tab Helpers''': 個別のオブジェクトでWebContentsと結びつく（WebContentsUserData混合）。ブラウザはこれらをWebContentsに結び付ける（faviconやinfobarなど）%0a%3c %0a%3c !WebKit%0a%3c 我々はオープンソースのWebKitをウェブページのレイアウトに使っている。コードはアップルからプルされ、/third_party/WebKitディレクトリにある。WebKitは主にWebCoreから構成されコアレイアウト機能をもつ。Javascriptを実行するJavaScriptCoreももつ。JavaScriptCoreはテスト目的で実行する。通常これはハイパフォーマンスなV8 JavaScriptエンジンに置き換えられている。AppleがWebKitと呼ぶレイヤでSafariなどではWebCoreとOS X間の組み込みAPIは実際には使っていない。我々はAppleからプルしたコードを一般にWebKitと呼んでいる。%0a%3c %0a%3c !WebKit port%0a%3c 最下位に我々のWebKit "port"がある。プラットフォーム固有の機能の実装でプラットフォーム独立のWebCoreとのインターフェースになる。ファイルはWebKitツリーにあり、chromiumディレクトリまたはChromiumサフィックスのファイルである。フォントレンダリングなどはプラットフォームごとに処理されなければならない。%0a%3c %0a%3c *ネットワークトラフィックはマルチプロセスリソースローディングで処理され、レンダープロセスからOSを利用しない。%0a%3c *グラフィックはAndroid用に開発されたSkiaグラフィックライブラリを利用する。これはクロスプラットフォームのグラフィックライブラリですべてのイメージと基本グラフィックを処理する（テキストは除く）。Skiaは/third_party/skiaにある。%0a%3c %0a%3c !WebKit glue%0a
host:1502797177=192.168.0.2
author:1502795026=
diff:1502795026:1502794997:=6,7d5%0a%3c (The original Google Doc for this illustration is http://goo.gl/MsEJX which is open for editing by any @chromium.org)%0a%3c %0a
host:1502795026=192.168.0.2
author:1502794997=
diff:1502794997:1502794951:=5c5%0a%3c Attach:ConceptualApplicationLayers.png%0a---%0a> [[Page|Attach:ConceptualApplicationLayers.png]]%0a
host:1502794997=192.168.0.2
author:1502794951=
diff:1502794951:1502794899:=4,5c4%0a%3c %0a%3c [[Page|Attach:ConceptualApplicationLayers.png]]%0a---%0a> [Page|ConceptualApplicationLayers.png]%0a
host:1502794951=192.168.0.2
author:1502794899=
diff:1502794899:1502794838:=4,5c4%0a%3c [Page|ConceptualApplicationLayers.png]%0a%3c %0a---%0a> %25width=50px%25 https://docs.google.com/drawings/pub?id=1gdSTfvLxbJDbX8oiWo5LTwAmXmdMQvjoUhYEhfhj0-k&w=473&h=211%0a
host:1502794899=192.168.0.2
author:1502794838=
diff:1502794838:1502794806:=
host:1502794838=192.168.0.2
author:1502794806=
diff:1502794806:1502794582:=4,6c4%0a%3c %25width=50px%25 https://docs.google.com/drawings/pub?id=1gdSTfvLxbJDbX8oiWo5LTwAmXmdMQvjoUhYEhfhj0-k&w=473&h=211%0a%3c %0a%3c %0a---%0a> https://docs.google.com/drawings/pub?id=1gdSTfvLxbJDbX8oiWo5LTwAmXmdMQvjoUhYEhfhj0-k&w=473&h=211 | '''a'''%0a
host:1502794806=192.168.0.2
author:1502794582=
diff:1502794582:1502794483:=4c4%0a%3c https://docs.google.com/drawings/pub?id=1gdSTfvLxbJDbX8oiWo5LTwAmXmdMQvjoUhYEhfhj0-k&w=473&h=211 | '''a'''%0a---%0a> https://docs.google.com/drawings/pub?id=1gdSTfvLxbJDbX8oiWo5LTwAmXmdMQvjoUhYEhfhj0-k&w=473&h=211%0a
host:1502794582=192.168.0.2
author:1502794483=
diff:1502794483:1502794483:=1,5d0%0a%3c Chromiumがどのようにウェブページを表示するかをボトムアップに記述する。[マルチプロセスアーキテクチャ]を読んでおいてください。[マルチプロセスリソースローディング]にも興味があると思います。%0a%3c %0a%3c !概念的アプリケーションレイヤー%0a%3c https://docs.google.com/drawings/pub?id=1gdSTfvLxbJDbX8oiWo5LTwAmXmdMQvjoUhYEhfhj0-k&w=473&h=211%0a%3c %0a
host:1502794483=192.168.0.2
