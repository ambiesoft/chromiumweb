version=pmwiki-2.2.102 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko
author=
charset=UTF-8
csum=
ctime=1502860434
host=192.168.0.2
name=開発者向け.ソースコードの機能分類
rev=2
targets=開発者向け.マルチプロセスアーキテクチャ,開発者向け.IPCの安全性情報,開発者向け.マルチプロセスリソースローディング
text=https://www.chromium.org/developers/design-documents/inter-process-communication%0a%0a!!全体像%0aChromiumは[[マルチプロセスアーキテクチャ]]で多くのプロセスもち、それぞれが通信する。基本的に名前付きパイプを使う。LinuxやOS Xではsocketpair()を使う。通信は非同期でおこわなれる。%0a%0a安全はIPC端点を書くには[[IPCの安全性情報]]を参照。%0a%0a!!ブラウザ内でのIPC%0aブラウザとレンダラの通信は分離されたIOスレッドで行う。メッセージはChannelProxyを通じて送受信される。利点としては重たくなるリソース要求（ウェブページなど）がIOスレッドで行われUIがブロックしなくなること。RenderProcessHostによりChannelProxy::MessageFilterがインストールされ、このフィルターはIOで動き、リソース要求を横取りし、それをリソースディスパッチャーへ転送する。詳しくは[[マルチプロセスリソースローディング]]を参照。%0a%0a!!レンダラでのIPC%0aそれぞれのレンダラもメッセージを処理するスレッドを持つ（ここの場合はメインスレッド）。レンダリングや他の処理は別スレッドで行う。ほとんどのメッセージはブラウザから送られ、メインスレッドを通じてWebKitに到達する、逆も真。さらに同期通信を行うスレッドもある。%0a%0a!メッセージ%0a!!メッセージの種類%0a大きく"routed"と"control"の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスはMessageRouterオブジェクトを持ち、それを登録する。%0a%0a例えばレンダリング中、controlメッセージは特定のビュー対象ではなく、RenderProcess（レンダラ側）やRenderProcessHost（ブラウザ側）で処理される。リソース要求やクリップボード操作はビュー特定の操作でないのでcontrolメッセージで行う。routedメッセージの例はビューに対する描画要求である。%0a%0aこれとは別の切り方はどちらからどちらへ送られるかで分ける場合。ドキュメントフレーム関連のメッセージがブラウザから送られれば、Frameメッセージと呼ばれる。なぜならそれはRenderFrameへ送られるから。逆の場合はFrameHostメッセージと呼ばれる。[[https://code.google.com/p/chromium/codesearch#chromium/src/content/common/frame_messages.h|frame_messages.h]]を見れば２つのセクションがあり、FrameとFrameHostで分けられている。%0a%0aビューやプラグインでも同様にView,ViewHostそしてPluginProcess,PluginProcessHostとなる。%0a%0a!メッセージの宣言%0aマクロが使われる。レンダラからブラウザへのroutedメッセージで引数にURLとintがある場合、以下のようになる。%0a[= IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int) =]%0a%0a%0a
time=1502937952
author:1502937952=
diff:1502937952:1502860434:=1,2d0%0a%3c https://www.chromium.org/developers/design-documents/inter-process-communication%0a%3c %0a28a27%0a> [[https://www.chromium.org/developers/design-documents/inter-process-communication|オリジナル]]%0a\ No newline at end of file%0a
host:1502937952=192.168.0.2
author:1502860434=
diff:1502860434:1502860434:=1,27d0%0a%3c !!全体像%0a%3c Chromiumは[[マルチプロセスアーキテクチャ]]で多くのプロセスもち、それぞれが通信する。基本的に名前付きパイプを使う。LinuxやOS Xではsocketpair()を使う。通信は非同期でおこわなれる。%0a%3c %0a%3c 安全はIPC端点を書くには[[IPCの安全性情報]]を参照。%0a%3c %0a%3c !!ブラウザ内でのIPC%0a%3c ブラウザとレンダラの通信は分離されたIOスレッドで行う。メッセージはChannelProxyを通じて送受信される。利点としては重たくなるリソース要求（ウェブページなど）がIOスレッドで行われUIがブロックしなくなること。RenderProcessHostによりChannelProxy::MessageFilterがインストールされ、このフィルターはIOで動き、リソース要求を横取りし、それをリソースディスパッチャーへ転送する。詳しくは[[マルチプロセスリソースローディング]]を参照。%0a%3c %0a%3c !!レンダラでのIPC%0a%3c それぞれのレンダラもメッセージを処理するスレッドを持つ（ここの場合はメインスレッド）。レンダリングや他の処理は別スレッドで行う。ほとんどのメッセージはブラウザから送られ、メインスレッドを通じてWebKitに到達する、逆も真。さらに同期通信を行うスレッドもある。%0a%3c %0a%3c !メッセージ%0a%3c !!メッセージの種類%0a%3c 大きく"routed"と"control"の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスはMessageRouterオブジェクトを持ち、それを登録する。%0a%3c %0a%3c 例えばレンダリング中、controlメッセージは特定のビュー対象ではなく、RenderProcess（レンダラ側）やRenderProcessHost（ブラウザ側）で処理される。リソース要求やクリップボード操作はビュー特定の操作でないのでcontrolメッセージで行う。routedメッセージの例はビューに対する描画要求である。%0a%3c %0a%3c これとは別の切り方はどちらからどちらへ送られるかで分ける場合。ドキュメントフレーム関連のメッセージがブラウザから送られれば、Frameメッセージと呼ばれる。なぜならそれはRenderFrameへ送られるから。逆の場合はFrameHostメッセージと呼ばれる。[[https://code.google.com/p/chromium/codesearch#chromium/src/content/common/frame_messages.h|frame_messages.h]]を見れば２つのセクションがあり、FrameとFrameHostで分けられている。%0a%3c %0a%3c ビューやプラグインでも同様にView,ViewHostそしてPluginProcess,PluginProcessHostとなる。%0a%3c %0a%3c !メッセージの宣言%0a%3c マクロが使われる。レンダラからブラウザへのroutedメッセージで引数にURLとintがある場合、以下のようになる。%0a%3c [= IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int) =]%0a%3c %0a%3c %0a%3c [[https://www.chromium.org/developers/design-documents/inter-process-communication|オリジナル]]%0a\ No newline at end of file%0a
host:1502860434=192.168.0.2
