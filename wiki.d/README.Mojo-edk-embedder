version=pmwiki-2.2.102 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1530639511
host=192.168.3.2
name=README.Mojo-edk-embedder
rev=8
targets=
text=!Mojo Embedder Development Kit (EDK)%0a%0aこの文書はMojoドキュメント化のサブセット%0a%0a!概観%0aMojoEDKは（バイナリ不安定な）APIで、これを使うとプロセス間での通信ができる。%0a%0a'''//mojo/edk/embedder'''にあるAPIサーフェスを使うには（混乱をもたらすようだが）GNターゲットの'''//mojo/edk/system'''の直接依存が必要になる。それにもかかわらず、'''mojo/edi/system'''にあるヘッダを直接参照すべきではない。ここにあるのはEDK内部の詳細であるから。%0a%0a'''注意：'''あなたが新しいバイナリのエントリポイントを作り込むのでない限り（例えばmain()をもつ新しい実行形式をつくる）、EDK APIについて何も知っている必要はない。Chromeレポで定義されるほとんどのプロセスは、すでにEDKを初期化しており、Mojoの他の公開APIは"即座に動く"。%0a%0a!基本的初期化%0aプロセスでMojoを使うには、'''mojo::edk::Init'''を一回だけ呼ぶ。%0a=cpp [=%0a#include "mojo/edk/embedder/embedder.h"%0a%0aint main(int argc, char** argv) {%0a  mojo::edk::Init();%0a%0a  // ここから、メッセージパイプの作成やメッセージの書き込みなどができる。%0a%0a  return 0;%0a}%0a=]%0a%0aIPCサポートがないとほとんど使えないので、次にこれを初期化する。%0a%0a!IPC初期化%0aバックグランドで動く'''TaskRunner'''が必要で、それがIOを監視する。%0a%0a以下がIPCのためのバックグランドスレッド作成とそれを使うMojoのコードである。Chromiumではすでに存在するブラウザプロセス内のあるいはコンテント子プロセス内の''IOスレッド''を利用する。%0a%0a=cpp [=%0a#include "base/threading/thread.h"%0a#include "mojo/edk/embedder/embedder.h"%0a#include "mojo/edk/embedder/scoped_ipc_support.h"%0a%0aint main(int argc, char** argv) {%0a  mojo::edk::Init();%0a%0a  base::Thread ipc_thread("ipc!");%0a  ipc_thread.StartWithOptions(%0a          base::Thread::Options(base::MessageLoop::TYPE_IO, 0));%0a%0a  // このオプジェクトが存在する間、IPC接続に関連するすべてのEDK APIを使うことができる。%0a  // プロセス境界にまたがるメッセージパイプも機能し続ける。%0a  mojo::edk::ScopedIPCSupport ipc_support(%0a      ipc_thread.task_runner(),%0a      mojo::edk::ScopedIPCSupport::ShutdownPolicy::CLEAN);%0a%0a  return 0;%0a}%0a=]%0aこれでプロセスはMojoIPCに対しての完全な準備ができた。%0a%0aChromiumのすべてのプロセスではこのセットアップをスタートアップの初期に行う。%0a%0a!２つのプロセスを接続%0aMojoIPCの準備ができたら、他のプロセスを起動してそのプロセスもMojoIPCの準備をしないとならない。そのためのコードを記述する。%0a%0a歴史的理由により、接続されるプロセスを呼ぶためにいくつかのAPIの用語が''Parent''や''Child''になっているがこの関係はOSのプロセス階層とは完全に直角(orthogonal)である。なのでこれらAPIはそのようなOS階層に制約されない。%0a%0aMojo requires you to bring your own OS pipe to the party, and it will do the rest. It also provides a convenient mechanism for creating such pipes, known as a PlatformChannelPair.%0a%0aYou provide one end of this pipe to the EDK in the local process via OutgoingBrokerClientInvitation - which can also be used to create cross- process message pipes (see the next section) - and you're responsible for getting the other end into the remote process.%0a%0a=cpp [=%0a#include "base/process/process_handle.h"%0a#include "base/threading/thread.h"%0a#include "mojo/edk/embedder/embedder.h"%0a#include "mojo/edk/embedder/outgoing_broker_client_invitation.h"%0a#include "mojo/edk/embedder/platform_channel_pair.h"%0a#include "mojo/edk/embedder/scoped_ipc_support.h"%0a%0a// You write this. It launches a new process, passing the pipe handle%0a// encapsulated by |channel| by any means possible (e.g. on Windows or POSIX%0a// you may inhert the file descriptor/HANDLE at launch and pass a commandline%0a// argument to indicate its numeric value). Returns the handle of the new%0a// process.%0abase::ProcessHandle LaunchCoolChildProcess(%0a    mojo::edk::ScopedPlatformHandle channel);%0a%0aint main(int argc, char** argv) {%0a  mojo::edk::Init();%0a%0a  base::Thread ipc_thread("ipc!");%0a  ipc_thread.StartWithOptions(%0a      base::Thread::Options(base::MessageLoop::TYPE_IO, 0));%0a%0a  mojo::edk::ScopedIPCSupport ipc_support(%0a      ipc_thread.task_runner(),%0a      mojo::edk::ScopedIPCSupport::ShutdownPolicy::CLEAN);%0a%0a  // This is essentially always an OS pipe (domain socket pair, Windows named%0a  // pipe, etc.)%0a  mojo::edk::PlatformChannelPair channel;%0a%0a  // This is a scoper which encapsulates the intent to connect to another%0a  // process. It exists because process connection is inherently asynchronous,%0a  // things may go wrong, and the lifetime of any associated resources is bound%0a  // by the lifetime of this object regardless of success or failure.%0a  mojo::edk::OutgoingBrokerClientInvitation invitation;%0a%0a  base::ProcessHandle child_handle =%0a      LaunchCoolChildProcess(channel.PassClientHandle());%0a%0a  // At this point it's safe for |child| to go out of scope and nothing will%0a  // break.%0a  child.Connect(child_handle, channel.PassServerHandle());%0a%0a  return 0;%0a}%0a=]%0aThe launched process code uses IncomingBrokerClientInvitation to get connected, and might look something like:%0a%0a=cpp [=%0a#include "base/threading/thread.h"%0a#include "mojo/edk/embedder/embedder.h"%0a#include "mojo/edk/embedder/scoped_ipc_support.h"%0a%0a// You write this. It acquires the ScopedPlatformHandle that was passed by%0a// whomever launched this process (i.e. LaunchCoolChildProcess above).%0amojo::edk::ScopedPlatformHandle GetChannelHandle();%0a%0aint main(int argc, char** argv) {%0a  mojo::edk::Init();%0a%0a  base::Thread ipc_thread("ipc!");%0a  ipc_thread.StartWithOptions(%0a      base::Thread::Options(base::MessageLoop::TYPE_IO, 0));%0a%0a  mojo::edk::ScopedIPCSupport ipc_support(%0a      ipc_thread.task_runner(),%0a      mojo::edk::ScopedIPCSupport::ShutdownPolicy::CLEAN);%0a%0a  mojo::edk::IncomingBrokerClientInvitation::Accept(GetChannelHandle());%0a%0a  return 0;%0a}%0a=]%0aNow you have IPC initialized between two processes. For some practical examples of how this is done, you can dig into the various multiprocess tests in the mojo_system_unittests test suite.%0a%0a!Bootstrapping Cross-Process Message Pipes%0aHaving internal Mojo IPC support initialized is pretty useless if you don't have any message pipes spanning the process boundary. Fortunately, this is made trivial by the EDK: OutgoingBrokerClientInvitation has an AttachMessagePipe method which synthesizes a new solitary message pipe endpoint for your immediate use, and attaches the other end to the invitation such that it can later be extracted by name by the invitee from the IncomingBrokerClientInvitation.%0a%0aWe can modify our existing sample code as follows:%0a%0a=cpp [=%0a#include "base/command_line.h"%0a#include "base/process/process_handle.h"%0a#include "base/threading/thread.h"%0a#include "mojo/edk/embedder/embedder.h"%0a#include "mojo/edk/embedder/outgoing_broker_client_invitation.h"%0a#include "mojo/edk/embedder/platform_channel_pair.h"%0a#include "mojo/edk/embedder/scoped_ipc_support.h"%0a#include "mojo/public/cpp/system/message_pipe.h"%0a#include "local/foo.mojom.h"  // You provide this%0a%0abase::ProcessHandle LaunchCoolChildProcess(%0a    const base::CommandLine& command_line,%0a    mojo::edk::ScopedPlatformHandle channel);%0a%0aint main(int argc, char** argv) {%0a  mojo::edk::Init();%0a%0a  base::Thread ipc_thread("ipc!");%0a  ipc_thread.StartWithOptions(%0a      base::Thread::Options(base::MessageLoop::TYPE_IO, 0));%0a%0a  mojo::edk::ScopedIPCSupport ipc_support(%0a      ipc_thread.task_runner(),%0a      mojo::edk::ScopedIPCSupport::ShutdownPolicy::CLEAN);%0a%0a  mojo::edk::PlatformChannelPair channel;%0a%0a  mojo::edk::OutgoingBrokerClientInvitation invitation;%0a%0a  // Create a new message pipe with one end being retrievable in the new%0a  // process. Note that the name chosen for the attachment is arbitrary and%0a  // scoped to this invitation.%0a  mojo::ScopedMessagePipeHandle my_pipe =%0a      invitation.AttachMessagePipe("pretty_cool_pipe");%0a%0a  base::ProcessHandle child_handle =%0a      LaunchCoolChildProcess(channel.PassClientHandle());%0a  invitation.Send(%0a      child_handle,%0a      mojo::edk::ConnectionParams(mojo::edk::TransportProtocol::kLegacy,%0a                                  channel.PassServerHandle()));%0a%0a  // We can start using our end of the pipe immediately. Here we assume the%0a  // other end will eventually be bound to a local::mojom::Foo implementation,%0a  // so we can start making calls on that interface.%0a  //%0a  // Note that this could even be done before the child process is launched and%0a  // it would still work as expected.%0a  local::mojom::FooPtr foo;%0a  foo.Bind(local::mojom::FooPtrInfo(std::move(my_pipe), 0));%0a  foo->DoSomeStuff(42);%0a%0a  return 0;%0a}%0a=]%0aand for the launched process:%0a%0a=cpp [=%0a#include "base/run_loop/run_loop.h"%0a#include "base/threading/thread.h"%0a#include "mojo/edk/embedder/embedder.h"%0a#include "mojo/edk/embedder/incoming_broker_client_invitation.h"%0a#include "mojo/edk/embedder/scoped_ipc_support.h"%0a#include "mojo/public/cpp/bindings/binding.h"%0a#include "mojo/public/cpp/system/message_pipe.h"%0a#include "local/foo.mojom.h"  // You provide this%0a%0amojo::edk::ScopedPlatformHandle GetChannelHandle();%0a%0aclass FooImpl : local::mojom::Foo {%0a public:%0a  explicit FooImpl(local::mojom::FooRequest request)%0a      : binding_(this, std::move(request)) {}%0a  ~FooImpl() override {}%0a%0a  void DoSomeStuff(int32_t n) override {%0a    // ...%0a  }%0a%0a private:%0a  mojo::Binding%3clocal::mojom::Foo> binding_;%0a%0a  DISALLOW_COPY_AND_ASSIGN(FooImpl);%0a};%0a%0aint main(int argc, char** argv) {%0a  mojo::edk::Init();%0a%0a  base::Thread ipc_thread("ipc!");%0a  ipc_thread.StartWithOptions(%0a      base::Thread::Options(base::MessageLoop::TYPE_IO));%0a%0a  mojo::edk::ScopedIPCSupport ipc_support(%0a      ipc_thread.task_runner(),%0a      mojo::edk::ScopedIPCSupport::ShutdownPolicy::CLEAN);%0a%0a  auto invitation = mojo::edk::IncomingBrokerClientInvitation::Accept(%0a      mojo::edk::ConnectionParams(mojo::edk::TransportProtocol::kLegacy,%0a                                  GetChannelHandle()));%0a%0a  mojo::ScopedMessagePipeHandle my_pipe =%0a      invitation->ExtractMessagePipe("pretty_cool_pipe");%0a%0a  FooImpl impl(local::mojom::FooRequest(std::move(my_pipe)));%0a%0a  // Run forever!%0a  base::RunLoop().Run();%0a%0a  return 0;%0a}%0a=]%0aNote that the above samples assume an interface definition in //local/test.mojom which would look something like:%0a%0a=cpp [=%0amodule local.mojom;%0a%0ainterface Foo {%0a  DoSomeStuff(int32 n);%0a};%0a=]%0a%0aOnce you've bootstrapped your process connection with a real mojom interface, you can avoid any further mucking around with EDK APIs or raw message pipe handles, as everything beyond this point - including the passing of other interface pipes - can be handled eloquently using public bindings APIs.%0a%0a!Setting System Properties%0a%0aThe public Mojo C System API exposes a MojoGetProperty function for querying global, embedder-defined property values. These can be set by calling:%0a%0a=cpp [=%0amojo::edk::SetProperty(MojoPropertyType type, const void* value)%0a=]%0a
time=1530647573
author:1530647573=
diff:1530647573:1530641411:=5c5%0a%3c !概観%0a---%0a> !外観%0a
host:1530647573=192.168.3.2
author:1530641411=
diff:1530641411:1530640602:=53,277d52%0a%3c =]%0a%3c これでプロセスはMojoIPCに対しての完全な準備ができた。%0a%3c %0a%3c Chromiumのすべてのプロセスではこのセットアップをスタートアップの初期に行う。%0a%3c %0a%3c !２つのプロセスを接続%0a%3c MojoIPCの準備ができたら、他のプロセスを起動してそのプロセスもMojoIPCの準備をしないとならない。そのためのコードを記述する。%0a%3c %0a%3c 歴史的理由により、接続されるプロセスを呼ぶためにいくつかのAPIの用語が''Parent''や''Child''になっているがこの関係はOSのプロセス階層とは完全に直角(orthogonal)である。なのでこれらAPIはそのようなOS階層に制約されない。%0a%3c %0a%3c Mojo requires you to bring your own OS pipe to the party, and it will do the rest. It also provides a convenient mechanism for creating such pipes, known as a PlatformChannelPair.%0a%3c %0a%3c You provide one end of this pipe to the EDK in the local process via OutgoingBrokerClientInvitation - which can also be used to create cross- process message pipes (see the next section) - and you're responsible for getting the other end into the remote process.%0a%3c %0a%3c =cpp [=%0a%3c #include "base/process/process_handle.h"%0a%3c #include "base/threading/thread.h"%0a%3c #include "mojo/edk/embedder/embedder.h"%0a%3c #include "mojo/edk/embedder/outgoing_broker_client_invitation.h"%0a%3c #include "mojo/edk/embedder/platform_channel_pair.h"%0a%3c #include "mojo/edk/embedder/scoped_ipc_support.h"%0a%3c %0a%3c // You write this. It launches a new process, passing the pipe handle%0a%3c // encapsulated by |channel| by any means possible (e.g. on Windows or POSIX%0a%3c // you may inhert the file descriptor/HANDLE at launch and pass a commandline%0a%3c // argument to indicate its numeric value). Returns the handle of the new%0a%3c // process.%0a%3c base::ProcessHandle LaunchCoolChildProcess(%0a%3c     mojo::edk::ScopedPlatformHandle channel);%0a%3c %0a%3c int main(int argc, char** argv) {%0a%3c   mojo::edk::Init();%0a%3c %0a%3c   base::Thread ipc_thread("ipc!");%0a%3c   ipc_thread.StartWithOptions(%0a%3c       base::Thread::Options(base::MessageLoop::TYPE_IO, 0));%0a%3c %0a%3c   mojo::edk::ScopedIPCSupport ipc_support(%0a%3c       ipc_thread.task_runner(),%0a%3c       mojo::edk::ScopedIPCSupport::ShutdownPolicy::CLEAN);%0a%3c %0a%3c   // This is essentially always an OS pipe (domain socket pair, Windows named%0a%3c   // pipe, etc.)%0a%3c   mojo::edk::PlatformChannelPair channel;%0a%3c %0a%3c   // This is a scoper which encapsulates the intent to connect to another%0a%3c   // process. It exists because process connection is inherently asynchronous,%0a%3c   // things may go wrong, and the lifetime of any associated resources is bound%0a%3c   // by the lifetime of this object regardless of success or failure.%0a%3c   mojo::edk::OutgoingBrokerClientInvitation invitation;%0a%3c %0a%3c   base::ProcessHandle child_handle =%0a%3c       LaunchCoolChildProcess(channel.PassClientHandle());%0a%3c %0a%3c   // At this point it's safe for |child| to go out of scope and nothing will%0a%3c   // break.%0a%3c   child.Connect(child_handle, channel.PassServerHandle());%0a%3c %0a%3c   return 0;%0a%3c }%0a%3c =]%0a%3c The launched process code uses IncomingBrokerClientInvitation to get connected, and might look something like:%0a%3c %0a%3c =cpp [=%0a%3c #include "base/threading/thread.h"%0a%3c #include "mojo/edk/embedder/embedder.h"%0a%3c #include "mojo/edk/embedder/scoped_ipc_support.h"%0a%3c %0a%3c // You write this. It acquires the ScopedPlatformHandle that was passed by%0a%3c // whomever launched this process (i.e. LaunchCoolChildProcess above).%0a%3c mojo::edk::ScopedPlatformHandle GetChannelHandle();%0a%3c %0a%3c int main(int argc, char** argv) {%0a%3c   mojo::edk::Init();%0a%3c %0a%3c   base::Thread ipc_thread("ipc!");%0a%3c   ipc_thread.StartWithOptions(%0a%3c       base::Thread::Options(base::MessageLoop::TYPE_IO, 0));%0a%3c %0a%3c   mojo::edk::ScopedIPCSupport ipc_support(%0a%3c       ipc_thread.task_runner(),%0a%3c       mojo::edk::ScopedIPCSupport::ShutdownPolicy::CLEAN);%0a%3c %0a%3c   mojo::edk::IncomingBrokerClientInvitation::Accept(GetChannelHandle());%0a%3c %0a%3c   return 0;%0a%3c }%0a%3c =]%0a%3c Now you have IPC initialized between two processes. For some practical examples of how this is done, you can dig into the various multiprocess tests in the mojo_system_unittests test suite.%0a%3c %0a%3c !Bootstrapping Cross-Process Message Pipes%0a%3c Having internal Mojo IPC support initialized is pretty useless if you don't have any message pipes spanning the process boundary. Fortunately, this is made trivial by the EDK: OutgoingBrokerClientInvitation has an AttachMessagePipe method which synthesizes a new solitary message pipe endpoint for your immediate use, and attaches the other end to the invitation such that it can later be extracted by name by the invitee from the IncomingBrokerClientInvitation.%0a%3c %0a%3c We can modify our existing sample code as follows:%0a%3c %0a%3c =cpp [=%0a%3c #include "base/command_line.h"%0a%3c #include "base/process/process_handle.h"%0a%3c #include "base/threading/thread.h"%0a%3c #include "mojo/edk/embedder/embedder.h"%0a%3c #include "mojo/edk/embedder/outgoing_broker_client_invitation.h"%0a%3c #include "mojo/edk/embedder/platform_channel_pair.h"%0a%3c #include "mojo/edk/embedder/scoped_ipc_support.h"%0a%3c #include "mojo/public/cpp/system/message_pipe.h"%0a%3c #include "local/foo.mojom.h"  // You provide this%0a%3c %0a%3c base::ProcessHandle LaunchCoolChildProcess(%0a%3c     const base::CommandLine& command_line,%0a%3c     mojo::edk::ScopedPlatformHandle channel);%0a%3c %0a%3c int main(int argc, char** argv) {%0a%3c   mojo::edk::Init();%0a%3c %0a%3c   base::Thread ipc_thread("ipc!");%0a%3c   ipc_thread.StartWithOptions(%0a%3c       base::Thread::Options(base::MessageLoop::TYPE_IO, 0));%0a%3c %0a%3c   mojo::edk::ScopedIPCSupport ipc_support(%0a%3c       ipc_thread.task_runner(),%0a%3c       mojo::edk::ScopedIPCSupport::ShutdownPolicy::CLEAN);%0a%3c %0a%3c   mojo::edk::PlatformChannelPair channel;%0a%3c %0a%3c   mojo::edk::OutgoingBrokerClientInvitation invitation;%0a%3c %0a%3c   // Create a new message pipe with one end being retrievable in the new%0a%3c   // process. Note that the name chosen for the attachment is arbitrary and%0a%3c   // scoped to this invitation.%0a%3c   mojo::ScopedMessagePipeHandle my_pipe =%0a%3c       invitation.AttachMessagePipe("pretty_cool_pipe");%0a%3c %0a%3c   base::ProcessHandle child_handle =%0a%3c       LaunchCoolChildProcess(channel.PassClientHandle());%0a%3c   invitation.Send(%0a%3c       child_handle,%0a%3c       mojo::edk::ConnectionParams(mojo::edk::TransportProtocol::kLegacy,%0a%3c                                   channel.PassServerHandle()));%0a%3c %0a%3c   // We can start using our end of the pipe immediately. Here we assume the%0a%3c   // other end will eventually be bound to a local::mojom::Foo implementation,%0a%3c   // so we can start making calls on that interface.%0a%3c   //%0a%3c   // Note that this could even be done before the child process is launched and%0a%3c   // it would still work as expected.%0a%3c   local::mojom::FooPtr foo;%0a%3c   foo.Bind(local::mojom::FooPtrInfo(std::move(my_pipe), 0));%0a%3c   foo->DoSomeStuff(42);%0a%3c %0a%3c   return 0;%0a%3c }%0a%3c =]%0a%3c and for the launched process:%0a%3c %0a%3c =cpp [=%0a%3c #include "base/run_loop/run_loop.h"%0a%3c #include "base/threading/thread.h"%0a%3c #include "mojo/edk/embedder/embedder.h"%0a%3c #include "mojo/edk/embedder/incoming_broker_client_invitation.h"%0a%3c #include "mojo/edk/embedder/scoped_ipc_support.h"%0a%3c #include "mojo/public/cpp/bindings/binding.h"%0a%3c #include "mojo/public/cpp/system/message_pipe.h"%0a%3c #include "local/foo.mojom.h"  // You provide this%0a%3c %0a%3c mojo::edk::ScopedPlatformHandle GetChannelHandle();%0a%3c %0a%3c class FooImpl : local::mojom::Foo {%0a%3c  public:%0a%3c   explicit FooImpl(local::mojom::FooRequest request)%0a%3c       : binding_(this, std::move(request)) {}%0a%3c   ~FooImpl() override {}%0a%3c %0a%3c   void DoSomeStuff(int32_t n) override {%0a%3c     // ...%0a%3c   }%0a%3c %0a%3c  private:%0a%3c   mojo::Binding%3clocal::mojom::Foo> binding_;%0a%3c %0a%3c   DISALLOW_COPY_AND_ASSIGN(FooImpl);%0a%3c };%0a%3c %0a%3c int main(int argc, char** argv) {%0a%3c   mojo::edk::Init();%0a%3c %0a%3c   base::Thread ipc_thread("ipc!");%0a%3c   ipc_thread.StartWithOptions(%0a%3c       base::Thread::Options(base::MessageLoop::TYPE_IO));%0a%3c %0a%3c   mojo::edk::ScopedIPCSupport ipc_support(%0a%3c       ipc_thread.task_runner(),%0a%3c       mojo::edk::ScopedIPCSupport::ShutdownPolicy::CLEAN);%0a%3c %0a%3c   auto invitation = mojo::edk::IncomingBrokerClientInvitation::Accept(%0a%3c       mojo::edk::ConnectionParams(mojo::edk::TransportProtocol::kLegacy,%0a%3c                                   GetChannelHandle()));%0a%3c %0a%3c   mojo::ScopedMessagePipeHandle my_pipe =%0a%3c       invitation->ExtractMessagePipe("pretty_cool_pipe");%0a%3c %0a%3c   FooImpl impl(local::mojom::FooRequest(std::move(my_pipe)));%0a%3c %0a%3c   // Run forever!%0a%3c   base::RunLoop().Run();%0a%3c %0a%3c   return 0;%0a%3c }%0a%3c =]%0a%3c Note that the above samples assume an interface definition in //local/test.mojom which would look something like:%0a%3c %0a%3c =cpp [=%0a%3c module local.mojom;%0a%3c %0a%3c interface Foo {%0a%3c   DoSomeStuff(int32 n);%0a%3c };%0a%3c =]%0a%3c %0a%3c Once you've bootstrapped your process connection with a real mojom interface, you can avoid any further mucking around with EDK APIs or raw message pipe handles, as everything beyond this point - including the passing of other interface pipes - can be handled eloquently using public bindings APIs.%0a%3c %0a%3c !Setting System Properties%0a%3c %0a%3c The public Mojo C System API exposes a MojoGetProperty function for querying global, embedder-defined property values. These can be set by calling:%0a%3c %0a%3c =cpp [=%0a%3c mojo::edk::SetProperty(MojoPropertyType type, const void* value)%0a
host:1530641411=192.168.3.2
author:1530640602=
diff:1530640602:1530640393:=43,46c43,47%0a%3c           base::Thread::Options(base::MessageLoop::TYPE_IO, 0));%0a%3c %0a%3c   // このオプジェクトが存在する間、IPC接続に関連するすべてのEDK APIを使うことができる。%0a%3c   // プロセス境界にまたがるメッセージパイプも機能し続ける。%0a---%0a>       base::Thread::Options(base::MessageLoop::TYPE_IO, 0));%0a> %0a>   // As long as this object is alive, all EDK API surface relevant to IPC%0a>   // connections is usable and message pipes which span a process boundary will%0a>   // continue to function.%0a
host:1530640602=192.168.3.2
author:1530640393=
diff:1530640393:1530640030:=21d20%0a%3c %0a24,54c23%0a%3c =]%0a%3c %0a%3c IPCサポートがないとほとんど使えないので、次にこれを初期化する。%0a%3c %0a%3c !IPC初期化%0a%3c バックグランドで動く'''TaskRunner'''が必要で、それがIOを監視する。%0a%3c %0a%3c 以下がIPCのためのバックグランドスレッド作成とそれを使うMojoのコードである。Chromiumではすでに存在するブラウザプロセス内のあるいはコンテント子プロセス内の''IOスレッド''を利用する。%0a%3c %0a%3c =cpp [=%0a%3c #include "base/threading/thread.h"%0a%3c #include "mojo/edk/embedder/embedder.h"%0a%3c #include "mojo/edk/embedder/scoped_ipc_support.h"%0a%3c %0a%3c int main(int argc, char** argv) {%0a%3c   mojo::edk::Init();%0a%3c %0a%3c   base::Thread ipc_thread("ipc!");%0a%3c   ipc_thread.StartWithOptions(%0a%3c       base::Thread::Options(base::MessageLoop::TYPE_IO, 0));%0a%3c %0a%3c   // As long as this object is alive, all EDK API surface relevant to IPC%0a%3c   // connections is usable and message pipes which span a process boundary will%0a%3c   // continue to function.%0a%3c   mojo::edk::ScopedIPCSupport ipc_support(%0a%3c       ipc_thread.task_runner(),%0a%3c       mojo::edk::ScopedIPCSupport::ShutdownPolicy::CLEAN);%0a%3c %0a%3c   return 0;%0a%3c }%0a%3c =]%0a---%0a> =]%0a\ No newline at end of file%0a
host:1530640393=192.168.3.2
author:1530640030=
diff:1530640030:1530639915:=12,23d11%0a%3c !基本的初期化%0a%3c プロセスでMojoを使うには、'''mojo::edk::Init'''を一回だけ呼ぶ。%0a%3c =cpp [=%0a%3c #include "mojo/edk/embedder/embedder.h"%0a%3c %0a%3c int main(int argc, char** argv) {%0a%3c   mojo::edk::Init();%0a%3c %0a%3c   // ここから、メッセージパイプの作成やメッセージの書き込みなどができる。%0a%3c   return 0;%0a%3c }%0a%3c =]%0a\ No newline at end of file%0a
host:1530640030=192.168.3.2
author:1530639915=
diff:1530639915:1530639538:=8,11c8%0a%3c '''//mojo/edk/embedder'''にあるAPIサーフェスを使うには（混乱をもたらすようだが）GNターゲットの'''//mojo/edk/system'''の直接依存が必要になる。それにもかかわらず、'''mojo/edi/system'''にあるヘッダを直接参照すべきではない。ここにあるのはEDK内部の詳細であるから。%0a%3c %0a%3c '''注意：'''あなたが新しいバイナリのエントリポイントを作り込むのでない限り（例えばmain()をもつ新しい実行形式をつくる）、EDK APIについて何も知っている必要はない。Chromeレポで定義されるほとんどのプロセスは、すでにEDKを初期化しており、Mojoの他の公開APIは"即座に動く"。%0a%3c %0a---%0a> '''//mojo/edk/embedder'''にあるAPIサーフェスを使うには（混乱をもたらすようだが）GNターゲットの'''//mojo/edk/system'''の直接依存が必要になる。それにもかかわらず、'''mojo/edi/system'''にあるヘッダを直接参照すべきではない。ここにあるのはEDK内部の詳細であるから。%0a\ No newline at end of file%0a
host:1530639915=192.168.3.2
author:1530639538=
diff:1530639538:1530639511:=8c8%0a%3c '''//mojo/edk/embedder'''にあるAPIサーフェスを使うには（混乱をもたらすようだが）GNターゲットの'''//mojo/edk/system'''の直接依存が必要になる。それにもかかわらず、'''mojo/edi/system'''にあるヘッダを直接参照すべきではない。ここにあるのはEDK内部の詳細であるから。%0a\ No newline at end of file%0a---%0a> '''//mojo/edk/embedder'''にあるAPIサーフェスを使うには（混乱をもたらすようだが）GNターゲットの//mojo/edk/systemの直接依存が必要になる。それにもかかわらず、mojo/edi/systemにあるヘッダを直接参照すべきではない。ここにあるのはEDK内部の詳細であるから。%0a\ No newline at end of file%0a
host:1530639538=192.168.3.2
author:1530639511=
diff:1530639511:1530639511:=1,8d0%0a%3c !Mojo Embedder Development Kit (EDK)%0a%3c %0a%3c この文書はMojoドキュメント化のサブセット%0a%3c %0a%3c !外観%0a%3c MojoEDKは（バイナリ不安定な）APIで、これを使うとプロセス間での通信ができる。%0a%3c %0a%3c '''//mojo/edk/embedder'''にあるAPIサーフェスを使うには（混乱をもたらすようだが）GNターゲットの//mojo/edk/systemの直接依存が必要になる。それにもかかわらず、mojo/edi/systemにあるヘッダを直接参照すべきではない。ここにあるのはEDK内部の詳細であるから。%0a\ No newline at end of file%0a
host:1530639511=192.168.3.2
