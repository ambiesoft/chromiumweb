version=pmwiki-2.2.107 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1530947676
host=192.168.3.2
name=Masterdoc.コールバックとバインド
rev=4
targets=
text=https://chromium.googlesource.com/chromium/src/+/master/docs/callback.md%0a%0a!イントロ%0a%0aテンプレートの'''Callback%3c>'''クラスは一般化された関数オブジェクトである。'''Bind()'''と一緒にタイプセーフなメソッドを提供し、関数の部分的適用を実演する。（performing partial application of functions）%0a%0a%0a部分的適用（またはカリー化）は、関数の引数のサブセットを束縛するプロセスで、より引数の少ない関数を作成する。これにより遅延実行のユニットを持ちまわることができる、多言語のレキシカルクロージャようなもの。Chromiumでは異なるMessageLoopにおいてタスクをスケジュールするのにつかわれる。%0a%0a%0a拘束なしの入力パラメタコールバック（'''Callback%3cvoid()>'''）は'''クロージャ'''と呼ばれる。これは多言語で言うところのクロージャと同じでは'''ない'''。囲っている環境の参照を保持しない。%0a%0a!OnceCallback%3c>とRepeatingCallback%3c>%0a'''OnceCallback%3c>'''と'''RepeatingCallback%3c>'''は現在開発中の次世代コールバッククラスである。%0a%0a%0a'''OnceCallback%3c>'''は'''BindOnce()'''により作成される。これはコールバックの一種で、ムーブオンリータイプあり、一度しか実行されない。これは内部ストレージから拘束パラメータを拘束関数へムーブする、ムーブ可能なタイプで使いやすい。これは好ましいコールバックタイプである。ライフタイムが鮮明になり、スレッド間で渡されるコールバックがいつ破壊されたのか理解しやすくする。%0a%0a'''RepeatingCallback()'''は'''BindRepeating()'''で作成される。これはコールバックの一種で、コピー可能で何度でも実行できる。内部の参照カウンタを使うのでコピーは軽い。しかし、所有は共有されるので、コールバックや拘束状態がいつ破壊されのか推論しにくい、特にスレッド間で渡されるときにはそうだ。%0a%0aレガシーな'''Callback%3c>'''は現在では'''RepeatingCallback%3c>'''にエリアスされている。新規コードでは可能な限り'''OnceCallback%3c>'''を用いること。移行完了後はエリアスは消去され、'''OnceCallback%3c>'''が'''Callback%3c>'''にリネームされる。これが好ましいことを強調するため。%0a%0a'''RepeatingCallback%3c>'''は'''OnceCallback%3c>'''に暗黙変換が可能。%0a%0a!メモリ管理とデータ渡し%0a所有権が移転されるなら値渡しでCallbackオブジェクトを渡す、そうでないならコンスト参照で渡す。%0a%0a=cpp [=%0a// |Foo| just refers to |cb| but doesn't store it nor consume it.%0abool Foo(const OnceCallback%3cvoid(int)>& cb) {%0a  return cb.is_null();%0a}%0a%0a// |Bar| takes the ownership of |cb| and stores |cb| into |g_cb|.%0aOnceCallback%3cvoid(int)> g_cb;%0avoid Bar(OnceCallback%3cvoid(int)> cb) {%0a  g_cb = std::move(cb);%0a}%0a%0a// |Baz| takes the ownership of |cb| and consumes |cb| by Run().%0avoid Baz(OnceCallback%3cvoid(int)> cb) {%0a  std::move(cb).Run(42);%0a}%0a%0a// |Qux| takes the ownership of |cb| and transfers ownership to PostTask(),%0a// which also takes the ownership of |cb|.%0avoid Qux(OnceCallback%3cvoid(int)> cb) {%0a  PostTask(FROM_HERE,%0a           base::BindOnce(std::move(cb), 42));%0a}%0a=]%0a'''Callback'''オブジェクトを関数パラメータに渡すとき、参照を保持する必要がないなら'''std::move()'''を使う。そうでないなら直接渡す。関数が排他的所有権を要求するならムーブで渡さないとコンパイルエラーになる。ムーブされた'''Callback'''はnullになることに注意すること。あたかも'''Reset()'''メソッドが呼ばれたようになり、'''is_null()'''はtrueを返す。%0a%0a!基本事項のクイックリファレンス%0a!!生の関数を拘束%0a=cpp [=%0aint Return5() { return 5; }%0aOnceCallback%3cint()> func_cb = BindOnce(&Return5);%0aLOG(INFO) %3c%3c std::move(func_cb).Run();  // Prints 5.%0a=]%0a%0a=cpp [=%0aint Return5() { return 5; }%0aRepeatingCallback%3cint()> func_cb = BindRepeating(&Return5);%0aLOG(INFO) %3c%3c func_cb.Run();  // Prints 5.%0a=]%0a%0a!!キャプチャなしのラムダを拘束%0a=cpp [=%0aCallback%3cint()> lambda_cb = Bind([] { return 4; });%0aLOG(INFO) %3c%3c lambda_cb.Run();  // Print 4.%0a%0aOnceCallback%3cint()> lambda_cb2 = BindOnce([] { return 3; });%0aLOG(INFO) %3c%3c std::move(lambda_cb2).Run();  // Print 3.%0a=]%0a%0a!!クラスメソッドを拘束%0abindへの最初の引数は呼び出すメンバ関数、二番目は呼び出すオブジェクト%0a=cpp [=%0aclass Ref : public RefCountedThreadSafe%3cRef> {%0a public:%0a  int Foo() { return 3; }%0a};%0ascoped_refptr%3cRef> ref = new Ref();%0aCallback%3cvoid()> ref_cb = Bind(&Ref::Foo, ref);%0aLOG(INFO) %3c%3c ref_cb.Run();  // Prints out 3.%0a=]%0aデフォルトではオブジェクトはRefCountedをサポートしたいとコンパイルエラーになる。スレッド間で渡すなら、RefCountedThreadSafeを使うこと！参照カウンタを使いたくないなら下の「メンバ関数拘束の詳細」を見ること。%0a%0a!!コールバックの実行%0aTODO
time=1530947769
author:1530947769=
diff:1530947769:1530947730:=5,7c5,7%0a%3c テンプレートの'''Callback%3c>'''クラスは一般化された関数オブジェクトである。'''Bind()'''と一緒にタイプセーフなメソッドを提供し、関数の部分的適用を実演する。（performing partial application of functions）%0a%3c %0a%3c %0a---%0a> テンプレートの'''Callback%3c>'''クラスは一般化された関数オブジェクトである。@@Bind()@@と一緒にタイプセーフなメソッドを提供し、関数の部分的適用を実演する。（performing partial application of functions）%0a> %0a> %0a11,12c11,12%0a%3c 拘束なしの入力パラメタコールバック（'''Callback%3cvoid()>'''）は'''クロージャ'''と呼ばれる。これは多言語で言うところのクロージャと同じでは'''ない'''。囲っている環境の参照を保持しない。%0a%3c %0a---%0a> 拘束なしの入力パラメタコールバック（@@Callback%3cvoid()>@@）は@@クロージャ@@と呼ばれる。これは多言語で言うところのクロージャと同じでは'''ない'''。囲っている環境の参照を保持しない。%0a> %0a14,24c14,24%0a%3c '''OnceCallback%3c>'''と'''RepeatingCallback%3c>'''は現在開発中の次世代コールバッククラスである。%0a%3c %0a%3c %0a%3c '''OnceCallback%3c>'''は'''BindOnce()'''により作成される。これはコールバックの一種で、ムーブオンリータイプあり、一度しか実行されない。これは内部ストレージから拘束パラメータを拘束関数へムーブする、ムーブ可能なタイプで使いやすい。これは好ましいコールバックタイプである。ライフタイムが鮮明になり、スレッド間で渡されるコールバックがいつ破壊されたのか理解しやすくする。%0a%3c %0a%3c '''RepeatingCallback()'''は'''BindRepeating()'''で作成される。これはコールバックの一種で、コピー可能で何度でも実行できる。内部の参照カウンタを使うのでコピーは軽い。しかし、所有は共有されるので、コールバックや拘束状態がいつ破壊されのか推論しにくい、特にスレッド間で渡されるときにはそうだ。%0a%3c %0a%3c レガシーな'''Callback%3c>'''は現在では'''RepeatingCallback%3c>'''にエリアスされている。新規コードでは可能な限り'''OnceCallback%3c>'''を用いること。移行完了後はエリアスは消去され、'''OnceCallback%3c>'''が'''Callback%3c>'''にリネームされる。これが好ましいことを強調するため。%0a%3c %0a%3c '''RepeatingCallback%3c>'''は'''OnceCallback%3c>'''に暗黙変換が可能。%0a%3c %0a---%0a> @@OnceCallback%3c>@@と@@RepeatingCallback%3c>@@は現在開発中の次世代コールバッククラスである。%0a> %0a> %0a> @@OnceCallback%3c>@@は@@BindOnce()@@により作成される。これはコールバックの一種で、ムーブオンリータイプあり、一度しか実行されない。これは内部ストレージから拘束パラメータを拘束関数へムーブする、ムーブ可能なタイプで使いやすい。これは好ましいコールバックタイプである。ライフタイムが鮮明になり、スレッド間で渡されるコールバックがいつ破壊されたのか理解しやすくする。%0a> %0a> @@RepeatingCallback()@@は@@BindRepeating()@@で作成される。これはコールバックの一種で、コピー可能で何度でも実行できる。内部の参照カウンタを使うのでコピーは軽い。しかし、所有は共有されるので、コールバックや拘束状態がいつ破壊されのか推論しにくい、特にスレッド間で渡されるときにはそうだ。%0a> %0a> レガシーな@@Callback%3c>@@は現在では@@RepeatingCallback%3c>@@にエリアスされている。新規コードでは可能な限り@@OnceCallback%3c>@@を用いること。移行完了後はエリアスは消去され、@@OnceCallback%3c>@@が@@Callback%3c>@@にリネームされる。これが好ましいことを強調するため。%0a> %0a> @@RepeatingCallback%3c>@@は@@OnceCallback%3c>@@に暗黙変換が可能。%0a> %0a52c52%0a%3c '''Callback'''オブジェクトを関数パラメータに渡すとき、参照を保持する必要がないなら'''std::move()'''を使う。そうでないなら直接渡す。関数が排他的所有権を要求するならムーブで渡さないとコンパイルエラーになる。ムーブされた'''Callback'''はnullになることに注意すること。あたかも'''Reset()'''メソッドが呼ばれたようになり、'''is_null()'''はtrueを返す。%0a---%0a> @@Callback@@オブジェクトを関数パラメータに渡すとき、参照を保持する必要がないなら@@std::move()@@を使う。そうでないなら直接渡す。関数が排他的所有権を要求するならムーブで渡さないとコンパイルエラーになる。ムーブされた@@Callback@@はnullになることに注意すること。あたかも@@Reset()@@メソッドが呼ばれたようになり、@@is_null()@@はtrueを返す。%0a
host:1530947769=192.168.3.2
author:1530947730=
diff:1530947730:1530947719:=5c5%0a%3c テンプレートの'''Callback%3c>'''クラスは一般化された関数オブジェクトである。@@Bind()@@と一緒にタイプセーフなメソッドを提供し、関数の部分的適用を実演する。（performing partial application of functions）%0a---%0a> テンプレートの@@Callback%3c>@@クラスは一般化された関数オブジェクトである。@@Bind()@@と一緒にタイプセーフなメソッドを提供し、関数の部分的適用を実演する。（performing partial application of functions）%0a
host:1530947730=192.168.3.2
author:1530947719=
diff:1530947719:1530947676:=1c1%0a%3c https://chromium.googlesource.com/chromium/src/+/master/docs/callback.md%0a---%0a> https://chromium.googlesource.com/chromium/src/+/lkcr/docs/callback.md%0a
host:1530947719=192.168.3.2
author:1530947676=
diff:1530947676:1530947676:=1,91d0%0a%3c https://chromium.googlesource.com/chromium/src/+/lkcr/docs/callback.md%0a%3c %0a%3c !イントロ%0a%3c %0a%3c テンプレートの@@Callback%3c>@@クラスは一般化された関数オブジェクトである。@@Bind()@@と一緒にタイプセーフなメソッドを提供し、関数の部分的適用を実演する。（performing partial application of functions）%0a%3c %0a%3c %0a%3c 部分的適用（またはカリー化）は、関数の引数のサブセットを束縛するプロセスで、より引数の少ない関数を作成する。これにより遅延実行のユニットを持ちまわることができる、多言語のレキシカルクロージャようなもの。Chromiumでは異なるMessageLoopにおいてタスクをスケジュールするのにつかわれる。%0a%3c %0a%3c %0a%3c 拘束なしの入力パラメタコールバック（@@Callback%3cvoid()>@@）は@@クロージャ@@と呼ばれる。これは多言語で言うところのクロージャと同じでは'''ない'''。囲っている環境の参照を保持しない。%0a%3c %0a%3c !OnceCallback%3c>とRepeatingCallback%3c>%0a%3c @@OnceCallback%3c>@@と@@RepeatingCallback%3c>@@は現在開発中の次世代コールバッククラスである。%0a%3c %0a%3c %0a%3c @@OnceCallback%3c>@@は@@BindOnce()@@により作成される。これはコールバックの一種で、ムーブオンリータイプあり、一度しか実行されない。これは内部ストレージから拘束パラメータを拘束関数へムーブする、ムーブ可能なタイプで使いやすい。これは好ましいコールバックタイプである。ライフタイムが鮮明になり、スレッド間で渡されるコールバックがいつ破壊されたのか理解しやすくする。%0a%3c %0a%3c @@RepeatingCallback()@@は@@BindRepeating()@@で作成される。これはコールバックの一種で、コピー可能で何度でも実行できる。内部の参照カウンタを使うのでコピーは軽い。しかし、所有は共有されるので、コールバックや拘束状態がいつ破壊されのか推論しにくい、特にスレッド間で渡されるときにはそうだ。%0a%3c %0a%3c レガシーな@@Callback%3c>@@は現在では@@RepeatingCallback%3c>@@にエリアスされている。新規コードでは可能な限り@@OnceCallback%3c>@@を用いること。移行完了後はエリアスは消去され、@@OnceCallback%3c>@@が@@Callback%3c>@@にリネームされる。これが好ましいことを強調するため。%0a%3c %0a%3c @@RepeatingCallback%3c>@@は@@OnceCallback%3c>@@に暗黙変換が可能。%0a%3c %0a%3c !メモリ管理とデータ渡し%0a%3c 所有権が移転されるなら値渡しでCallbackオブジェクトを渡す、そうでないならコンスト参照で渡す。%0a%3c %0a%3c =cpp [=%0a%3c // |Foo| just refers to |cb| but doesn't store it nor consume it.%0a%3c bool Foo(const OnceCallback%3cvoid(int)>& cb) {%0a%3c   return cb.is_null();%0a%3c }%0a%3c %0a%3c // |Bar| takes the ownership of |cb| and stores |cb| into |g_cb|.%0a%3c OnceCallback%3cvoid(int)> g_cb;%0a%3c void Bar(OnceCallback%3cvoid(int)> cb) {%0a%3c   g_cb = std::move(cb);%0a%3c }%0a%3c %0a%3c // |Baz| takes the ownership of |cb| and consumes |cb| by Run().%0a%3c void Baz(OnceCallback%3cvoid(int)> cb) {%0a%3c   std::move(cb).Run(42);%0a%3c }%0a%3c %0a%3c // |Qux| takes the ownership of |cb| and transfers ownership to PostTask(),%0a%3c // which also takes the ownership of |cb|.%0a%3c void Qux(OnceCallback%3cvoid(int)> cb) {%0a%3c   PostTask(FROM_HERE,%0a%3c            base::BindOnce(std::move(cb), 42));%0a%3c }%0a%3c =]%0a%3c @@Callback@@オブジェクトを関数パラメータに渡すとき、参照を保持する必要がないなら@@std::move()@@を使う。そうでないなら直接渡す。関数が排他的所有権を要求するならムーブで渡さないとコンパイルエラーになる。ムーブされた@@Callback@@はnullになることに注意すること。あたかも@@Reset()@@メソッドが呼ばれたようになり、@@is_null()@@はtrueを返す。%0a%3c %0a%3c !基本事項のクイックリファレンス%0a%3c !!生の関数を拘束%0a%3c =cpp [=%0a%3c int Return5() { return 5; }%0a%3c OnceCallback%3cint()> func_cb = BindOnce(&Return5);%0a%3c LOG(INFO) %3c%3c std::move(func_cb).Run();  // Prints 5.%0a%3c =]%0a%3c %0a%3c =cpp [=%0a%3c int Return5() { return 5; }%0a%3c RepeatingCallback%3cint()> func_cb = BindRepeating(&Return5);%0a%3c LOG(INFO) %3c%3c func_cb.Run();  // Prints 5.%0a%3c =]%0a%3c %0a%3c !!キャプチャなしのラムダを拘束%0a%3c =cpp [=%0a%3c Callback%3cint()> lambda_cb = Bind([] { return 4; });%0a%3c LOG(INFO) %3c%3c lambda_cb.Run();  // Print 4.%0a%3c %0a%3c OnceCallback%3cint()> lambda_cb2 = BindOnce([] { return 3; });%0a%3c LOG(INFO) %3c%3c std::move(lambda_cb2).Run();  // Print 3.%0a%3c =]%0a%3c %0a%3c !!クラスメソッドを拘束%0a%3c bindへの最初の引数は呼び出すメンバ関数、二番目は呼び出すオブジェクト%0a%3c =cpp [=%0a%3c class Ref : public RefCountedThreadSafe%3cRef> {%0a%3c  public:%0a%3c   int Foo() { return 3; }%0a%3c };%0a%3c scoped_refptr%3cRef> ref = new Ref();%0a%3c Callback%3cvoid()> ref_cb = Bind(&Ref::Foo, ref);%0a%3c LOG(INFO) %3c%3c ref_cb.Run();  // Prints out 3.%0a%3c =]%0a%3c デフォルトではオブジェクトはRefCountedをサポートしたいとコンパイルエラーになる。スレッド間で渡すなら、RefCountedThreadSafeを使うこと！参照カウンタを使いたくないなら下の「メンバ関数拘束の詳細」を見ること。%0a%3c %0a%3c !!コールバックの実行%0a%3c TODO%0a\ No newline at end of file%0a
host:1530947676=192.168.3.2
