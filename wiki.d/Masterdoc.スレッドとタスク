version=pmwiki-2.2.107 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1530880865
host=192.168.3.6
name=Masterdoc.スレッドとタスク
rev=1
targets=Masterdoc.タスクスケジューラの移転,開発者向け.ロックと条件変数
text=https://chromium.googlesource.com/chromium/src/+/master/docs/threading_and_tasks.md%0a%0a!概観%0aChromiumはマルチスレッドを多用する。それによりUIをスムーズにする。つまりIOや他の時間のかかる作業はスレッドで動いている。スレッド間の通信はメッセージを使う。ロックやスレッドセーフオブジェクトは推奨されない。オブジェクトは１つのスレッドのみに存在し、スレッド間でメッセージをやり取りし、情報のやり取りにはコールバックを使う。%0a%0a!!スレッド%0aすべてのChromeプロセスは以下のスレッドを持つ。%0a*メインスレッド%0a**ブラウザプロセス：UIの更新%0a**レンダープロセス：Blinkの大体の仕事%0a%0a*IOスレッド%0a**ブラウザプロセス：IPCのハンドルやネットワークリクエスト%0a**レンダープロセス：IPCのハンドル%0a%0a*いくつかの特別なスレッド%0a*一般用のプール%0a%0aほとんどのスレッドはタスクを取得するためのループとキューを持っている。（キューは共有されていることもある）%0a%0a!!タスク%0aタスクは'''base::OnceClosure'''クラスのインスタンスで、非同期の実行のためキューに追加される。%0a'''base::OnceClosure'''は関数ポインタと引数を保持しており、'''Run()'''メソッドが関数ポインタを実行する。これは'''base::BindOnce'''で作られる（参照：[[https://chromium.googlesource.com/chromium/src/+/lkcr/docs/callback.md|コールバックとBind()]]）%0a%0a=cpp [=%0avoid TaskA() {}%0avoid TaskB(int v) {}%0a%0aauto task_a = base::BindOnce(&TaskA);%0aauto task_b = base::BindOnce(&TaskB, 42);%0a=]%0a%0aタスクのグループは以下の方法で実行される。%0a*パラレル：タスクの順番を考慮しない。別々のスレッドで一気に実行される場合もある。%0a*シーケンス：ポストされた順番通りに実行される。一度に一つずつ実行される。どのスレッドでも実行されえる。%0a*シングルスレッド：ポストされた通りの順番で１つのスレッドで実行される。%0a->*COMシングルスレッド：シングルスレッドのCOM版、COMの初期化を伴う。%0a%0a!!シーケンスのほうがシングルスレッドより好ましい%0aスレッドセーフだけが要求される場合、'''シーケンス実行モードはシングルスレッドよりも遥かに好ましい。'''（シングルスレッドの場合、スレッドの最後に仕事を追加するがシーケンスの場合スレッドをHOPできる。）スレッドがホップできるとスレッドカウントが動的にマシンのリソース利用状況に適用される（大きいマシンでは早くなり、遅いマシンではゴミを減らす）。%0a%0a多くのコアAPIは最近シーケンスフレンドリになった。（ほとんどのクラスはthread-affine（スレッドローカルストレッジを使ったりしている）ではないはず）。しかしコードベースはシングルスレッドコンテキストを前提として進化してきた。もしクラスがシーケンスで実行可能で、リーフ依存のなかで'''ThreadChecker/ThreadTaskRunnerHandle/SingleThreadTaskrunner'''を多用しブロックされているなら、他の人のためにコードを見直すべき（最低でもブロッキングバグを[[https://crbug.com/675631]]に提出すべきで、'''base::CreateSingleThreadTaskRunnerWithTraits()'''にはTODOのフラグを付けるべき）。%0a%0aシングルスレッドからシーケンスへの詳細な文書は[[タスクスケジューラの移転|ここ]]にある。%0a%0a以下の議論はタスクを実行するこれらの詳細を述べる。%0a%0a!パラレスタスクをポスト%0a!!タスクスケジューラへ直接ポスト%0aどのスレッドでも実行できて、排他制御を持たないタスクは'''base::PostTask*()'''を使うべき。[[https://cs.chromium.org/chromium/src/base/task_scheduler/post_task.h|base/task_scheduler/post_task.h]]で定義される。%0a%0a=cpp [=%0abase::PostTask(FROM_HERE, base::BindOnce(&Task));%0a=]%0a%0aこれはデフォルトのトレイトでタスクをポストする。%0a%0a'''base::PostTask*WithTraits()'''は、'''TaskTraits'''を使って追加情報を提供できる。（下記参照）%0a=cpp [=%0abase::PostTaskWithTraits(%0a    FROM_HERE, {base::TaskPriority::BACKGROUND, MayBlock()},%0a    base::BindOnce(&Task));%0a=]%0a%0a!!TaskRunner経由でポストする%0aパラレルの'''[[https://cs.chromium.org/chromium/src/base/task_runner.h|TaskRunner]]'''は直接'''base::PostTask*()'''コールの代替品である。前もってタスクがパラレルなのかシーケンスなのかシングルスレッドなのかわからないときに有用である。（下記参照）。'''TaskRunnder'''は'''SequencedTaskRunner'''や'''SingleThreadTaskRunner'''のベースクラスなので、'''scoped_refptr%3cTaskRunnder>'''メンバは'''TaskRunnder'''や'''SequencedTaskRunner'''、または'''SingleThreadTaskRunner'''を保持できる。%0a%0a=cpp [=%0aclass A {%0a public:%0a  A() = default;%0a%0a  void set_task_runner_for_testing(%0a      scoped_refptr%3cbase::TaskRunner> task_runner) {%0a    task_runner_ = std::move(task_runner);%0a  }%0a%0a  void DoSomething() {%0a    // プロダクションコードでは, Aは常にパラレスでポストされる。テストでは%0a    // set_task_runner_for_testing()で提供されるTaskRunnerにポストされる。%0a    task_runner_->PostTask(FROM_HERE, base::BindOnce(&A));%0a  }%0a%0a private:%0a  scoped_refptr%3cbase::TaskRunner> task_runner_ =%0a      base::CreateTaskRunnerWithTraits({base::TaskPriority::USER_VISIBLE});%0a};%0a=]%0a%0aテストがタスク実行の正確なコントロールを必要としないときは、'''base::PostTask*()'''を直接コールするのが好ましい。%0a%0a%0a!シーケンスタスクのポスト%0aシーケンスタスクはポストされた順番に１つづつ処理されるタスク（同じスレッドで動作するとは限らない）。シーケンスタスクをポストするには'''SequencedTaskRunner'''を使う。%0a%0a!!新規シーケンスをポスト%0a'''SequncedTaskRunner'''は'''base::CreateSequencedTaskRunnerWithTraits()'''によって作成できる。%0a=cpp [=%0ascoped_refptr%3cSequencedTaskRunner> sequenced_task_runner =%0a    base::CreateSequencedTaskRunnerWithTraits(...);%0a%0a// TaskBはTaskAが終わってから実行される。%0asequenced_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskA));%0asequenced_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskB));%0a=]%0a%0a!!カレントシーケンスにポスト%0a現在のタスクがポストされた'''SequencedTaskRunner'''を得るには'''[[https://cs.chromium.org/chromium/src/base/threading/sequenced_task_runner_handle.h|SquencedTaskRunnerHandle::Get()]]'''を使う。%0a%0a'''注意:'''%0aパラレルタスクから'''SequencedTaskRunnerHandle::Get()'''を呼ぶことは出来ない。シングルスレッドのタスク（'''SingleThreadTaskRunner'''か'''SequencedTaskRunner'''）からなら呼ぶことができる。%0a%0a=cpp [=%0a// タスクはすでにポストされたタスクの後に実行される。%0a// （つまりこのタスクが終わってから実行される）。%0a// 他のタスクと同時に実行されることはない。%0abase::SequencedTaskRunnerHandle::Get()->%0a    PostTask(FROM_HERE, base::BindOnce(&Task));%0a=]%0a%0a!ロックの代わりにシーケンスを使う%0aChromeではロックは推奨されない。シーケンスは本質的にスレッドセーフを提供する。ロックでスレッドセーフを確保するよりも、同じシーケンスからのみアクセスされるクラスの方が好ましい。%0a%0a=cpp [=%0aclass A {%0a public:%0a  A() {%0a    // アクセスは作成シーケンス上にあることを要求しない。%0a    DETACH_FROM_SEQUENCE(sequence_checker_);%0a  }%0a%0a  void AddValue(int v) {%0a    // すべてのアクセスが同じシーケンスかをチェック。%0a    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);%0a    values_.push_back(v);%0a}%0a%0a private:%0a  SEQUENCE_CHECKER(sequence_checker_);%0a%0a  // すべてのアクセスは同じスレッド上にあるので%0a  // ロックは必要ない。%0a  std::vector%3cint> values_;%0a};%0a%0aA a;%0ascoped_refptr%3cSequencedTaskRunner> task_runner_for_a = ...;%0atask_runner_for_a->PostTask(FROM_HERE,%0a                      base::BindOnce(&A::AddValue, base::Unretained(&a), 42));%0atask_runner_for_a->PostTask(FROM_HERE,%0a                      base::BindOnce(&A::AddValue, base::Unretained(&a), 27));%0a%0a// 違うシーケンスからのアクセスはDCHECKで失敗する。%0ascoped_refptr%3cSequencedTaskRunner> other_task_runner = ...;%0aother_task_runner->PostTask(FROM_HERE,%0a                            base::BindOnce(&A::AddValue, base::Unretained(&a), 1));%0a=]%0a%0aロックはマルチスレッドでの共有データ構造のスワップでのみ使われるべきである。ロック中に重たい処理をすべきではない。データの用意が完了してからロックを取得しスワップすべきである。１つの例は'''PluginList::LoadPlugins'''([[https://cs.chromium.org/chromium/src/content/common/plugin_list.cc|content/common/plugin_list.cc]])である。どうしてもロックが必要なら、[[開発者向け/ロックと条件変数]]を参照してベストプラクティスを見て落とし穴にはまらないように。%0a%0aブロッキングなしのコードが書けるように、Chromiumの多くのAPIは非同期である。このことが意味することは処理は特定のスレッド/シーケンスで実行され、結果はデリゲートで受け取る、つまり'''base::Callback%3c>'''オブジェクトが完了後に呼び出されることで結果を受け取るということである。%0a%0a!同じスレッドに多くのタスクをポスト%0aもし多くのタスクが同じスレッドで実行される必要がある場合は、同じ'''SingleThreadTaskRunner'''にポストする。ポストされた順番通りに実行される。%0a%0a!!ブラウザプロセスのメインスレッドまたはIOスレッドへポスト%0a適切な'''SingleThreadTaskRunner'''を取得してポストする。取得には'''content::BrowserThread::GetTaskRunnerForThread'''を使う。%0a%0a=cpp [=%0acontent::BrowserThread::GetTaskRunnerForThread(content::BrowserThread::UI)%0a    ->PostTask(FROM_HERE, ...);%0a%0acontent::BrowserThread::GetTaskRunnerForThread(content::BrowserThread::IO)%0a    ->PostTask(FROM_HERE, ...);%0a=]%0a%0aメインスレッドやIOスレッドはいつもとても忙しいので可能であれば一般的なスレッド（パラレルタスクやシーケンスタスク）へポストすること。UIの更新やブラウザスレッドが持っているオブジェクト（プロファイルなど）へのアクセスのためにはブラウザスレッドを使う。IPCやネットワークにアクセスするにはIOスレッドを使う。注意：IPCやネットワークにアクセスするためにIOスレッドが絶対に必要なわけではない。%0a%0a!レンダプロセスのメインスレッドへポスト%0aTODO%0a%0a!カスタムSingleThreadTaskRunnerへポスト%0a多数のタスクが同じスレッドで実行される必要があり、それらはメインスレッドもIOスレッドも必要としないときは'''base::CreateSingleThreadTaskRunnerWithTraits'''で作成された'''SingleThreadTaskRunner'''へポストする。%0a%0a=cpp [=%0ascoped_refptr%3cSequencedTaskRunner> single_thread_task_runner =%0a    base::CreateSingleThreadTaskRunnerWithTraits(...);%0a%0a// TaskBはTaskAの完了後に実行される。どちらのタスクも同じスレッドで実行される。%0asingle_thread_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskA));%0asingle_thread_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskB));%0a=]%0a%0a'''重要：'''ほとんどの場合これは必要ない。Chromiumでのほとんどのクラスはスレッドセーフティを要求している（スレッドアフィニティではなく）。もし使うAPIが不正確にスレッドアフィニティなら（単にスレッドアンセーフのときに'''base::ThreadChecker'''を使っていたり（base::SequenceCheckerを使うべき））、自分のAPIもスレッドアフィニティにして自体を悪化させるより、それを修正することを考えてください。%0a%0aカレントスレッドへポストするなら'''ThreadTaskRunnerHandle'''を使う。%0a=cpp [=%0a// タスクはこの後にカレントスレッドで実行される。%0abase::ThreadTaskRunnerHandle::Get()->PostTask(%0a    FROM_HERE, base::BindOnce(&Task));%0a=]%0a%0a'''注意：'''パラレルまたはシーケンスから'''ThreadTaskRunnerHandle::Get()'''を呼ぶことは出来ません。%0a%0a!COMのSingle-Thread Apartmentスレッド(STD)にポストする（Windows）%0aCOMのSTAで動くタスクをポストするには、'''CreateCOMSTATaskRunnerWithTraits()'''で得られる'''SingleThreadTaskRunner'''を使う。%0a%0a=cpp [=%0a// Task(A|B|C)UsingCOMSTAは同じCOM STAスレッドで実行される。%0avoid TaskAUsingCOMSTA() {%0a  // [ これはCOM STAスレッドで実行される ]%0a  // COM STA呼び出しを実行。%0a  // ...%0a%0a  // 他のタスクを現在のCOM STAスレッドで実行。%0a  base::ThreadTaskRunnerHandle::Get()->PostTask(%0a      FROM_HERE, base::BindOnce(&TaskCUsingCOMSTA));%0a}%0avoid TaskBUsingCOMSTA() { }%0avoid TaskCUsingCOMSTA() { }%0a%0aauto com_sta_task_runner = base::CreateCOMSTATaskRunnerWithTraits(...);%0acom_sta_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskAUsingCOMSTA));%0acom_sta_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskBUsingCOMSTA));%0a=]%0a%0a!タスクトレイトでタスクを修飾%0a[[https://cs.chromium.org/chromium/src/base/task_scheduler/task_traits.h|TaskTraits]]はタスクについての情報をもち、タスクスケジューラがより良い決定をできるようにする。%0a%0a[[https://cs.chromium.org/chromium/src/base/task_scheduler/post_task.h|base/task_scheduler/post_task.h]]内のすべての'''PostTask*()'''関数は'''TaskTraits'''を引数に取る関数をオーバーロードしている。'''TaskTraits'''をとらない関数のオーバーロードに適しているのは以下の場合：%0a* ブロックしない（参照：'''MayBlock'''と'''WithBaseSyncPrimitives'''）。%0a* 現在の優先度を継承したい場合。%0a* シャットダウンをブロックするか、シャットダウン時にスキップされる場合（タスクスケジューラが適切な選択を自由にする）。これに当てはまらない場合は'''TaskTraits'''を使わなくてはならない。%0a%0a[[https://cs.chromium.org/chromium/src/base/task_scheduler/post_task.h|base/task_scheduler/post_task.h]]には利用できるトレイトについて大量のドキュメントがある。以下は'''TaskTraits'''を指定する実例。%0a%0a=cpp [=%0a// このタスクはTaskTraitsを指定されていない。ブロックできない。優先度は%0a// 呼び出し元のものを継承する。（バックグラウンドタスクからポストされれば%0a// バックグラウンドの優先度をもつ）%0a// シャットダウンをブロックするかもしれないし、シャットダウン中にスキップされるかもしれない%0abase::PostTask(FROM_HERE, base::BindOnce(...));%0a%0a// このタスクは最上位の優先度をもつ。スケジューラはUSER_VISIBLEやBACKGROUNDより%0a// 前にこのタスクを実行しようとする。%0abase::PostTaskWithTraits(%0a    FROM_HERE, {base::TaskPriority::USER_BLOCKING},%0a    base::BindOnce(...));%0a%0a// このタスクは最低位の優先度をもつ。ブロックされる%0a// （つまりディスクからファイルを読める）%0abase::PostTaskWithTraits(%0a    FROM_HERE, {base::TaskPriority::BACKGROUND, base::MayBlock()},%0a    base::BindOnce(...));%0a%0a// このタスクはシャットダウンをブロックする。タスクが完了するまで%0a// プロセスは終了しない。%0abase::PostTaskWithTraits(%0a    FROM_HERE, {base::TaskShutdownBehavior::BLOCK_SHUTDOWN},%0a    base::BindOnce(...));%0a=]%0a%0a!ブラウザの反応をよくする%0aメインスレッドやIOスレッドや低遅延が期待されるシーケンスで重たい処理をしないこと。それらは'''base::PostTaskAndReply*()'''か'''SequenceTaskRunner::PostTaskAndReply'''で非同期で実行する。注意：IOスレッドの非同期/オーバーラップIOは問題ない。%0a%0a実例：以下のコードをメインスレッドで実行すると、ブラウザのレスポンスが悪くなりユーザは待たされる。%0a%0a=cpp [=%0a// GetHistoryItemsFromDisk()は長時間ブロックするかもしれない。%0a// AddHistoryItemsToOmniboxDropDown()はUIをアップデートするので%0a// メインスレッドから呼ばなくてはならない。%0aAddHistoryItemsToOmniboxDropdown(GetHistoryItemsFromDisk("keyword"));%0a=]%0a%0a以下のコードは修正版。'''GetHistoryItemsFromDisk()'''をスレッドプールにスケジュールし、その後'''AddHistoryItemsToOmniboxDropdown()'''を呼ぶ（メインスレッドで）。最初の呼び出しの戻り値は自動的に次の呼び出しの引数になる。%0a%0a=cpp [=%0abase::PostTaskWithTraitsAndReplyWithResult(%0a    FROM_HERE, {base::MayBlock()},%0a    base::BindOnce(&GetHistoryItemsFromDisk, "keyword"),%0a    base::BindOnce(&AddHistoryItemsToOmniboxDropdown));%0a=]%0a%0a!遅延をもってタスクをポスト%0a!!遅延を持って一回限りのタスクをポスト%0a一定時間後に一回限り実行されるタスクをポストするには、'''PostDelayedTask*()'''または'''Taskrunner::PostDelayedTask()'''を使う。%0a%0a=cpp [=%0abase::PostDelayedTaskWithTraits(%0a  FROM_HERE, {base::TaskPriority::BACKGROUND}, base::BindOnce(&Task),%0a  base::TimeDelta::FromHours(1));%0a%0ascoped_refptr%3cbase::SequencedTaskRunner> task_runner =%0a    base::CreateSequencedTaskRunnerWithTraits({base::TaskPriority::BACKGROUND});%0atask_runner->PostDelayedTask(%0a    FROM_HERE, base::BindOnce(&Task), base::TimeDelta::FromHours(1));%0a=]%0a%0a'''注意：'''１時間後に実行されるタスクは、おそらく１時間たった後すぐに実行される必要はないだろう。'''base::TaskPriority::BACKGROUND'''を指定してブラウザにインパクトを与えないようにしている。%0a%0a!!遅延を持って繰り返しタスクをポスト%0a一定間隔で繰り返し実行されるタスクをポストするには、'''base::RepeatingTimer'''を使う。%0a=cpp [=%0aclass A {%0a public:%0a  ~A() {%0a    // The timer is stopped automatically when it is deleted.%0a  }%0a  void StartDoingStuff() {%0a    timer_.Start(FROM_HERE, TimeDelta::FromSeconds(1),%0a                 this, &MyClass::DoStuff);%0a  }%0a  void StopDoingStuff() {%0a    timer_.Stop();%0a  }%0a private:%0a  void DoStuff() {%0a    // This method is called every second on the sequence that invoked%0a    // StartDoingStuff().%0a  }%0a  base::RepeatingTimer timer_;%0a};%0a=]%0a%0a!タスクをキャンセル%0a!!base::WeakPtrを使う%0a'''[[https://cs.chromium.org/chromium/src/base/memory/weak_ptr.h|base::WeakPtr]]'''を使うとオブジェクトが破棄された後はタスクがキャンセルされることを保証する。%0a%0a=cpp [=%0aint Compute() { … }%0a%0aclass A {%0a public:%0a  A() : weak_ptr_factory_(this) {}%0a%0a  void ComputeAndStore() {%0a    // スレッドプールでCompute()呼び出しをスケジュールする。現在のシーケンスで%0a    // A::Store()が後に続いて実行される。A::Store()呼び出しは|weak_ptr_factory_|が破棄%0a    // されればキャンセルされる。%0a    // （|this|が開放された後使われないことを保証する）%0a    base::PostTaskAndReplyWithResult(%0a        FROM_HERE, base::BindOnce(&Compute),%0a        base::BindOnce(&A::Store, weak_ptr_factory_.GetWeakPtr()));%0a  }%0a%0a private:%0a  void Store(int value) { value_ = value; }%0a%0a  int value_;%0a  base::WeakPtrFactory%3cA> weak_ptr_factory_;%0a};%0a=]%0a%0a注意：'''WeakPtr'''はスレッドセーフでない：'''GetWeakPtr()''', '''~WeakPtrFactory()''', '''Compute()''' ('''WeakPtr'''に拘束されている)は同じシーケンスで呼ばなければならない。%0a%0a!Using base::CancelableTaskTracker
time=1530880865
author:1530880865=
diff:1530880865:1530880865:=1,356d0%0a%3c https://chromium.googlesource.com/chromium/src/+/master/docs/threading_and_tasks.md%0a%3c %0a%3c !概観%0a%3c Chromiumはマルチスレッドを多用する。それによりUIをスムーズにする。つまりIOや他の時間のかかる作業はスレッドで動いている。スレッド間の通信はメッセージを使う。ロックやスレッドセーフオブジェクトは推奨されない。オブジェクトは１つのスレッドのみに存在し、スレッド間でメッセージをやり取りし、情報のやり取りにはコールバックを使う。%0a%3c %0a%3c !!スレッド%0a%3c すべてのChromeプロセスは以下のスレッドを持つ。%0a%3c *メインスレッド%0a%3c **ブラウザプロセス：UIの更新%0a%3c **レンダープロセス：Blinkの大体の仕事%0a%3c %0a%3c *IOスレッド%0a%3c **ブラウザプロセス：IPCのハンドルやネットワークリクエスト%0a%3c **レンダープロセス：IPCのハンドル%0a%3c %0a%3c *いくつかの特別なスレッド%0a%3c *一般用のプール%0a%3c %0a%3c ほとんどのスレッドはタスクを取得するためのループとキューを持っている。（キューは共有されていることもある）%0a%3c %0a%3c !!タスク%0a%3c タスクは'''base::OnceClosure'''クラスのインスタンスで、非同期の実行のためキューに追加される。%0a%3c '''base::OnceClosure'''は関数ポインタと引数を保持しており、'''Run()'''メソッドが関数ポインタを実行する。これは'''base::BindOnce'''で作られる（参照：[[https://chromium.googlesource.com/chromium/src/+/lkcr/docs/callback.md|コールバックとBind()]]）%0a%3c %0a%3c =cpp [=%0a%3c void TaskA() {}%0a%3c void TaskB(int v) {}%0a%3c %0a%3c auto task_a = base::BindOnce(&TaskA);%0a%3c auto task_b = base::BindOnce(&TaskB, 42);%0a%3c =]%0a%3c %0a%3c タスクのグループは以下の方法で実行される。%0a%3c *パラレル：タスクの順番を考慮しない。別々のスレッドで一気に実行される場合もある。%0a%3c *シーケンス：ポストされた順番通りに実行される。一度に一つずつ実行される。どのスレッドでも実行されえる。%0a%3c *シングルスレッド：ポストされた通りの順番で１つのスレッドで実行される。%0a%3c ->*COMシングルスレッド：シングルスレッドのCOM版、COMの初期化を伴う。%0a%3c %0a%3c !!シーケンスのほうがシングルスレッドより好ましい%0a%3c スレッドセーフだけが要求される場合、'''シーケンス実行モードはシングルスレッドよりも遥かに好ましい。'''（シングルスレッドの場合、スレッドの最後に仕事を追加するがシーケンスの場合スレッドをHOPできる。）スレッドがホップできるとスレッドカウントが動的にマシンのリソース利用状況に適用される（大きいマシンでは早くなり、遅いマシンではゴミを減らす）。%0a%3c %0a%3c 多くのコアAPIは最近シーケンスフレンドリになった。（ほとんどのクラスはthread-affine（スレッドローカルストレッジを使ったりしている）ではないはず）。しかしコードベースはシングルスレッドコンテキストを前提として進化してきた。もしクラスがシーケンスで実行可能で、リーフ依存のなかで'''ThreadChecker/ThreadTaskRunnerHandle/SingleThreadTaskrunner'''を多用しブロックされているなら、他の人のためにコードを見直すべき（最低でもブロッキングバグを[[https://crbug.com/675631]]に提出すべきで、'''base::CreateSingleThreadTaskRunnerWithTraits()'''にはTODOのフラグを付けるべき）。%0a%3c %0a%3c シングルスレッドからシーケンスへの詳細な文書は[[タスクスケジューラの移転|ここ]]にある。%0a%3c %0a%3c 以下の議論はタスクを実行するこれらの詳細を述べる。%0a%3c %0a%3c !パラレスタスクをポスト%0a%3c !!タスクスケジューラへ直接ポスト%0a%3c どのスレッドでも実行できて、排他制御を持たないタスクは'''base::PostTask*()'''を使うべき。[[https://cs.chromium.org/chromium/src/base/task_scheduler/post_task.h|base/task_scheduler/post_task.h]]で定義される。%0a%3c %0a%3c =cpp [=%0a%3c base::PostTask(FROM_HERE, base::BindOnce(&Task));%0a%3c =]%0a%3c %0a%3c これはデフォルトのトレイトでタスクをポストする。%0a%3c %0a%3c '''base::PostTask*WithTraits()'''は、'''TaskTraits'''を使って追加情報を提供できる。（下記参照）%0a%3c =cpp [=%0a%3c base::PostTaskWithTraits(%0a%3c     FROM_HERE, {base::TaskPriority::BACKGROUND, MayBlock()},%0a%3c     base::BindOnce(&Task));%0a%3c =]%0a%3c %0a%3c !!TaskRunner経由でポストする%0a%3c パラレルの'''[[https://cs.chromium.org/chromium/src/base/task_runner.h|TaskRunner]]'''は直接'''base::PostTask*()'''コールの代替品である。前もってタスクがパラレルなのかシーケンスなのかシングルスレッドなのかわからないときに有用である。（下記参照）。'''TaskRunnder'''は'''SequencedTaskRunner'''や'''SingleThreadTaskRunner'''のベースクラスなので、'''scoped_refptr%3cTaskRunnder>'''メンバは'''TaskRunnder'''や'''SequencedTaskRunner'''、または'''SingleThreadTaskRunner'''を保持できる。%0a%3c %0a%3c =cpp [=%0a%3c class A {%0a%3c  public:%0a%3c   A() = default;%0a%3c %0a%3c   void set_task_runner_for_testing(%0a%3c       scoped_refptr%3cbase::TaskRunner> task_runner) {%0a%3c     task_runner_ = std::move(task_runner);%0a%3c   }%0a%3c %0a%3c   void DoSomething() {%0a%3c     // プロダクションコードでは, Aは常にパラレスでポストされる。テストでは%0a%3c     // set_task_runner_for_testing()で提供されるTaskRunnerにポストされる。%0a%3c     task_runner_->PostTask(FROM_HERE, base::BindOnce(&A));%0a%3c   }%0a%3c %0a%3c  private:%0a%3c   scoped_refptr%3cbase::TaskRunner> task_runner_ =%0a%3c       base::CreateTaskRunnerWithTraits({base::TaskPriority::USER_VISIBLE});%0a%3c };%0a%3c =]%0a%3c %0a%3c テストがタスク実行の正確なコントロールを必要としないときは、'''base::PostTask*()'''を直接コールするのが好ましい。%0a%3c %0a%3c %0a%3c !シーケンスタスクのポスト%0a%3c シーケンスタスクはポストされた順番に１つづつ処理されるタスク（同じスレッドで動作するとは限らない）。シーケンスタスクをポストするには'''SequencedTaskRunner'''を使う。%0a%3c %0a%3c !!新規シーケンスをポスト%0a%3c '''SequncedTaskRunner'''は'''base::CreateSequencedTaskRunnerWithTraits()'''によって作成できる。%0a%3c =cpp [=%0a%3c scoped_refptr%3cSequencedTaskRunner> sequenced_task_runner =%0a%3c     base::CreateSequencedTaskRunnerWithTraits(...);%0a%3c %0a%3c // TaskBはTaskAが終わってから実行される。%0a%3c sequenced_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskA));%0a%3c sequenced_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskB));%0a%3c =]%0a%3c %0a%3c !!カレントシーケンスにポスト%0a%3c 現在のタスクがポストされた'''SequencedTaskRunner'''を得るには'''[[https://cs.chromium.org/chromium/src/base/threading/sequenced_task_runner_handle.h|SquencedTaskRunnerHandle::Get()]]'''を使う。%0a%3c %0a%3c '''注意:'''%0a%3c パラレルタスクから'''SequencedTaskRunnerHandle::Get()'''を呼ぶことは出来ない。シングルスレッドのタスク（'''SingleThreadTaskRunner'''か'''SequencedTaskRunner'''）からなら呼ぶことができる。%0a%3c %0a%3c =cpp [=%0a%3c // タスクはすでにポストされたタスクの後に実行される。%0a%3c // （つまりこのタスクが終わってから実行される）。%0a%3c // 他のタスクと同時に実行されることはない。%0a%3c base::SequencedTaskRunnerHandle::Get()->%0a%3c     PostTask(FROM_HERE, base::BindOnce(&Task));%0a%3c =]%0a%3c %0a%3c !ロックの代わりにシーケンスを使う%0a%3c Chromeではロックは推奨されない。シーケンスは本質的にスレッドセーフを提供する。ロックでスレッドセーフを確保するよりも、同じシーケンスからのみアクセスされるクラスの方が好ましい。%0a%3c %0a%3c =cpp [=%0a%3c class A {%0a%3c  public:%0a%3c   A() {%0a%3c     // アクセスは作成シーケンス上にあることを要求しない。%0a%3c     DETACH_FROM_SEQUENCE(sequence_checker_);%0a%3c   }%0a%3c %0a%3c   void AddValue(int v) {%0a%3c     // すべてのアクセスが同じシーケンスかをチェック。%0a%3c     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);%0a%3c     values_.push_back(v);%0a%3c }%0a%3c %0a%3c  private:%0a%3c   SEQUENCE_CHECKER(sequence_checker_);%0a%3c %0a%3c   // すべてのアクセスは同じスレッド上にあるので%0a%3c   // ロックは必要ない。%0a%3c   std::vector%3cint> values_;%0a%3c };%0a%3c %0a%3c A a;%0a%3c scoped_refptr%3cSequencedTaskRunner> task_runner_for_a = ...;%0a%3c task_runner_for_a->PostTask(FROM_HERE,%0a%3c                       base::BindOnce(&A::AddValue, base::Unretained(&a), 42));%0a%3c task_runner_for_a->PostTask(FROM_HERE,%0a%3c                       base::BindOnce(&A::AddValue, base::Unretained(&a), 27));%0a%3c %0a%3c // 違うシーケンスからのアクセスはDCHECKで失敗する。%0a%3c scoped_refptr%3cSequencedTaskRunner> other_task_runner = ...;%0a%3c other_task_runner->PostTask(FROM_HERE,%0a%3c                             base::BindOnce(&A::AddValue, base::Unretained(&a), 1));%0a%3c =]%0a%3c %0a%3c ロックはマルチスレッドでの共有データ構造のスワップでのみ使われるべきである。ロック中に重たい処理をすべきではない。データの用意が完了してからロックを取得しスワップすべきである。１つの例は'''PluginList::LoadPlugins'''([[https://cs.chromium.org/chromium/src/content/common/plugin_list.cc|content/common/plugin_list.cc]])である。どうしてもロックが必要なら、[[開発者向け/ロックと条件変数]]を参照してベストプラクティスを見て落とし穴にはまらないように。%0a%3c %0a%3c ブロッキングなしのコードが書けるように、Chromiumの多くのAPIは非同期である。このことが意味することは処理は特定のスレッド/シーケンスで実行され、結果はデリゲートで受け取る、つまり'''base::Callback%3c>'''オブジェクトが完了後に呼び出されることで結果を受け取るということである。%0a%3c %0a%3c !同じスレッドに多くのタスクをポスト%0a%3c もし多くのタスクが同じスレッドで実行される必要がある場合は、同じ'''SingleThreadTaskRunner'''にポストする。ポストされた順番通りに実行される。%0a%3c %0a%3c !!ブラウザプロセスのメインスレッドまたはIOスレッドへポスト%0a%3c 適切な'''SingleThreadTaskRunner'''を取得してポストする。取得には'''content::BrowserThread::GetTaskRunnerForThread'''を使う。%0a%3c %0a%3c =cpp [=%0a%3c content::BrowserThread::GetTaskRunnerForThread(content::BrowserThread::UI)%0a%3c     ->PostTask(FROM_HERE, ...);%0a%3c %0a%3c content::BrowserThread::GetTaskRunnerForThread(content::BrowserThread::IO)%0a%3c     ->PostTask(FROM_HERE, ...);%0a%3c =]%0a%3c %0a%3c メインスレッドやIOスレッドはいつもとても忙しいので可能であれば一般的なスレッド（パラレルタスクやシーケンスタスク）へポストすること。UIの更新やブラウザスレッドが持っているオブジェクト（プロファイルなど）へのアクセスのためにはブラウザスレッドを使う。IPCやネットワークにアクセスするにはIOスレッドを使う。注意：IPCやネットワークにアクセスするためにIOスレッドが絶対に必要なわけではない。%0a%3c %0a%3c !レンダプロセスのメインスレッドへポスト%0a%3c TODO%0a%3c %0a%3c !カスタムSingleThreadTaskRunnerへポスト%0a%3c 多数のタスクが同じスレッドで実行される必要があり、それらはメインスレッドもIOスレッドも必要としないときは'''base::CreateSingleThreadTaskRunnerWithTraits'''で作成された'''SingleThreadTaskRunner'''へポストする。%0a%3c %0a%3c =cpp [=%0a%3c scoped_refptr%3cSequencedTaskRunner> single_thread_task_runner =%0a%3c     base::CreateSingleThreadTaskRunnerWithTraits(...);%0a%3c %0a%3c // TaskBはTaskAの完了後に実行される。どちらのタスクも同じスレッドで実行される。%0a%3c single_thread_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskA));%0a%3c single_thread_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskB));%0a%3c =]%0a%3c %0a%3c '''重要：'''ほとんどの場合これは必要ない。Chromiumでのほとんどのクラスはスレッドセーフティを要求している（スレッドアフィニティではなく）。もし使うAPIが不正確にスレッドアフィニティなら（単にスレッドアンセーフのときに'''base::ThreadChecker'''を使っていたり（base::SequenceCheckerを使うべき））、自分のAPIもスレッドアフィニティにして自体を悪化させるより、それを修正することを考えてください。%0a%3c %0a%3c カレントスレッドへポストするなら'''ThreadTaskRunnerHandle'''を使う。%0a%3c =cpp [=%0a%3c // タスクはこの後にカレントスレッドで実行される。%0a%3c base::ThreadTaskRunnerHandle::Get()->PostTask(%0a%3c     FROM_HERE, base::BindOnce(&Task));%0a%3c =]%0a%3c %0a%3c '''注意：'''パラレルまたはシーケンスから'''ThreadTaskRunnerHandle::Get()'''を呼ぶことは出来ません。%0a%3c %0a%3c !COMのSingle-Thread Apartmentスレッド(STD)にポストする（Windows）%0a%3c COMのSTAで動くタスクをポストするには、'''CreateCOMSTATaskRunnerWithTraits()'''で得られる'''SingleThreadTaskRunner'''を使う。%0a%3c %0a%3c =cpp [=%0a%3c // Task(A|B|C)UsingCOMSTAは同じCOM STAスレッドで実行される。%0a%3c void TaskAUsingCOMSTA() {%0a%3c   // [ これはCOM STAスレッドで実行される ]%0a%3c   // COM STA呼び出しを実行。%0a%3c   // ...%0a%3c %0a%3c   // 他のタスクを現在のCOM STAスレッドで実行。%0a%3c   base::ThreadTaskRunnerHandle::Get()->PostTask(%0a%3c       FROM_HERE, base::BindOnce(&TaskCUsingCOMSTA));%0a%3c }%0a%3c void TaskBUsingCOMSTA() { }%0a%3c void TaskCUsingCOMSTA() { }%0a%3c %0a%3c auto com_sta_task_runner = base::CreateCOMSTATaskRunnerWithTraits(...);%0a%3c com_sta_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskAUsingCOMSTA));%0a%3c com_sta_task_runner->PostTask(FROM_HERE, base::BindOnce(&TaskBUsingCOMSTA));%0a%3c =]%0a%3c %0a%3c !タスクトレイトでタスクを修飾%0a%3c [[https://cs.chromium.org/chromium/src/base/task_scheduler/task_traits.h|TaskTraits]]はタスクについての情報をもち、タスクスケジューラがより良い決定をできるようにする。%0a%3c %0a%3c [[https://cs.chromium.org/chromium/src/base/task_scheduler/post_task.h|base/task_scheduler/post_task.h]]内のすべての'''PostTask*()'''関数は'''TaskTraits'''を引数に取る関数をオーバーロードしている。'''TaskTraits'''をとらない関数のオーバーロードに適しているのは以下の場合：%0a%3c * ブロックしない（参照：'''MayBlock'''と'''WithBaseSyncPrimitives'''）。%0a%3c * 現在の優先度を継承したい場合。%0a%3c * シャットダウンをブロックするか、シャットダウン時にスキップされる場合（タスクスケジューラが適切な選択を自由にする）。これに当てはまらない場合は'''TaskTraits'''を使わなくてはならない。%0a%3c %0a%3c [[https://cs.chromium.org/chromium/src/base/task_scheduler/post_task.h|base/task_scheduler/post_task.h]]には利用できるトレイトについて大量のドキュメントがある。以下は'''TaskTraits'''を指定する実例。%0a%3c %0a%3c =cpp [=%0a%3c // このタスクはTaskTraitsを指定されていない。ブロックできない。優先度は%0a%3c // 呼び出し元のものを継承する。（バックグラウンドタスクからポストされれば%0a%3c // バックグラウンドの優先度をもつ）%0a%3c // シャットダウンをブロックするかもしれないし、シャットダウン中にスキップされるかもしれない%0a%3c base::PostTask(FROM_HERE, base::BindOnce(...));%0a%3c %0a%3c // このタスクは最上位の優先度をもつ。スケジューラはUSER_VISIBLEやBACKGROUNDより%0a%3c // 前にこのタスクを実行しようとする。%0a%3c base::PostTaskWithTraits(%0a%3c     FROM_HERE, {base::TaskPriority::USER_BLOCKING},%0a%3c     base::BindOnce(...));%0a%3c %0a%3c // このタスクは最低位の優先度をもつ。ブロックされる%0a%3c // （つまりディスクからファイルを読める）%0a%3c base::PostTaskWithTraits(%0a%3c     FROM_HERE, {base::TaskPriority::BACKGROUND, base::MayBlock()},%0a%3c     base::BindOnce(...));%0a%3c %0a%3c // このタスクはシャットダウンをブロックする。タスクが完了するまで%0a%3c // プロセスは終了しない。%0a%3c base::PostTaskWithTraits(%0a%3c     FROM_HERE, {base::TaskShutdownBehavior::BLOCK_SHUTDOWN},%0a%3c     base::BindOnce(...));%0a%3c =]%0a%3c %0a%3c !ブラウザの反応をよくする%0a%3c メインスレッドやIOスレッドや低遅延が期待されるシーケンスで重たい処理をしないこと。それらは'''base::PostTaskAndReply*()'''か'''SequenceTaskRunner::PostTaskAndReply'''で非同期で実行する。注意：IOスレッドの非同期/オーバーラップIOは問題ない。%0a%3c %0a%3c 実例：以下のコードをメインスレッドで実行すると、ブラウザのレスポンスが悪くなりユーザは待たされる。%0a%3c %0a%3c =cpp [=%0a%3c // GetHistoryItemsFromDisk()は長時間ブロックするかもしれない。%0a%3c // AddHistoryItemsToOmniboxDropDown()はUIをアップデートするので%0a%3c // メインスレッドから呼ばなくてはならない。%0a%3c AddHistoryItemsToOmniboxDropdown(GetHistoryItemsFromDisk("keyword"));%0a%3c =]%0a%3c %0a%3c 以下のコードは修正版。'''GetHistoryItemsFromDisk()'''をスレッドプールにスケジュールし、その後'''AddHistoryItemsToOmniboxDropdown()'''を呼ぶ（メインスレッドで）。最初の呼び出しの戻り値は自動的に次の呼び出しの引数になる。%0a%3c %0a%3c =cpp [=%0a%3c base::PostTaskWithTraitsAndReplyWithResult(%0a%3c     FROM_HERE, {base::MayBlock()},%0a%3c     base::BindOnce(&GetHistoryItemsFromDisk, "keyword"),%0a%3c     base::BindOnce(&AddHistoryItemsToOmniboxDropdown));%0a%3c =]%0a%3c %0a%3c !遅延をもってタスクをポスト%0a%3c !!遅延を持って一回限りのタスクをポスト%0a%3c 一定時間後に一回限り実行されるタスクをポストするには、'''PostDelayedTask*()'''または'''Taskrunner::PostDelayedTask()'''を使う。%0a%3c %0a%3c =cpp [=%0a%3c base::PostDelayedTaskWithTraits(%0a%3c   FROM_HERE, {base::TaskPriority::BACKGROUND}, base::BindOnce(&Task),%0a%3c   base::TimeDelta::FromHours(1));%0a%3c %0a%3c scoped_refptr%3cbase::SequencedTaskRunner> task_runner =%0a%3c     base::CreateSequencedTaskRunnerWithTraits({base::TaskPriority::BACKGROUND});%0a%3c task_runner->PostDelayedTask(%0a%3c     FROM_HERE, base::BindOnce(&Task), base::TimeDelta::FromHours(1));%0a%3c =]%0a%3c %0a%3c '''注意：'''１時間後に実行されるタスクは、おそらく１時間たった後すぐに実行される必要はないだろう。'''base::TaskPriority::BACKGROUND'''を指定してブラウザにインパクトを与えないようにしている。%0a%3c %0a%3c !!遅延を持って繰り返しタスクをポスト%0a%3c 一定間隔で繰り返し実行されるタスクをポストするには、'''base::RepeatingTimer'''を使う。%0a%3c =cpp [=%0a%3c class A {%0a%3c  public:%0a%3c   ~A() {%0a%3c     // The timer is stopped automatically when it is deleted.%0a%3c   }%0a%3c   void StartDoingStuff() {%0a%3c     timer_.Start(FROM_HERE, TimeDelta::FromSeconds(1),%0a%3c                  this, &MyClass::DoStuff);%0a%3c   }%0a%3c   void StopDoingStuff() {%0a%3c     timer_.Stop();%0a%3c   }%0a%3c  private:%0a%3c   void DoStuff() {%0a%3c     // This method is called every second on the sequence that invoked%0a%3c     // StartDoingStuff().%0a%3c   }%0a%3c   base::RepeatingTimer timer_;%0a%3c };%0a%3c =]%0a%3c %0a%3c !タスクをキャンセル%0a%3c !!base::WeakPtrを使う%0a%3c '''[[https://cs.chromium.org/chromium/src/base/memory/weak_ptr.h|base::WeakPtr]]'''を使うとオブジェクトが破棄された後はタスクがキャンセルされることを保証する。%0a%3c %0a%3c =cpp [=%0a%3c int Compute() { … }%0a%3c %0a%3c class A {%0a%3c  public:%0a%3c   A() : weak_ptr_factory_(this) {}%0a%3c %0a%3c   void ComputeAndStore() {%0a%3c     // スレッドプールでCompute()呼び出しをスケジュールする。現在のシーケンスで%0a%3c     // A::Store()が後に続いて実行される。A::Store()呼び出しは|weak_ptr_factory_|が破棄%0a%3c     // されればキャンセルされる。%0a%3c     // （|this|が開放された後使われないことを保証する）%0a%3c     base::PostTaskAndReplyWithResult(%0a%3c         FROM_HERE, base::BindOnce(&Compute),%0a%3c         base::BindOnce(&A::Store, weak_ptr_factory_.GetWeakPtr()));%0a%3c   }%0a%3c %0a%3c  private:%0a%3c   void Store(int value) { value_ = value; }%0a%3c %0a%3c   int value_;%0a%3c   base::WeakPtrFactory%3cA> weak_ptr_factory_;%0a%3c };%0a%3c =]%0a%3c %0a%3c 注意：'''WeakPtr'''はスレッドセーフでない：'''GetWeakPtr()''', '''~WeakPtrFactory()''', '''Compute()''' ('''WeakPtr'''に拘束されている)は同じシーケンスで呼ばなければならない。%0a%3c %0a%3c !Using base::CancelableTaskTracker%0a\ No newline at end of file%0a
host:1530880865=192.168.3.6
