version=pmwiki-2.2.107 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko
author=
charset=UTF-8
csum=
ctime=1532466245
host=192.168.3.2
name=HowTo.Windowsでのデバッグ
rev=4
targets=テスター情報.ログのとり方,HowTo.ユーザデータディレクトリ,デザイン.マルチプロセスアーキテクチャ,HowTo.VisualStudio2013でグラフィックデバッグ,HowTo.NVIDIANSightでグラフィックデバッグ
text=https://www.chromium.org/developers/how-tos/debugging-on-windows%0a%0a!!始める%0aVisual StudioやWinDBGが使える。ビルドするのにIDEは必要ないが、デバッグでは使える。デバッグを開始するには以下のコマンドを実行。%0a [=%0adevenv /debugexe out\Debug\chrome.exe %3coptions to Chromium can go here>%0a=]%0a%0aVisual Studioがインストールされていてパスが通っていることが前提、depot_toolsにパスが通っている必要はない。devenv.exeでなくdevenv.comのほうがいいのかもしれない。chrome.exeは後々chrome.dllやcontent.dllなどの大きなPDBをもつモジュールをロードし、とても重くなる。他のプロセスも実行するのでデバッグは難しくなる。%0a%0aGoma(Googleの内部配布ビルド）ではsymbol_level=1になっていて、ソースコードレベルでのデバッグができない。Gomaをフルデバッグしたい場合はSymbol_level=2とis_win_fastlink=1が必要。しかしこれはデバッガのバグを引き起こすかもしれない。最新のデバッガを使うようにするべき。%0a%0a!Profiles%0aデバッグ用に別のプロファイルを使うのがいい。Google ChromeのブランドビルドやChromiumをデバッグしているならプロファイルが衝突し、同時に実行することができない、また安定ビルドのブラウザが未来のプロファイルを参照してしまうかもしれない。（Google ChromeとChromiumのプロファイルは今は衝突しない）。プロファイル指定のコマンドラインは以下。%0a%0a [=%0a--user-data-dir=c:\tmp\my_debug_profile (replace the path as necessary)%0a=]%0a%0aIDEを使うならデバッグタブに移動し、コマンド引数に追加する。%0a%0a!Chromeデバッグログ%0a@@--enable-logging --v=1@@でChromeのデバッグログを有効にできる。デバッグビルドは@@chrome_debug.log@@を@@out\Debug@@に作成する。リリースビルドではChromiumアプリディレクトリに置くが、これはOS依存。[[テスター情報/ログのとり方|ロギング]]と[[ユーザデータディレクトリ]]を参照。%0a%0a!!Symbolサーバ%0a公式のGoogle Chromeリリースビルドをデバッグするなら、以下のシンボルサーバが使える。%0a [=%0ahttps://chromium-browser-symsrv.commondatastorage.googleapis.com%0a=]%0a%0aVisual Studioでは、'''Debugging > Symbols'''の'''Tools > Options'''にある。ローカルキャッシュを持てば速くなる。%0a%0a!マルチプロセス問題%0aChromiumは[[デザイン/マルチプロセスアーキテクチャ|マルチプロセス]]なのでデバッグが大変になる。デバッガで実行するとき、メインのブラウザプロセスだけがデバッグ対象になる。レンダラやプラグインは他のプロセスなのでデバッグ対象にならない。[[https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer|ProcessExplorer]]ではプロセスをツリー上に表示できる。ChromeのタブごとのプロセスIDが確認できる。%0a%0a!!シングルプロセスモード%0aもっとも簡単な方法はシングルプロセスモードを使う方法。これでプログラムのすべての状況をしることができる。シングルプロセスモードを使うには以下のコマンドラインフラグを指定する。%0a%0a [=%0a--single-process%0a=]%0a%0aこのやり方は完全ではない。問題が現象しないかもしれないし、いくつかの機能を動かないかもしれない。%0a%0a!!子プロセスに手動でアタッチ%0aデバッガで実行中の子プロセスにアタッチできる。'''Tools > Attach'''でchrome.exeにアタッチする。'''ネイティブコードのみ'''が選択されていることを確認すること。これを忘れると、"WebKit"モードでJavascriptへのアタッチを試みて、エラー"An operation is not legal in the current state"が発生する。%0a%0aこれで２つのプロセスを１つのようにデバッグできる。多数のプロセスをデバッグするなら'''Debug > Windows > Processed'''を開き切り替えられる。%0a%0aスタートアップでのみ実行されるコードをデバッグするには以下を使う。%0a [=%0a--render-startup-dialog --no-sandbox%0a=]%0aサンドボックスは無効にしないとダイアログが表示されない。ダイアログが表示されたら、'''Tools > Attach to Process'''してプロセスにアタッチする。他のプロセスの場合、以下のような引数を使う。%0a%0a [=%0a--gpu-startup-dialog%0a--ppapi-startup-dialog%0a--plugin-startup-dialog%0a=]%0a%0a[[http://chromium.github.io/vs-chromium/#attach-to-chrome|vs-chromiumプラグイン]]で正しいプロセスにアタッチできる。%0a%0a!!子プロセスの準自動アタッチ%0a以下のフラグを指定すると子プロセスはあ６０秒ビジーループで待つ。%0a [=%0a--wait-for-debugger-children[=filter]%0a=]%0afilterがあれば、--typeパラメータをフィルタする。@@renderer@@,@@plugin@@(for NPAPI),@@ppapi@@,@@gpu-process@@ and @@utility@@.%0a%0a以下のオプションで、レンダラプロセスの個数を指定できる。%0a [=%0a--renderer-process-limit=1%0a=]%0a%0a!!イメージファイル実行オプション%0aImage File Execution Options(IFEO)は機能しない。CreateProcess()はデバッガプロセスのハンドルを返すため。サンドボックスとの問題もある。%0a%0a!Visual Studioヒント%0a!!デバッグヴィジュアライザー%0aTODO%0a!!ささいな関数にステップインしない%0aステップインしない関数を正規表現で指定できる。以下のフォルダの設定ファイル@@.natstepfilter@@を編集する。%0a*'''For Visual Studio 2015''': C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\Packages\Debugger\Visualizers (for all users) or [=%25USERPROFILE%25=]\My Documents\Visual Studio 2015\Visualizers (for the current user only)%0a*'''For Visual Studio 2017 Pro''': C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\Common7\Packages\Debugger\Visualizers (for all users) or [=%25USERPROFILE%25=]\My Documents\Visual Studio 2017\Visualizers (for the current user only)%0a%0a以下の内容を追加%0a=xml [=%0a%3c?xml version="1.0" encoding="utf-8"?>  %0a%3cStepFilter xmlns="http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010">  %0a  %3cFunction>%3cName>operator new%3c/Name>%3cAction>NoStepInto%3c/Action>%3c/Function>%0a  %3cFunction>%3cName>operator delete%3c/Name>%3cAction>NoStepInto%3c/Action>%3c/Function>%0a  %3c!-- Skip everything in std -->%0a  %3cFunction>%3cName>std::.*%3c/Name>%3cAction>NoStepInto%3c/Action>%3c/Function>%0a  %3c!-- all methods on WebKit OwnPtr and variants, ... WTF::*Ptr%3c*>::* -->%0a  %3cFunction>%3cName>WTF::.*Ptr&lt;.*&gt;::.*%3c/Name>%3cAction>NoStepInto%3c/Action>%3c/Function>%0a%3c/StepFilter>%0a=]%0aこのファイルはデバッグ実行時（F5）に読み込まれるのでVisual Studioを再起動する必要はない。%0a%0a!V8とChromium%0aV8はデバッグをサポートする豊富なコマンドラインフラグを持っている。Chromiumのコマンドラインで@@--js-flags@@経由で渡すことができる。%0a [=%0achrome.exe --js-flags="--trace_exception --heap_stats"%0a=]%0aこのコマンドラインフラグはデバッグ版のV8にしか存在しない。すべてのV8フラグを見るには以下を行う。%0a [=%0achrome.exe --js-flags="--help"%0a=]%0a!グラフィックのデバッグ%0aレンダリングのGPU加速はツールを使って容易にデバッグできる。以下を参照%0a*[[Visual Studio 2013でグラフィックデバッグ]]%0a*[[NVIDIA NSightでグラフィックデバッグ]]%0a%0a!他のマシンでデバッグ%0a他のマシンにデバッグ環境を構築すると有益なこともある。他のマシン（デバッグマシン）にデバッグ環境を構築するには最初にビルドマシンで@@mini_installerターゲットをビルドする。（@@ninja -C out\Debug mini_installer@@）。次にデバッグマシンで以下の事を行う。%0a*ビルドマシンのビルドボリュームをマウントするかUNCで見えるようにする。%0a*コマンドプロンプトを開き、ローカルディスクに移動する。%0a*@@src\tools\win\copy-installer.bat@@を先ほどのマウントポイントから実行する。これはインストーラやDLL、PDBをデバッグマシンの@@C:\out@@または@@C:\build@@にコピーする（コンポーネントビルドしたかどうかで異なる）。%0a*@@C:\out\Debug\mini_installer.exe@@を必要ならフラグを添えて実行し、タスクマネージャでインストーラがchrome.exeを実行するまで監視。%0a*@@_NT_SYMBOL_PATH@@に@@C:\out\Debug@@を追加する。%0a%0a@@copy_installer.bat@@の最初に書いてある文書を読むこと。このファイルは再度実行しても問題ない。%0a%0a!メモリリークを見つける%0aWindowsのヒープマネージャは役立つデバッグフラグを持っている。すべてのメモリ割り当てのスタックトレースをキャプチャする。WinDbgとUMDHでこれらスタックとレースをプロセスからscrapeできる。%0a%0aUMDHは偉大。ヒープ状態のスナップショットをキャプチャし、スタックトレースをシンボル化し使用集計をユニークスタックトレースへまとめる。%0a%0agflagsをつかってユーザスタックトレースデータベースを有効にできる。とても遅くなるがブラウザプロセスだけやればよい。%0a%0a@@"!gflag"@@デバッグ拡張でユーザスタックデータベースを有効にできるが、ブレークポイントがヒットした時点ではすでに遅い。正しいやり方は以下。%0a#@@GFlags.exe@@を起動%0a#（イメージごとの）ユーザスタックトレースデータベースを有効に%0a#デバッガー下でChromeを起動%0a#chrome.dllがロードしたときブレークするブレークポインタを設定 @@"sxe ld chrome.dll"@@%0a#ステップ実行しChrome.dllを初期化%0a#@@GFlags.exe@@でスタックトレースデータベースを無効化%0a#chromeを継続実行し、必要ならデバッガから切り離す%0a%0ahttps://www.chromium.org/_/rsrc/1480103082209/developers/how-tos/debugging-on-windows/gflags.png"GFlags.exe" | @@GFlags.exe@@でユーザモードスタックトレースデータベースを設定%0a%0aブラウザのメモリリークで困っているなら、以下のコマンドでダンプを吐き出す。%0a [=%0aumdh -p:%3cmy browser pid> > chrome-browser-leak-umdh-dump.txt%0a=]%0a典型的には「ささいな」犯人が見つかる。%0a%0a!その他いろいろ%0a*[[http://www.microsoft.com/downloads/details.aspx?FamilyID=bd02c19c-1250-433c-8c1b-2619bd93b3a2&displaylang=en|アプリケーションべりファイア]]はマイクロソフトのフリーツール。ツールの実行にはサンドボックスの無効化が必要（@@--no-sandbox@@）。そうしてアプリが認証したプロセスをデバッガで実行する。つまりレンダープロセスやプラグインプロセスはデバッガで実行する必要がある、そうしないと変な風になる。上述した方法でアタッチする必要がある。%0a%0a*@@CreateFile()@@にブレークポイントを設定するには以下のようにする。%0a [=%0a{,,kernel32.dll}_CreateFileW@28%0a]=%0a**@@{,,kernel32.dll}@@はDLLを指定する（コンテキストオペレータ）。%0a**@@_@@プリフィックスはextern "C"を意味する。%0a**@28は@@_stdcall@@を意味する。関数の終わりでスタックがポップする。つまり引数のバイト数。%0a*SysInternalsのDebugViewや[[https://github.com/google/sawbuck/releases/latest|sawbuck]]で通常POSIXではstderrへいくLOG()メッセージを見れる。%0a%0a%0a
time=1532510047
author:1532510047=
diff:1532510047:1532508645:=67c67%0a%3c --wait-for-debugger-children[=filter]%0a---%0a> --wait-for-debugger-childres[=filter]%0a
host:1532510047=192.168.3.2
author:1532508645=
diff:1532508645:1532508555:=23c23%0a%3c @@--enable-logging --v=1@@でChromeのデバッグログを有効にできる。デバッグビルドは@@chrome_debug.log@@を@@out\Debug@@に作成する。リリースビルドではChromiumアプリディレクトリに置くが、これはOS依存。[[テスター情報/ログのとり方|ロギング]]と[[ユーザデータディレクトリ]]を参照。%0a---%0a> @@--enable-logging --v=1@@でChromeのデバッグログを有効にできる。デバッグビルドは@@chrome_debug.log@@を@@out\Debug@@に作成する。リリースビルドではChromiumアプリディレクトリに置くが、これはOS依存。[[ロギング]]と[[ユーザデータディレクトリ]]を参照。%0a
host:1532508645=192.168.3.2
author:1532508555=
diff:1532508555:1532466245:=34c34%0a%3c Chromiumは[[デザイン/マルチプロセスアーキテクチャ|マルチプロセス]]なのでデバッグが大変になる。デバッガで実行するとき、メインのブラウザプロセスだけがデバッグ対象になる。レンダラやプラグインは他のプロセスなのでデバッグ対象にならない。[[https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer|ProcessExplorer]]ではプロセスをツリー上に表示できる。ChromeのタブごとのプロセスIDが確認できる。%0a---%0a> Chromiumは[[開発者向け/マルチプロセスアーキテクチャ|マルチプロセス]]なのでデバッグが大変になる。デバッガで実行するとき、メインのブラウザプロセスだけがデバッグ対象になる。レンダラやプラグインは他のプロセスなのでデバッグ対象にならない。[[https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer|ProcessExplorer]]ではプロセスをツリー上に表示できる。ChromeのタブごとのプロセスIDが確認できる。%0a
host:1532508555=192.168.3.2
author:1532466245=
diff:1532466245:1532466245:=1,161d0%0a%3c https://www.chromium.org/developers/how-tos/debugging-on-windows%0a%3c %0a%3c !!始める%0a%3c Visual StudioやWinDBGが使える。ビルドするのにIDEは必要ないが、デバッグでは使える。デバッグを開始するには以下のコマンドを実行。%0a%3c  [=%0a%3c devenv /debugexe out\Debug\chrome.exe %3coptions to Chromium can go here>%0a%3c =]%0a%3c %0a%3c Visual Studioがインストールされていてパスが通っていることが前提、depot_toolsにパスが通っている必要はない。devenv.exeでなくdevenv.comのほうがいいのかもしれない。chrome.exeは後々chrome.dllやcontent.dllなどの大きなPDBをもつモジュールをロードし、とても重くなる。他のプロセスも実行するのでデバッグは難しくなる。%0a%3c %0a%3c Goma(Googleの内部配布ビルド）ではsymbol_level=1になっていて、ソースコードレベルでのデバッグができない。Gomaをフルデバッグしたい場合はSymbol_level=2とis_win_fastlink=1が必要。しかしこれはデバッガのバグを引き起こすかもしれない。最新のデバッガを使うようにするべき。%0a%3c %0a%3c !Profiles%0a%3c デバッグ用に別のプロファイルを使うのがいい。Google ChromeのブランドビルドやChromiumをデバッグしているならプロファイルが衝突し、同時に実行することができない、また安定ビルドのブラウザが未来のプロファイルを参照してしまうかもしれない。（Google ChromeとChromiumのプロファイルは今は衝突しない）。プロファイル指定のコマンドラインは以下。%0a%3c %0a%3c  [=%0a%3c --user-data-dir=c:\tmp\my_debug_profile (replace the path as necessary)%0a%3c =]%0a%3c %0a%3c IDEを使うならデバッグタブに移動し、コマンド引数に追加する。%0a%3c %0a%3c !Chromeデバッグログ%0a%3c @@--enable-logging --v=1@@でChromeのデバッグログを有効にできる。デバッグビルドは@@chrome_debug.log@@を@@out\Debug@@に作成する。リリースビルドではChromiumアプリディレクトリに置くが、これはOS依存。[[ロギング]]と[[ユーザデータディレクトリ]]を参照。%0a%3c %0a%3c !!Symbolサーバ%0a%3c 公式のGoogle Chromeリリースビルドをデバッグするなら、以下のシンボルサーバが使える。%0a%3c  [=%0a%3c https://chromium-browser-symsrv.commondatastorage.googleapis.com%0a%3c =]%0a%3c %0a%3c Visual Studioでは、'''Debugging > Symbols'''の'''Tools > Options'''にある。ローカルキャッシュを持てば速くなる。%0a%3c %0a%3c !マルチプロセス問題%0a%3c Chromiumは[[開発者向け/マルチプロセスアーキテクチャ|マルチプロセス]]なのでデバッグが大変になる。デバッガで実行するとき、メインのブラウザプロセスだけがデバッグ対象になる。レンダラやプラグインは他のプロセスなのでデバッグ対象にならない。[[https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer|ProcessExplorer]]ではプロセスをツリー上に表示できる。ChromeのタブごとのプロセスIDが確認できる。%0a%3c %0a%3c !!シングルプロセスモード%0a%3c もっとも簡単な方法はシングルプロセスモードを使う方法。これでプログラムのすべての状況をしることができる。シングルプロセスモードを使うには以下のコマンドラインフラグを指定する。%0a%3c %0a%3c  [=%0a%3c --single-process%0a%3c =]%0a%3c %0a%3c このやり方は完全ではない。問題が現象しないかもしれないし、いくつかの機能を動かないかもしれない。%0a%3c %0a%3c !!子プロセスに手動でアタッチ%0a%3c デバッガで実行中の子プロセスにアタッチできる。'''Tools > Attach'''でchrome.exeにアタッチする。'''ネイティブコードのみ'''が選択されていることを確認すること。これを忘れると、"WebKit"モードでJavascriptへのアタッチを試みて、エラー"An operation is not legal in the current state"が発生する。%0a%3c %0a%3c これで２つのプロセスを１つのようにデバッグできる。多数のプロセスをデバッグするなら'''Debug > Windows > Processed'''を開き切り替えられる。%0a%3c %0a%3c スタートアップでのみ実行されるコードをデバッグするには以下を使う。%0a%3c  [=%0a%3c --render-startup-dialog --no-sandbox%0a%3c =]%0a%3c サンドボックスは無効にしないとダイアログが表示されない。ダイアログが表示されたら、'''Tools > Attach to Process'''してプロセスにアタッチする。他のプロセスの場合、以下のような引数を使う。%0a%3c %0a%3c  [=%0a%3c --gpu-startup-dialog%0a%3c --ppapi-startup-dialog%0a%3c --plugin-startup-dialog%0a%3c =]%0a%3c %0a%3c [[http://chromium.github.io/vs-chromium/#attach-to-chrome|vs-chromiumプラグイン]]で正しいプロセスにアタッチできる。%0a%3c %0a%3c !!子プロセスの準自動アタッチ%0a%3c 以下のフラグを指定すると子プロセスはあ６０秒ビジーループで待つ。%0a%3c  [=%0a%3c --wait-for-debugger-childres[=filter]%0a%3c =]%0a%3c filterがあれば、--typeパラメータをフィルタする。@@renderer@@,@@plugin@@(for NPAPI),@@ppapi@@,@@gpu-process@@ and @@utility@@.%0a%3c %0a%3c 以下のオプションで、レンダラプロセスの個数を指定できる。%0a%3c  [=%0a%3c --renderer-process-limit=1%0a%3c =]%0a%3c %0a%3c !!イメージファイル実行オプション%0a%3c Image File Execution Options(IFEO)は機能しない。CreateProcess()はデバッガプロセスのハンドルを返すため。サンドボックスとの問題もある。%0a%3c %0a%3c !Visual Studioヒント%0a%3c !!デバッグヴィジュアライザー%0a%3c TODO%0a%3c !!ささいな関数にステップインしない%0a%3c ステップインしない関数を正規表現で指定できる。以下のフォルダの設定ファイル@@.natstepfilter@@を編集する。%0a%3c *'''For Visual Studio 2015''': C:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\Packages\Debugger\Visualizers (for all users) or [=%25USERPROFILE%25=]\My Documents\Visual Studio 2015\Visualizers (for the current user only)%0a%3c *'''For Visual Studio 2017 Pro''': C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\Common7\Packages\Debugger\Visualizers (for all users) or [=%25USERPROFILE%25=]\My Documents\Visual Studio 2017\Visualizers (for the current user only)%0a%3c %0a%3c 以下の内容を追加%0a%3c =xml [=%0a%3c %3c?xml version="1.0" encoding="utf-8"?>  %0a%3c %3cStepFilter xmlns="http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010">  %0a%3c   %3cFunction>%3cName>operator new%3c/Name>%3cAction>NoStepInto%3c/Action>%3c/Function>%0a%3c   %3cFunction>%3cName>operator delete%3c/Name>%3cAction>NoStepInto%3c/Action>%3c/Function>%0a%3c   %3c!-- Skip everything in std -->%0a%3c   %3cFunction>%3cName>std::.*%3c/Name>%3cAction>NoStepInto%3c/Action>%3c/Function>%0a%3c   %3c!-- all methods on WebKit OwnPtr and variants, ... WTF::*Ptr%3c*>::* -->%0a%3c   %3cFunction>%3cName>WTF::.*Ptr&lt;.*&gt;::.*%3c/Name>%3cAction>NoStepInto%3c/Action>%3c/Function>%0a%3c %3c/StepFilter>%0a%3c =]%0a%3c このファイルはデバッグ実行時（F5）に読み込まれるのでVisual Studioを再起動する必要はない。%0a%3c %0a%3c !V8とChromium%0a%3c V8はデバッグをサポートする豊富なコマンドラインフラグを持っている。Chromiumのコマンドラインで@@--js-flags@@経由で渡すことができる。%0a%3c  [=%0a%3c chrome.exe --js-flags="--trace_exception --heap_stats"%0a%3c =]%0a%3c このコマンドラインフラグはデバッグ版のV8にしか存在しない。すべてのV8フラグを見るには以下を行う。%0a%3c  [=%0a%3c chrome.exe --js-flags="--help"%0a%3c =]%0a%3c !グラフィックのデバッグ%0a%3c レンダリングのGPU加速はツールを使って容易にデバッグできる。以下を参照%0a%3c *[[Visual Studio 2013でグラフィックデバッグ]]%0a%3c *[[NVIDIA NSightでグラフィックデバッグ]]%0a%3c %0a%3c !他のマシンでデバッグ%0a%3c 他のマシンにデバッグ環境を構築すると有益なこともある。他のマシン（デバッグマシン）にデバッグ環境を構築するには最初にビルドマシンで@@mini_installerターゲットをビルドする。（@@ninja -C out\Debug mini_installer@@）。次にデバッグマシンで以下の事を行う。%0a%3c *ビルドマシンのビルドボリュームをマウントするかUNCで見えるようにする。%0a%3c *コマンドプロンプトを開き、ローカルディスクに移動する。%0a%3c *@@src\tools\win\copy-installer.bat@@を先ほどのマウントポイントから実行する。これはインストーラやDLL、PDBをデバッグマシンの@@C:\out@@または@@C:\build@@にコピーする（コンポーネントビルドしたかどうかで異なる）。%0a%3c *@@C:\out\Debug\mini_installer.exe@@を必要ならフラグを添えて実行し、タスクマネージャでインストーラがchrome.exeを実行するまで監視。%0a%3c *@@_NT_SYMBOL_PATH@@に@@C:\out\Debug@@を追加する。%0a%3c %0a%3c @@copy_installer.bat@@の最初に書いてある文書を読むこと。このファイルは再度実行しても問題ない。%0a%3c %0a%3c !メモリリークを見つける%0a%3c Windowsのヒープマネージャは役立つデバッグフラグを持っている。すべてのメモリ割り当てのスタックトレースをキャプチャする。WinDbgとUMDHでこれらスタックとレースをプロセスからscrapeできる。%0a%3c %0a%3c UMDHは偉大。ヒープ状態のスナップショットをキャプチャし、スタックトレースをシンボル化し使用集計をユニークスタックトレースへまとめる。%0a%3c %0a%3c gflagsをつかってユーザスタックトレースデータベースを有効にできる。とても遅くなるがブラウザプロセスだけやればよい。%0a%3c %0a%3c @@"!gflag"@@デバッグ拡張でユーザスタックデータベースを有効にできるが、ブレークポイントがヒットした時点ではすでに遅い。正しいやり方は以下。%0a%3c #@@GFlags.exe@@を起動%0a%3c #（イメージごとの）ユーザスタックトレースデータベースを有効に%0a%3c #デバッガー下でChromeを起動%0a%3c #chrome.dllがロードしたときブレークするブレークポインタを設定 @@"sxe ld chrome.dll"@@%0a%3c #ステップ実行しChrome.dllを初期化%0a%3c #@@GFlags.exe@@でスタックトレースデータベースを無効化%0a%3c #chromeを継続実行し、必要ならデバッガから切り離す%0a%3c %0a%3c https://www.chromium.org/_/rsrc/1480103082209/developers/how-tos/debugging-on-windows/gflags.png"GFlags.exe" | @@GFlags.exe@@でユーザモードスタックトレースデータベースを設定%0a%3c %0a%3c ブラウザのメモリリークで困っているなら、以下のコマンドでダンプを吐き出す。%0a%3c  [=%0a%3c umdh -p:%3cmy browser pid> > chrome-browser-leak-umdh-dump.txt%0a%3c =]%0a%3c 典型的には「ささいな」犯人が見つかる。%0a%3c %0a%3c !その他いろいろ%0a%3c *[[http://www.microsoft.com/downloads/details.aspx?FamilyID=bd02c19c-1250-433c-8c1b-2619bd93b3a2&displaylang=en|アプリケーションべりファイア]]はマイクロソフトのフリーツール。ツールの実行にはサンドボックスの無効化が必要（@@--no-sandbox@@）。そうしてアプリが認証したプロセスをデバッガで実行する。つまりレンダープロセスやプラグインプロセスはデバッガで実行する必要がある、そうしないと変な風になる。上述した方法でアタッチする必要がある。%0a%3c %0a%3c *@@CreateFile()@@にブレークポイントを設定するには以下のようにする。%0a%3c  [=%0a%3c {,,kernel32.dll}_CreateFileW@28%0a%3c ]=%0a%3c **@@{,,kernel32.dll}@@はDLLを指定する（コンテキストオペレータ）。%0a%3c **@@_@@プリフィックスはextern "C"を意味する。%0a%3c **@28は@@_stdcall@@を意味する。関数の終わりでスタックがポップする。つまり引数のバイト数。%0a%3c *SysInternalsのDebugViewや[[https://github.com/google/sawbuck/releases/latest|sawbuck]]で通常POSIXではstderrへいくLOG()メッセージを見れる。%0a%3c %0a%3c %0a
host:1532466245=192.168.3.2
