version=pmwiki-2.2.102 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko
author=
charset=UTF-8
csum=
ctime=1502858835
host=192.168.3.2
name=開発者向け.プロセス間通信
rev=20
targets=開発者向け.マルチプロセスアーキテクチャ,開発者向け.IPCの安全性情報,開発者向け.マルチプロセスリソースローディング
text=[[https://www.chromium.org/developers/design-documents/inter-process-communication|オリジナル]]%0a%0a!!全体像%0aChromiumは[[マルチプロセスアーキテクチャ]]で多くのプロセスもち、それぞれが通信する。基本的に名前付きパイプを使う。LinuxやOS Xでは'''socketpair()'''を使う。通信は非同期でおこわなれる。%0a%0a安全はIPC端点を書くには[[IPCの安全性情報]]を参照。%0a%0a!!ブラウザ内でのIPC%0aブラウザとレンダラの通信は分離されたIOスレッドで行う。メッセージは'''ChannelProxy'''を通じて送受信される。利点としては重たくなるリソース要求（ウェブページなど）がIOスレッドで行われUIがブロックしなくなること。'''RenderProcessHost'''により'''ChannelProxy::MessageFilter'''がインストールされ、このフィルターはIOで動き、リソース要求を横取りし、それをリソースディスパッチャーへ転送する。詳しくは[[マルチプロセスリソースローディング]]を参照。%0a%0a!!レンダラでのIPC%0aそれぞれのレンダラもメッセージを処理するスレッドを持つ（ここの場合はメインスレッド）。レンダリングや他の処理は別スレッドで行う。ほとんどのメッセージはブラウザから送られ、メインスレッドを通じてWebKitに到達する、逆も真。さらに同期通信を行うスレッドもある。%0a%0a!メッセージ%0a!!メッセージの種類%0a大きく'''routed'''と'''control'''の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスは'''MessageRouter'''オブジェクトを持ち、それを登録する。%0a%0a例えばレンダリング中、controlメッセージは特定のビュー対象ではなく、'''RenderProcess'''（レンダラ側）や'''RenderProcessHost'''（ブラウザ側）で処理される。リソース要求やクリップボード操作はビュー特定の操作でないのでcontrolメッセージで行う。routedメッセージの例はビューに対する描画要求である。%0a%0aこれとは別の切り方はどちらからどちらへ送られるかで分ける場合。ドキュメントフレーム関連のメッセージがブラウザから送られれば、Frameメッセージと呼ばれる。なぜならそれは'''RenderFrame'''へ送られるから。逆の場合は'''FrameHost'''メッセージと呼ばれる。[[https://code.google.com/p/chromium/codesearch#chromium/src/content/common/frame_messages.h|frame_messages.h]]を見れば２つのセクションがあり、'''Frame'''と'''FrameHost'''で分けられている。%0a%0aビューやプラグインでも同様に'''View,ViewHost'''そして'''PluginProcess,PluginProcessHost'''となる。%0a%0a!メッセージの宣言%0aマクロが使われる。レンダラからブラウザへのroutedメッセージで引数にURLとintがある場合、以下のようになる。%0a%0a=cpp [= IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int) =]%0a%0a%0aブラウザからレンダラへのコントロールメッセージは以下のように宣言される。%0a%0a=cpp [= IPC_MESSAGE_CONTROL0(FrameMsg_MyMessage) =]%0a%0a!!値を塩漬け%0aパラメータは'''ParamTraits'''テンプレートでメッセージ本文にシリアサイズされる。この場合、テンプレートの特殊化でほとんどの型はすでに定義されている（'''ipc_message_utils.h'''）。自分で型を定義した場合は、その型の'''ParamTraits'''を定義しなければならない。%0a%0aメッセージが非常に多くの値を持つことがある。この場合、値を保持する構造体をつくる。例えば'''FrameMsg_Navigate'''メッセージだと、'''CommonNavigationParams'''構造体が定義される（'''navigation_params.h'''）。'''frame_message.h'''は'''ParamTraits'''の特殊化を定義する、このとき'''IPC_STRUCT_TRAITS'''マクロが使われる。%0a%0a!!メッセージの送信%0aメッセージは'''チャネル'''（下記参照）を通じて送られる。ブラウザでは、'''RenderProcessHost'''がチャネルを保持し、ブラウザのUIスレッドからレンダラへメッセージが送られる。'''RenderWidgetHost'''（'''RenderViewHost'''の基底クラス）は使うのに便利な'''Send'''関数を提供する。%0a%0aメッセージはポインタを使って送られ、配達されたあとIPCレイヤによってdeleteされる。よって適切な'''Send'''関数を見つけたら、'''new'''を使って送信する。%0a%0a=cpp [= Send(new ViewMsg_StopFinding(routing_id)); =]%0a%0aメッセージが適切なView/ViewHostへルートされるようにrouting IDを指定する。'''RenderWidgetHost'''（'''RenderViewHost'''の基底クラス）と'''RenderWidget'''（'''RenderView'''の基底クラス）は'''GetRoutingID()'''メンバをもつ。%0a%0a!!メッセージハンドリング%0aインタフェース"IPC::Listener"を実装することでメッセージをハンドリングする。最も重要な関数は'''OnMessageReceived'''。これを実装するための多様なマクロが用意されている。以下を例を参照。%0a%0a=cpp [=%0aMyClass::OnMessageReceived(const IPC::Message& message) {%0a  IPC_BEGIN_MESSAGE_MAP(MyClass, message)%0a    // Will call OnMyMessage with the message. The parameters of the message will be unpacked for you.%0a    IPC_MESSAGE_HANDLER(ViewHostMsg_MyMessage, OnMyMessage)  %0a    ...%0a    IPC_MESSAGE_UNHANDLED_ERROR()  // This will throw an exception for unhandled messages.%0a  IPC_END_MESSAGE_MAP()%0a}%0a%0a// This function will be called with the parameters extracted from the ViewHostMsg_MyMessage message.%0aMyClass::OnMyMessage(const GURL& url, int something) {%0a  ...%0a}%0a=]%0a'''IPC_DEFINE_MESSAGE_MAP'''を使って関数を実装することもできる。この場合、メッセージ変数名を指定しない。与えられたクラスの'''OnMessageReceived'''関数を宣言し実装する。%0a%0a他のマクロ：%0a*'''OPC_MESSAGE_FORWARD''':これは'''IPC_MESSAGE_HANDLER'''と同じだが自分のクラスを指定しメッセージを受け取れる。通常は現在のクラスに送られる。%0a%0a=cpp [= IPC_MESSAGE_FORWARD(ViewHostMsg_MyMessage, some_object_pointer, SomeObject::OnMyMessage) =]%0a%0a*'''OPC_MESSAGE_HANDLER_GENERIC''':これは自分でコードを書ける。しかし自分でメッセージパラメータをアンパックしなければならない：%0a%0a=cpp [= IPC_MESSAGE_HANDLER_GENERIC(ViewHostMsg_MyMessage, printf("Hello, world, I got the message.")) =]%0a%0a!!セキュリティの考慮%0aIPCのセキュリティバグは[[https://blog.chromium.org/2012/05/tale-of-two-pwnies-part-1.html|ひどい]]結果をもたらす（ファイル窃盗、サンドボックス脱出、リモートコード実行）。[[https://www.chromium.org/Home/chromium-security/education/security-tips-for-ipc|IPCのセキュリティ]]を調べて、落とし穴に落ちないように。%0a%0a!チャネル%0a
time=1527925834
author:1527925834=
diff:1527925834:1527925719:=4,5c4,5%0a%3c Chromiumは[[マルチプロセスアーキテクチャ]]で多くのプロセスもち、それぞれが通信する。基本的に名前付きパイプを使う。LinuxやOS Xでは'''socketpair()'''を使う。通信は非同期でおこわなれる。%0a%3c %0a---%0a> Chromiumは[[マルチプロセスアーキテクチャ]]で多くのプロセスもち、それぞれが通信する。基本的に名前付きパイプを使う。LinuxやOS Xではsocketpair()を使う。通信は非同期でおこわなれる。%0a> %0a9,10c9,10%0a%3c ブラウザとレンダラの通信は分離されたIOスレッドで行う。メッセージは'''ChannelProxy'''を通じて送受信される。利点としては重たくなるリソース要求（ウェブページなど）がIOスレッドで行われUIがブロックしなくなること。'''RenderProcessHost'''により'''ChannelProxy::MessageFilter'''がインストールされ、このフィルターはIOで動き、リソース要求を横取りし、それをリソースディスパッチャーへ転送する。詳しくは[[マルチプロセスリソースローディング]]を参照。%0a%3c %0a---%0a> ブラウザとレンダラの通信は分離されたIOスレッドで行う。メッセージはChannelProxyを通じて送受信される。利点としては重たくなるリソース要求（ウェブページなど）がIOスレッドで行われUIがブロックしなくなること。RenderProcessHostによりChannelProxy::MessageFilterがインストールされ、このフィルターはIOで動き、リソース要求を横取りし、それをリソースディスパッチャーへ転送する。詳しくは[[マルチプロセスリソースローディング]]を参照。%0a> %0a16,22c16,22%0a%3c 大きく'''routed'''と'''control'''の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスは'''MessageRouter'''オブジェクトを持ち、それを登録する。%0a%3c %0a%3c 例えばレンダリング中、controlメッセージは特定のビュー対象ではなく、'''RenderProcess'''（レンダラ側）や'''RenderProcessHost'''（ブラウザ側）で処理される。リソース要求やクリップボード操作はビュー特定の操作でないのでcontrolメッセージで行う。routedメッセージの例はビューに対する描画要求である。%0a%3c %0a%3c これとは別の切り方はどちらからどちらへ送られるかで分ける場合。ドキュメントフレーム関連のメッセージがブラウザから送られれば、Frameメッセージと呼ばれる。なぜならそれは'''RenderFrame'''へ送られるから。逆の場合は'''FrameHost'''メッセージと呼ばれる。[[https://code.google.com/p/chromium/codesearch#chromium/src/content/common/frame_messages.h|frame_messages.h]]を見れば２つのセクションがあり、'''Frame'''と'''FrameHost'''で分けられている。%0a%3c %0a%3c ビューやプラグインでも同様に'''View,ViewHost'''そして'''PluginProcess,PluginProcessHost'''となる。%0a---%0a> 大きく'''routed'''と'''control'''の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスはMessageRouterオブジェクトを持ち、それを登録する。%0a> %0a> 例えばレンダリング中、controlメッセージは特定のビュー対象ではなく、RenderProcess（レンダラ側）やRenderProcessHost（ブラウザ側）で処理される。リソース要求やクリップボード操作はビュー特定の操作でないのでcontrolメッセージで行う。routedメッセージの例はビューに対する描画要求である。%0a> %0a> これとは別の切り方はどちらからどちらへ送られるかで分ける場合。ドキュメントフレーム関連のメッセージがブラウザから送られれば、Frameメッセージと呼ばれる。なぜならそれはRenderFrameへ送られるから。逆の場合はFrameHostメッセージと呼ばれる。[[https://code.google.com/p/chromium/codesearch#chromium/src/content/common/frame_messages.h|frame_messages.h]]を見れば２つのセクションがあり、FrameとFrameHostで分けられている。%0a> %0a> ビューやプラグインでも同様にView,ViewHostそしてPluginProcess,PluginProcessHostとなる。%0a
host:1527925834=192.168.3.2
author:1527925719=
diff:1527925719:1527925515:=16,17c16,17%0a%3c 大きく'''routed'''と'''control'''の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスはMessageRouterオブジェクトを持ち、それを登録する。%0a%3c %0a---%0a> 大きく"routed"と"control"の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスはMessageRouterオブジェクトを持ち、それを登録する。%0a> %0a35,38c35,38%0a%3c パラメータは'''ParamTraits'''テンプレートでメッセージ本文にシリアサイズされる。この場合、テンプレートの特殊化でほとんどの型はすでに定義されている（'''ipc_message_utils.h'''）。自分で型を定義した場合は、その型の'''ParamTraits'''を定義しなければならない。%0a%3c %0a%3c メッセージが非常に多くの値を持つことがある。この場合、値を保持する構造体をつくる。例えば'''FrameMsg_Navigate'''メッセージだと、'''CommonNavigationParams'''構造体が定義される（'''navigation_params.h'''）。'''frame_message.h'''は'''ParamTraits'''の特殊化を定義する、このとき'''IPC_STRUCT_TRAITS'''マクロが使われる。%0a%3c %0a---%0a> パラメータは'''ParamTraits'''テンプレートでメッセージ本文にシリアサイズされる。この場合、テンプレートの特殊化でほとんどの型はすでに定義されている（''ipc_message_utils.h''）。自分で型を定義した場合は、その型の"ParamTraits"を定義しなければならない。%0a> %0a> メッセージが非常に多くの値を持つことがある。この場合、値を保持する構造体をつくる。例えば"FrameMsg_Navigate"メッセージだと、"CommonNavigationParams"構造体が定義される（"navigation_params.h"）。"frame_message.h"は"ParamTraits"の特殊化を定義する、このとき"IPC_STRUCT_TRAITS"マクロが使われる。%0a> %0a40,43c40,43%0a%3c メッセージは'''チャネル'''（下記参照）を通じて送られる。ブラウザでは、'''RenderProcessHost'''がチャネルを保持し、ブラウザのUIスレッドからレンダラへメッセージが送られる。'''RenderWidgetHost'''（'''RenderViewHost'''の基底クラス）は使うのに便利な'''Send'''関数を提供する。%0a%3c %0a%3c メッセージはポインタを使って送られ、配達されたあとIPCレイヤによってdeleteされる。よって適切な'''Send'''関数を見つけたら、'''new'''を使って送信する。%0a%3c %0a---%0a> メッセージは""チャネル""（下記参照）を通じて送られる。ブラウザでは、"RenderProcessHost"がチャネルを保持し、ブラウザのUIスレッドからレンダラへメッセージが送られる。"RenderWidgetHost"（"RenderViewHost"の基底クラス）は使うのに便利な"Send"関数を提供する。%0a> %0a> メッセージはポインタを使って送られ、配達されたあとIPCレイヤによってdeleteされる。よって適切な"Send"関数を見つけたら、"new"を使って送信する。%0a> %0a46,47c46,47%0a%3c メッセージが適切なView/ViewHostへルートされるようにrouting IDを指定する。'''RenderWidgetHost'''（'''RenderViewHost'''の基底クラス）と'''RenderWidget'''（'''RenderView'''の基底クラス）は'''GetRoutingID()'''メンバをもつ。%0a%3c %0a---%0a> メッセージが適切なView/ViewHostへルートされるようにrouting IDを指定する。"RenderWidgetHost"（"RenderViewHost"の基底クラス）と"RenderWidget"（"RenderView"の基底クラス）は"GetRoutingID()"メンバをもつ。%0a> %0a49,50c49,50%0a%3c インタフェース"IPC::Listener"を実装することでメッセージをハンドリングする。最も重要な関数は'''OnMessageReceived'''。これを実装するための多様なマクロが用意されている。以下を例を参照。%0a%3c %0a---%0a> インタフェース"IPC::Listener"を実装することでメッセージをハンドリングする。最も重要な関数は"OnMessageReceived"。これを実装するための多様なマクロが用意されている。以下を例を参照。%0a> %0a66,67c66,67%0a%3c '''IPC_DEFINE_MESSAGE_MAP'''を使って関数を実装することもできる。この場合、メッセージ変数名を指定しない。与えられたクラスの'''OnMessageReceived'''関数を宣言し実装する。%0a%3c %0a---%0a> "IPC_DEFINE_MESSAGE_MAP"を使って関数を実装することもできる。この場合、メッセージ変数名を指定しない。与えられたクラスの"OnMessageReceived"関数を宣言し実装する。%0a> %0a69,70c69,70%0a%3c *'''OPC_MESSAGE_FORWARD''':これは'''IPC_MESSAGE_HANDLER'''と同じだが自分のクラスを指定しメッセージを受け取れる。通常は現在のクラスに送られる。%0a%3c %0a---%0a> *"OPC_MESSAGE_FORWARD":これは"IPC_MESSAGE_HANDLER"と同じだが自分のクラスを指定しメッセージを受け取れる。通常は現在のクラスに送られる。%0a> %0a73c73%0a%3c *'''OPC_MESSAGE_HANDLER_GENERIC''':これは自分でコードを書ける。しかし自分でメッセージパラメータをアンパックしなければならない：%0a---%0a> *"OPC_MESSAGE_HANDLER_GENERIC":これは自分でコードを書ける。しかし自分でメッセージパラメータをアンパックしなければならない：%0a
host:1527925719=192.168.3.2
author:1527925515=
diff:1527925515:1527925488:=31d30%0a%3c %0a35c34%0a%3c パラメータは'''ParamTraits'''テンプレートでメッセージ本文にシリアサイズされる。この場合、テンプレートの特殊化でほとんどの型はすでに定義されている（''ipc_message_utils.h''）。自分で型を定義した場合は、その型の"ParamTraits"を定義しなければならない。%0a---%0a> パラメータは"ParamTraits"テンプレートでメッセージ本文にシリアサイズされる。この場合、テンプレートの特殊化でほとんどの型はすでに定義されている（''ipc_message_utils.h''）。自分で型を定義した場合は、その型の"ParamTraits"を定義しなければならない。%0a
host:1527925515=192.168.3.2
author:1527925488=
diff:1527925488:1527925465:=26d25%0a%3c %0a31c30%0a%3c =cpp [= IPC_MESSAGE_CONTROL0(FrameMsg_MyMessage) =]%0a---%0a> [= IPC_MESSAGE_CONTROL0(FrameMsg_MyMessage) =]%0a
host:1527925488=192.168.3.2
author:1527925465=
diff:1527925465:1527925436:=26,28c26,28%0a%3c =cpp [= IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int) =]%0a%3c %0a%3c %0a---%0a> [= IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int) =]%0a> %0a> %0a69,70c69,70%0a%3c =cpp [= IPC_MESSAGE_FORWARD(ViewHostMsg_MyMessage, some_object_pointer, SomeObject::OnMyMessage) =]%0a%3c %0a---%0a> [= IPC_MESSAGE_FORWARD(ViewHostMsg_MyMessage, some_object_pointer, SomeObject::OnMyMessage) =]%0a> %0a73c73%0a%3c =cpp [= IPC_MESSAGE_HANDLER_GENERIC(ViewHostMsg_MyMessage, printf("Hello, world, I got the message.")) =]%0a---%0a> [= IPC_MESSAGE_HANDLER_GENERIC(ViewHostMsg_MyMessage, printf("Hello, world, I got the message.")) =]%0a
host:1527925465=192.168.3.2
author:1527925436=
diff:1527925436:1527925402:=42c42%0a%3c =cpp [= Send(new ViewMsg_StopFinding(routing_id)); =]%0a---%0a> [= Send(new ViewMsg_StopFinding(routing_id)); =]%0a
host:1527925436=192.168.3.2
author:1527925402=
diff:1527925402:1527920048:=33c33%0a%3c パラメータは"ParamTraits"テンプレートでメッセージ本文にシリアサイズされる。この場合、テンプレートの特殊化でほとんどの型はすでに定義されている（''ipc_message_utils.h''）。自分で型を定義した場合は、その型の"ParamTraits"を定義しなければならない。%0a---%0a> パラメータは"ParamTraits"テンプレートでメッセージ本文にシリアサイズされる。この場合、テンプレートの特殊化でほとんどの型はすでに定義されている（"ipc_message_utils.h"）。自分で型を定義した場合は、その型の"ParamTraits"を定義しなければならない。%0a
host:1527925402=192.168.3.2
author:1527920048=
diff:1527920048:1527919689:=32c32%0a%3c !!値を塩漬け%0a---%0a> !値を塩漬けに%0a37c37%0a%3c !!メッセージの送信%0a---%0a> !メッセージの送信%0a46c46%0a%3c !!メッセージハンドリング%0a---%0a> !メッセージハンドリング%0a75,78c75,76%0a%3c !!セキュリティの考慮%0a%3c IPCのセキュリティバグは[[https://blog.chromium.org/2012/05/tale-of-two-pwnies-part-1.html|ひどい]]結果をもたらす（ファイル窃盗、サンドボックス脱出、リモートコード実行）。[[https://www.chromium.org/Home/chromium-security/education/security-tips-for-ipc|IPCのセキュリティ]]を調べて、落とし穴に落ちないように。%0a%3c %0a%3c !チャネル%0a---%0a> !セキュリティの考慮%0a> IPCのセキュリティバグは[[https://blog.chromium.org/2012/05/tale-of-two-pwnies-part-1.html|ひどい]]結果をもたらす。%0a\ No newline at end of file%0a
host:1527920048=192.168.3.2
author:1527919689=
diff:1527919689:1527919078:=64,76d63%0a%3c "IPC_DEFINE_MESSAGE_MAP"を使って関数を実装することもできる。この場合、メッセージ変数名を指定しない。与えられたクラスの"OnMessageReceived"関数を宣言し実装する。%0a%3c %0a%3c 他のマクロ：%0a%3c *"OPC_MESSAGE_FORWARD":これは"IPC_MESSAGE_HANDLER"と同じだが自分のクラスを指定しメッセージを受け取れる。通常は現在のクラスに送られる。%0a%3c %0a%3c [= IPC_MESSAGE_FORWARD(ViewHostMsg_MyMessage, some_object_pointer, SomeObject::OnMyMessage) =]%0a%3c %0a%3c *"OPC_MESSAGE_HANDLER_GENERIC":これは自分でコードを書ける。しかし自分でメッセージパラメータをアンパックしなければならない：%0a%3c %0a%3c [= IPC_MESSAGE_HANDLER_GENERIC(ViewHostMsg_MyMessage, printf("Hello, world, I got the message.")) =]%0a%3c %0a%3c !セキュリティの考慮%0a%3c IPCのセキュリティバグは[[https://blog.chromium.org/2012/05/tale-of-two-pwnies-part-1.html|ひどい]]結果をもたらす。%0a\ No newline at end of file%0a
host:1527919689=192.168.3.2
author:1527919078=
diff:1527919078:1527919016:=49c49%0a%3c =cpp [=%0a---%0a> [=%0a
host:1527919078=192.168.3.2
author:1527919016=
diff:1527919016:1527918598:=44,63d43%0a%3c メッセージが適切なView/ViewHostへルートされるようにrouting IDを指定する。"RenderWidgetHost"（"RenderViewHost"の基底クラス）と"RenderWidget"（"RenderView"の基底クラス）は"GetRoutingID()"メンバをもつ。%0a%3c %0a%3c !メッセージハンドリング%0a%3c インタフェース"IPC::Listener"を実装することでメッセージをハンドリングする。最も重要な関数は"OnMessageReceived"。これを実装するための多様なマクロが用意されている。以下を例を参照。%0a%3c %0a%3c [=%0a%3c MyClass::OnMessageReceived(const IPC::Message& message) {%0a%3c   IPC_BEGIN_MESSAGE_MAP(MyClass, message)%0a%3c     // Will call OnMyMessage with the message. The parameters of the message will be unpacked for you.%0a%3c     IPC_MESSAGE_HANDLER(ViewHostMsg_MyMessage, OnMyMessage)  %0a%3c     ...%0a%3c     IPC_MESSAGE_UNHANDLED_ERROR()  // This will throw an exception for unhandled messages.%0a%3c   IPC_END_MESSAGE_MAP()%0a%3c }%0a%3c %0a%3c // This function will be called with the parameters extracted from the ViewHostMsg_MyMessage message.%0a%3c MyClass::OnMyMessage(const GURL& url, int something) {%0a%3c   ...%0a%3c }%0a%3c =]%0a
host:1527919016=192.168.3.2
author:1527918598=
diff:1527918598:1527917675:=31,43d30%0a%3c %0a%3c !値を塩漬けに%0a%3c パラメータは"ParamTraits"テンプレートでメッセージ本文にシリアサイズされる。この場合、テンプレートの特殊化でほとんどの型はすでに定義されている（"ipc_message_utils.h"）。自分で型を定義した場合は、その型の"ParamTraits"を定義しなければならない。%0a%3c %0a%3c メッセージが非常に多くの値を持つことがある。この場合、値を保持する構造体をつくる。例えば"FrameMsg_Navigate"メッセージだと、"CommonNavigationParams"構造体が定義される（"navigation_params.h"）。"frame_message.h"は"ParamTraits"の特殊化を定義する、このとき"IPC_STRUCT_TRAITS"マクロが使われる。%0a%3c %0a%3c !メッセージの送信%0a%3c メッセージは""チャネル""（下記参照）を通じて送られる。ブラウザでは、"RenderProcessHost"がチャネルを保持し、ブラウザのUIスレッドからレンダラへメッセージが送られる。"RenderWidgetHost"（"RenderViewHost"の基底クラス）は使うのに便利な"Send"関数を提供する。%0a%3c %0a%3c メッセージはポインタを使って送られ、配達されたあとIPCレイヤによってdeleteされる。よって適切な"Send"関数を見つけたら、"new"を使って送信する。%0a%3c %0a%3c [= Send(new ViewMsg_StopFinding(routing_id)); =]%0a%3c %0a
host:1527918598=192.168.3.2
author:1527917675=
diff:1527917675:1527917407:=29,30c29%0a%3c ブラウザからレンダラへのコントロールメッセージは以下のように宣言される。%0a%3c [= IPC_MESSAGE_CONTROL0(FrameMsg_MyMessage) =]%0a---%0a> %0a
host:1527917675=192.168.3.2
author:1527917407=
diff:1527917407:1502860576:=1,2d0%0a%3c [[https://www.chromium.org/developers/design-documents/inter-process-communication|オリジナル]]%0a%3c %0a29c27%0a%3c %0a---%0a> [[https://www.chromium.org/developers/design-documents/inter-process-communication|オリジナル]]%0a
host:1527917407=192.168.3.2
author:1502860576=
diff:1502860576:1502860441:=1,27d0%0a%3c !!全体像%0a%3c Chromiumは[[マルチプロセスアーキテクチャ]]で多くのプロセスもち、それぞれが通信する。基本的に名前付きパイプを使う。LinuxやOS Xではsocketpair()を使う。通信は非同期でおこわなれる。%0a%3c %0a%3c 安全はIPC端点を書くには[[IPCの安全性情報]]を参照。%0a%3c %0a%3c !!ブラウザ内でのIPC%0a%3c ブラウザとレンダラの通信は分離されたIOスレッドで行う。メッセージはChannelProxyを通じて送受信される。利点としては重たくなるリソース要求（ウェブページなど）がIOスレッドで行われUIがブロックしなくなること。RenderProcessHostによりChannelProxy::MessageFilterがインストールされ、このフィルターはIOで動き、リソース要求を横取りし、それをリソースディスパッチャーへ転送する。詳しくは[[マルチプロセスリソースローディング]]を参照。%0a%3c %0a%3c !!レンダラでのIPC%0a%3c それぞれのレンダラもメッセージを処理するスレッドを持つ（ここの場合はメインスレッド）。レンダリングや他の処理は別スレッドで行う。ほとんどのメッセージはブラウザから送られ、メインスレッドを通じてWebKitに到達する、逆も真。さらに同期通信を行うスレッドもある。%0a%3c %0a%3c !メッセージ%0a%3c !!メッセージの種類%0a%3c 大きく"routed"と"control"の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスはMessageRouterオブジェクトを持ち、それを登録する。%0a%3c %0a%3c 例えばレンダリング中、controlメッセージは特定のビュー対象ではなく、RenderProcess（レンダラ側）やRenderProcessHost（ブラウザ側）で処理される。リソース要求やクリップボード操作はビュー特定の操作でないのでcontrolメッセージで行う。routedメッセージの例はビューに対する描画要求である。%0a%3c %0a%3c これとは別の切り方はどちらからどちらへ送られるかで分ける場合。ドキュメントフレーム関連のメッセージがブラウザから送られれば、Frameメッセージと呼ばれる。なぜならそれはRenderFrameへ送られるから。逆の場合はFrameHostメッセージと呼ばれる。[[https://code.google.com/p/chromium/codesearch#chromium/src/content/common/frame_messages.h|frame_messages.h]]を見れば２つのセクションがあり、FrameとFrameHostで分けられている。%0a%3c %0a%3c ビューやプラグインでも同様にView,ViewHostそしてPluginProcess,PluginProcessHostとなる。%0a%3c %0a%3c !メッセージの宣言%0a%3c マクロが使われる。レンダラからブラウザへのroutedメッセージで引数にURLとintがある場合、以下のようになる。%0a%3c [= IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int) =]%0a%3c %0a%3c %0a%3c [[https://www.chromium.org/developers/design-documents/inter-process-communication|オリジナル]]%0a
host:1502860576=192.168.0.2
author:1502860441=
diff:1502860441:1502860236:=0a1,27%0a> !!全体像%0a> Chromiumは[[マルチプロセスアーキテクチャ]]で多くのプロセスもち、それぞれが通信する。基本的に名前付きパイプを使う。LinuxやOS Xではsocketpair()を使う。通信は非同期でおこわなれる。%0a> %0a> 安全はIPC端点を書くには[[IPCの安全性情報]]を参照。%0a> %0a> !!ブラウザ内でのIPC%0a> ブラウザとレンダラの通信は分離されたIOスレッドで行う。メッセージはChannelProxyを通じて送受信される。利点としては重たくなるリソース要求（ウェブページなど）がIOスレッドで行われUIがブロックしなくなること。RenderProcessHostによりChannelProxy::MessageFilterがインストールされ、このフィルターはIOで動き、リソース要求を横取りし、それをリソースディスパッチャーへ転送する。詳しくは[[マルチプロセスリソースローディング]]を参照。%0a> %0a> !!レンダラでのIPC%0a> それぞれのレンダラもメッセージを処理するスレッドを持つ（ここの場合はメインスレッド）。レンダリングや他の処理は別スレッドで行う。ほとんどのメッセージはブラウザから送られ、メインスレッドを通じてWebKitに到達する、逆も真。さらに同期通信を行うスレッドもある。%0a> %0a> !メッセージ%0a> !!メッセージの種類%0a> 大きく"routed"と"control"の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスはMessageRouterオブジェクトを持ち、それを登録する。%0a> %0a> 例えばレンダリング中、controlメッセージは特定のビュー対象ではなく、RenderProcess（レンダラ側）やRenderProcessHost（ブラウザ側）で処理される。リソース要求やクリップボード操作はビュー特定の操作でないのでcontrolメッセージで行う。routedメッセージの例はビューに対する描画要求である。%0a> %0a> これとは別の切り方はどちらからどちらへ送られるかで分ける場合。ドキュメントフレーム関連のメッセージがブラウザから送られれば、Frameメッセージと呼ばれる。なぜならそれはRenderFrameへ送られるから。逆の場合はFrameHostメッセージと呼ばれる。[[https://code.google.com/p/chromium/codesearch#chromium/src/content/common/frame_messages.h|frame_messages.h]]を見れば２つのセクションがあり、FrameとFrameHostで分けられている。%0a> %0a> ビューやプラグインでも同様にView,ViewHostそしてPluginProcess,PluginProcessHostとなる。%0a> %0a> !メッセージの宣言%0a> マクロが使われる。レンダラからブラウザへのroutedメッセージで引数にURLとintがある場合、以下のようになる。%0a> [= IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int) =]%0a> %0a> %0a> [[https://www.chromium.org/developers/design-documents/inter-process-communication|オリジナル]]%0a\ No newline at end of file%0a
host:1502860441=192.168.0.2
author:1502860236=
diff:1502860236:1502860213:=
host:1502860236=192.168.0.2
author:1502860213=
diff:1502860213:1502859190:=26,27d25%0a%3c %0a%3c [[https://www.chromium.org/developers/design-documents/inter-process-communication|オリジナル]]%0a\ No newline at end of file%0a
host:1502860213=192.168.0.2
author:1502859190=
diff:1502859190:1502858835:=19,24d18%0a%3c %0a%3c ビューやプラグインでも同様にView,ViewHostそしてPluginProcess,PluginProcessHostとなる。%0a%3c %0a%3c !メッセージの宣言%0a%3c マクロが使われる。レンダラからブラウザへのroutedメッセージで引数にURLとintがある場合、以下のようになる。%0a%3c [= IPC_MESSAGE_ROUTED2(FrameHostMsg_MyMessage, GURL, int) =]%0a
host:1502859190=192.168.0.2
author:1502858835=
diff:1502858835:1502858835:=1,19d0%0a%3c !!全体像%0a%3c Chromiumは[[マルチプロセスアーキテクチャ]]で多くのプロセスもち、それぞれが通信する。基本的に名前付きパイプを使う。LinuxやOS Xではsocketpair()を使う。通信は非同期でおこわなれる。%0a%3c %0a%3c 安全はIPC端点を書くには[[IPCの安全性情報]]を参照。%0a%3c %0a%3c !!ブラウザ内でのIPC%0a%3c ブラウザとレンダラの通信は分離されたIOスレッドで行う。メッセージはChannelProxyを通じて送受信される。利点としては重たくなるリソース要求（ウェブページなど）がIOスレッドで行われUIがブロックしなくなること。RenderProcessHostによりChannelProxy::MessageFilterがインストールされ、このフィルターはIOで動き、リソース要求を横取りし、それをリソースディスパッチャーへ転送する。詳しくは[[マルチプロセスリソースローディング]]を参照。%0a%3c %0a%3c !!レンダラでのIPC%0a%3c それぞれのレンダラもメッセージを処理するスレッドを持つ（ここの場合はメインスレッド）。レンダリングや他の処理は別スレッドで行う。ほとんどのメッセージはブラウザから送られ、メインスレッドを通じてWebKitに到達する、逆も真。さらに同期通信を行うスレッドもある。%0a%3c %0a%3c !メッセージ%0a%3c !!メッセージの種類%0a%3c 大きく"routed"と"control"の２つ。controlメッセージはパイプを作成したクラスで処理される。このクラスは他のクラスがメッセージを受け取ることも可能にしていて、他のクラスはMessageRouterオブジェクトを持ち、それを登録する。%0a%3c %0a%3c 例えばレンダリング中、controlメッセージは特定のビュー対象ではなく、RenderProcess（レンダラ側）やRenderProcessHost（ブラウザ側）で処理される。リソース要求やクリップボード操作はビュー特定の操作でないのでcontrolメッセージで行う。routedメッセージの例はビューに対する描画要求である。%0a%3c %0a%3c これとは別の切り方はどちらからどちらへ送られるかで分ける場合。ドキュメントフレーム関連のメッセージがブラウザから送られれば、Frameメッセージと呼ばれる。なぜならそれはRenderFrameへ送られるから。逆の場合はFrameHostメッセージと呼ばれる。[[https://code.google.com/p/chromium/codesearch#chromium/src/content/common/frame_messages.h|frame_messages.h]]を見れば２つのセクションがあり、FrameとFrameHostで分けられている。%0a%3c %0a
host:1502858835=192.168.0.2
