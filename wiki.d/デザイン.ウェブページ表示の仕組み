version=pmwiki-2.2.107 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36
author=
charset=UTF-8
csum=
ctime=1530427033
host=192.168.3.2
name=デザイン.ウェブページ表示の仕組み
rev=9
targets=デザイン.マルチプロセスアーキテクチャ,デザイン.マルチプロセスリソースローディング,開発者向け.コンテントモジュール,HowTo.Chromiumソースコードへの取り掛かり
text=https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome%0a%0a'''Chromium'''がどのようにウェブページを表示するかをボトムアップに記述。[[マルチプロセスアーキテクチャ]]も読む。[[マルチプロセスリソースローディング]]も面白い。%0a%0a!概念的アプリケーションレイヤー%0a%0aAttach:s1UD_M3hHfzYDGIEg7yotXQ.png%0a(The original Google Doc for this illustration is http://goo.gl/MsEJX which is open for editing by any @chromium.org)%0a%0a%0a%0a各階層は概念的アプリケーションレイヤー。下位レイヤーは上位レイヤに依存せず情報も持たない。%0a*'''WebKit''': '''Safari''', '''Chromium'''その他'''WebKit'''ベースのブラウザで使われる共用レンダリングエンジン。'''Port'''はWebKitの一部でプラットフォーム依存のシステムサービス（リソースロードやグラフィック）を統合する。%0a*'''Glue''': '''WebKit'''の型を'''Chromium'''の型に変換する。これが我々の'''WebKit'''組み込みレイヤ。%0a*'''Renderer / Render host''': '''Chromium'''のマルチプロセス組み込みレイヤ。相互の通知やコマンドのプロキシ。%0a*'''WebContents''': '''Content'''モジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスの'''HTML'''レンダリングをビューへ容易に組み込み可能。[[開発者向け/コンテントモジュール]]のページ参照%0a*'''Browser''': ブラウザウインドウを表す。多数の'''WebContents'''からなる。%0a*'''Tab Helpers''': 個別のオブジェクトで'''WebContents'''と結びつく（'''WebContentsUserData'''混合）。ブラウザはこれらを'''WebContents'''に結び付ける（'''favicon'''や'''infobar'''など）%0a%0a!WebKit%0a我々はオープンソースの'''WebKit'''をウェブページのレイアウトに使っている。コードはアップルからプルされ、'''/third_party/WebKit'''ディレクトリにある。'''WebKit'''は主に'''WebCore'''から構成されコアレイアウト機能をもつ。'''Javascript'''を実行する'''JavaScriptCore'''ももつ。'''JavaScriptCore'''はテスト目的で実行する。通常これはハイパフォーマンスな'''V8 JavaScript'''エンジンに置き換えられている。Appleが'''WebKit'''と呼ぶレイヤで'''Safari'''などでは'''WebCore'''と'''OS X'''間の組み込みAPIは実際には使っていない。我々はAppleからプルしたコードを一般に'''WebKit'''と呼んでいる。%0a%0a!WebKit port%0a最下位に我々の'''WebKit "port"'''がある。プラットフォーム固有の機能の実装でプラットフォーム独立の'''WebCore'''とのインターフェースになる。ファイルは'''WebKit'''ツリーにあり、'''chromium'''ディレクトリまたは'''Chromium'''サフィックスのファイルである。フォントレンダリングなどはプラットフォームごとに処理されなければならない。%0a%0a*ネットワークトラフィックはマルチプロセスリソースローディングで処理され、レンダープロセスからOSを利用しない。%0a*グラフィックは'''Android'''用に開発された'''Skia'''グラフィックライブラリを利用する。これはクロスプラットフォームのグラフィックライブラリですべてのイメージと基本グラフィックを処理する（テキストは除く）。'''Skiaは/third_party/skia'''にある。%0a%0a!WebKit glue%0a'''Chromium'''と'''WebKit'''は型などを含め別のコーディングルールで記述されている。'''WebKit glue'''はその間に入り'''Chromium'''にとってやりやすいインターフェースを提供する。'''/WebKit/glue'''にある。ネーミングは'''WebKit'''オブジェクトと同じようになっているが'''"Web"'''が初めにつく。例えば'''WebCore::Frame'''は'''WebFrame'''になる。%0a%0a'''"test shell"'''はベアボーンのウェブブラウザで'''WebKit port'''と'''glue'''のテストをする。%0a%0a!レンダープロセス%0ahttps://www.chromium.org/_/rsrc/1342584100941/developers/design-documents/displaying-a-web-page-in-chrome/Renderingintherenderer-v2.png%0a'''Chromium'''のレンダープロセスは'''glue'''インタフェースを使い'''WebKit port'''を組み込む。多量のコードは含んでいない。その仕事はブラウザとの'''IPC'''チャネルのレンダラーサイドになることである。%0a%0aレンダラーのもっとも重要なクラスは'''RenderView'''である。'''/content/renderer/render_view_impl.cc'''にある。これがウェブページを表す。ブラウザから、またブラウザへのナビゲーション関連のコマンドを処理する。これは'''RenderWidget'''から継承されるがこれは描画や入力を処理する。'''RenderView'''はブラウザとの通信に（レンダープロセスごとに）グローバルな'''RenderProcess'''を使う。%0a%0a!FAQ:RenderWidgetとRenderViewの違いは？%0a'''RenderWidget'''は'''WebCore::Widget'''オブジェクトとマップされる。それは抽象インターフェース'''WebWidgetDelegate'''を実装することにより行う。'''RenderWidget'''は基本的に１つのウインドウであり、入力と受け取り、描画の出力になる。'''RenderView'''は'''RenderWidget'''から継承され、タブやポップアップウインドウのコンテンツになり、ナビゲーション関連の命令を受け取る。'''RenderView'''なしに'''RenderWidget'''が存在するケースが１つだけありウェブページ上のセレクトボックスである。%0a%0a!レンダラー内のスレッド%0aレンダラーは２つのスレッドを持つ。１つは'''RenderView'''や'''WebKit'''が動くものである。（途中）%0a%0a!ブラウザプロセス%0ahttps://www.chromium.org/_/rsrc/1220197831473/developers/design-documents/displaying-a-web-page-in-chrome/rendering%2520browser.png%0a%0a!下位レベルのブラウザプロセスのオブジェクト%0aブラウザのIOスレッド上でレンダープロセスとのIPC通信が行われる。このスレッド上ですべてのネットワーク通信も扱われる。%0a%0aメインスレッド（UIが動いている）で'''RenderProcessHost'''が初期化されるとき、新しくレンダラープロセスと'''ChannelProxy'''という'''IPC'''オブジェクト（名前付きパイプ）がつくられる。この'''IPC'''オブジェクトはブラウザの'''IO'''スレッドで動き、名前付きパイプをリッスンし、メッセージを'''RenderProcessHost'''に返す。'''ResourceMessageFilter'''がこのチャネルにインストールされれば、メッセージをフィルタ出来る。%0a%0a'''RenderProcessHost'''はビュー関連のメッセージを適切な'''RenderViewHost'''にディスパッチする責任がある。%0a%0a!上位レベルのブラウザプロセスのオブジェクト%0aビュー固有のメッセージは'''RenderViewHost::OnMessageReceived'''に到着する。ほとんどのメッセージはここで処理され残りは'''RenderWidgetHost'''へ回される。それぞれのプラットフォームでビュークラスがあり('''RenderWidgetHostView[Aura|Gtk|Mac|Win]''')、ネイティブのビューシステムを実装する。%0a%0a'''RenderView/Widget'''の上位に'''WebContents'''オブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。'''WebContents'''はウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[[開発者向け/コンテントモジュール]]のページを参照。%0a%0a'''WebContents'''オブジェクトは'''TabContentsWrapper'''に含まれる。'''chrome'''ディレクトリにありタブに責任を持つ。%0a%0a!イラストでの実例%0aナビゲーションやスタートアップのさらなる実例は[[HowTo/Chromiumソースコードへの取り掛かり]]を参照。%0a%0a!"set cursor"メッセージの生涯%0aカーソルの切り替えはレンダラーからブラウザへ送られる典型的メッセージである。レンダラでは以下のことが起こる。%0a*'''Set cursor'''メッセージは入力イベントへの応答として内部的に'''WebKit'''が生成する。'''set cursor'''メッセージは'''RenderWidget::SetCursor'''から始まる。%0a*それは'''RenderWidget::Send'''を呼び、メッセージをディスパッチする。このメソッドは'''RenderView'''からもブラウザにメッセージを送るために使用される。そして'''RenderThread::Send'''を呼ぶ。%0a*これは'''IPC::SyncChannel'''を呼びブラウザへ送られる。%0a%0aそしたらブラウザは次のことを行う。%0a*'''RenderProcessHost'''内にある'''IPC::ChannelProxy'''はIOスレッドでこのメッセージを受け取る。%0a*'''RenderProcessHost::OnMessageReceived'''がメッセージを受け取る。いくつかのメッセージはここで直接処理され、残りは'''RenderViewHost'''へ送られる。%0a*'''RenderViewHost::OnMessageReceived'''にメッセージが到着する。多くのメッセージはここで処理される、我々のメッセージはここでは処理されない。%0a*処理されなかったメッセージは自動的に'''RenderWidgetHost'''に送られる。我々のメッセージもここに送られる。%0a*メッセージマップがついにメッセージを受け取るり'''RenderWidgetHost::OnMsgSetCuror'''が呼ばれる。ここで適切なUI関数が呼ばれマウスカーソルがセットされる。%0a%0a!"mouse click"メッセージの生涯%0aマウスクリックメッセージはブラウザからレンダラーに送られる典型的メッセージ。%0a*'''RederWidgetHostViewWin::OnMouseEvent'''がブラウザの'''UI'''スレッドで呼ばれる。これは'''ForwardMouseEventToRenderer'''を呼ぶ。%0a*このときマウス入力をプラットフォーム独立な'''WebMouseEvent'''にまとめ、'''RenderWidgetHost'''に送る。%0a*'''RenderWidgetHost::ForwardInputEvent'''は'''IPC'''メッセージ'''ViewMsg_HandleInputEvent'''を作成、'''WebInputEvent'''をその中にシリアライズする。そして'''RenderWidgetHost::Send'''する。%0a*'''RenderProcessHost::Send'''に送られ'''IPC::ChannelProxy'''で送られる。%0a*内部的には'''IPC:ChannelProxy'''は'''IO'''スレッドへのプロキシで、そこで名前付きパイプでレンダラーに送られる。%0a%0a他のタイプのメッセージは'''WebContents'''で作成されることに注意。例えばナビゲーション関連など。'''WebContents'''から'''RenderViewHost'''へは同じような経路をたどる。%0a%0aそしてレンダラーでは：%0a*メインスレッドの'''IPC::Channel'''がメッセージを受信し、'''IPC::ChannelProxy'''がレンダラースレッドでのプロキシになる。%0a*'''RenderView::OnMessageReceived'''がメッセージを受け取る。多くのメッセージはここで処理される。ただしマウスクリックは別で、'''RenderWidget::OnMessageReceived'''に転送されその後'''RederWidget::OnHandleInputEvent'''へ転送される。%0a*'''WebWidgetImpl::HandleInputEvent'''へ進み、'''WebKit'''の'''PlatformMouseEvnet'''クラスへ変換される。その後、'''WebCore::Widget'''へ進む。%0a%0a
time=1531041208
author:1531041208=
diff:1531041208:1531040910:=32,33c32,33%0a%3c '''"test shell"'''はベアボーンのウェブブラウザで'''WebKit port'''と'''glue'''のテストをする。%0a%3c %0a---%0a> "test shell"はベアボーンのウェブブラウザでWebKit portとglueのテストをする。%0a> %0a36,39c36,39%0a%3c '''Chromium'''のレンダープロセスは'''glue'''インタフェースを使い'''WebKit port'''を組み込む。多量のコードは含んでいない。その仕事はブラウザとの'''IPC'''チャネルのレンダラーサイドになることである。%0a%3c %0a%3c レンダラーのもっとも重要なクラスは'''RenderView'''である。'''/content/renderer/render_view_impl.cc'''にある。これがウェブページを表す。ブラウザから、またブラウザへのナビゲーション関連のコマンドを処理する。これは'''RenderWidget'''から継承されるがこれは描画や入力を処理する。'''RenderView'''はブラウザとの通信に（レンダープロセスごとに）グローバルな'''RenderProcess'''を使う。%0a%3c %0a---%0a> Chromiumのレンダープロセスはglueインタフェースを使いWebKit portを組み込む。多量のコードは含んでいない。その仕事はブラウザとのIPCチャネルのレンダラーサイドになることである。%0a> %0a> レンダラーのもっとも重要なクラスはRenderViewである。/content/renderer/render_view_impl.ccにある。これがウェブページを表す。ブラウザから、またブラウザへのナビゲーション関連のコマンドを処理する。これはRenderWidgetから継承されるがこれは描画や入力を処理する。RenderViewはブラウザとの通信に（レンダープロセスごとに）グローバルなRenderProcessを使う。%0a> %0a41,42c41,42%0a%3c '''RenderWidget'''は'''WebCore::Widget'''オブジェクトとマップされる。それは抽象インターフェース'''WebWidgetDelegate'''を実装することにより行う。'''RenderWidget'''は基本的に１つのウインドウであり、入力と受け取り、描画の出力になる。'''RenderView'''は'''RenderWidget'''から継承され、タブやポップアップウインドウのコンテンツになり、ナビゲーション関連の命令を受け取る。'''RenderView'''なしに'''RenderWidget'''が存在するケースが１つだけありウェブページ上のセレクトボックスである。%0a%3c %0a---%0a> RenderWidgetはWebCore::Widgetオブジェクトとマップされる。それは抽象インターフェースWebWidgetDelegateを実装することにより行う。RenderWidgetは基本的に１つのウインドウであり、入力と受け取り、描画の出力になる。RenderViewはRenderWidgetから継承され、タブやポップアップウインドウのコンテンツになり、ナビゲーション関連の命令を受け取る。RenderViewなしにRenderWidgetが存在するケースが１つだけありウェブページ上のセレクトボックスである。%0a> %0a44,45c44,45%0a%3c レンダラーは２つのスレッドを持つ。１つは'''RenderView'''や'''WebKit'''が動くものである。（途中）%0a%3c %0a---%0a> レンダラーは２つのスレッドを持つ。１つはRenderViewやWebKitが動くものである。（途中）%0a> %0a52,55c52,55%0a%3c メインスレッド（UIが動いている）で'''RenderProcessHost'''が初期化されるとき、新しくレンダラープロセスと'''ChannelProxy'''という'''IPC'''オブジェクト（名前付きパイプ）がつくられる。この'''IPC'''オブジェクトはブラウザの'''IO'''スレッドで動き、名前付きパイプをリッスンし、メッセージを'''RenderProcessHost'''に返す。'''ResourceMessageFilter'''がこのチャネルにインストールされれば、メッセージをフィルタ出来る。%0a%3c %0a%3c '''RenderProcessHost'''はビュー関連のメッセージを適切な'''RenderViewHost'''にディスパッチする責任がある。%0a%3c %0a---%0a> メインスレッド（UIが動いている）でRenderProcessHostが初期化されるとき、新しくレンダラープロセスとChannelProxyというIPCオブジェクト（名前付きパイプ）がつくられる。このIPCオブジェクトはブラウザのIOスレッドで動き、名前付きパイプをリッスンし、メッセージをRenderProcessHostに返す。ResourceMessageFilterがこのチャネルにインストールされれば、メッセージをフィルタ出来る。%0a> %0a> RenderProcessHostはビュー関連のメッセージを適切なRenderViewHostにディスパッチする責任がある。%0a> %0a57,62c57,62%0a%3c ビュー固有のメッセージは'''RenderViewHost::OnMessageReceived'''に到着する。ほとんどのメッセージはここで処理され残りは'''RenderWidgetHost'''へ回される。それぞれのプラットフォームでビュークラスがあり('''RenderWidgetHostView[Aura|Gtk|Mac|Win]''')、ネイティブのビューシステムを実装する。%0a%3c %0a%3c '''RenderView/Widget'''の上位に'''WebContents'''オブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。'''WebContents'''はウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[[開発者向け/コンテントモジュール]]のページを参照。%0a%3c %0a%3c '''WebContents'''オブジェクトは'''TabContentsWrapper'''に含まれる。'''chrome'''ディレクトリにありタブに責任を持つ。%0a%3c %0a---%0a> ビュー固有のメッセージはRenderViewHost::OnMessageReceivedに到着する。ほとんどのメッセージはここで処理され残りはRenderWidgetHostへ回される。それぞれのプラットフォームでビュークラスがあり(RenderWidgetHostView[Aura|Gtk|Mac|Win])、ネイティブのビューシステムを実装する。%0a> %0a> RenderView/Widgetの上位にWebContentsオブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。WebContentsはウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[[開発者向け/コンテントモジュール]]のページを参照。%0a> %0a> WebContentsオブジェクトはTabContentsWrapperに含まれる。chromeディレクトリにありタブに責任を持つ。%0a> %0a68,71c68,71%0a%3c *'''Set cursor'''メッセージは入力イベントへの応答として内部的に'''WebKit'''が生成する。'''set cursor'''メッセージは'''RenderWidget::SetCursor'''から始まる。%0a%3c *それは'''RenderWidget::Send'''を呼び、メッセージをディスパッチする。このメソッドは'''RenderView'''からもブラウザにメッセージを送るために使用される。そして'''RenderThread::Send'''を呼ぶ。%0a%3c *これは'''IPC::SyncChannel'''を呼びブラウザへ送られる。%0a%3c %0a---%0a> *Set cursorメッセージは入力イベントへの応答として内部的にWebKitが生成する。set cursorメッセージはRenderWidget::SetCursorから始まる。%0a> *それはRenderWidget::Sendを呼び、メッセージをディスパッチする。このメソッドはRenderViewからもブラウザにメッセージを送るために使用される。そしてRenderThread::Sendを呼ぶ。%0a> *これはIPC::SyncChannelを呼びブラウザへ送られる。%0a> %0a73,78c73,78%0a%3c *'''RenderProcessHost'''内にある'''IPC::ChannelProxy'''はIOスレッドでこのメッセージを受け取る。%0a%3c *'''RenderProcessHost::OnMessageReceived'''がメッセージを受け取る。いくつかのメッセージはここで直接処理され、残りは'''RenderViewHost'''へ送られる。%0a%3c *'''RenderViewHost::OnMessageReceived'''にメッセージが到着する。多くのメッセージはここで処理される、我々のメッセージはここでは処理されない。%0a%3c *処理されなかったメッセージは自動的に'''RenderWidgetHost'''に送られる。我々のメッセージもここに送られる。%0a%3c *メッセージマップがついにメッセージを受け取るり'''RenderWidgetHost::OnMsgSetCuror'''が呼ばれる。ここで適切なUI関数が呼ばれマウスカーソルがセットされる。%0a%3c %0a---%0a> *RenderProcessHost内にあるIPC::ChannelProxyはIOスレッドでこのメッセージを受け取る。%0a> *RenderProcessHost::OnMessageReceivedがメッセージを受け取る。いくつかのメッセージはここで直接処理され、残りはRenderViewHostへ送られる。%0a> *RenderViewHost::OnMessageReceivedにメッセージが到着する。多くのメッセージはここで処理される、我々のメッセージはここでは処理されない。%0a> *処理されなかったメッセージは自動的にRenderWidgetHostに送られる。我々のメッセージもここに送られる。%0a> *メッセージマップがついにメッセージを受け取るりRenderWidgetHost::OnMsgSetCurorが呼ばれる。ここで適切なUI関数が呼ばれマウスカーソルがセットされる。%0a> %0a81,88c81,88%0a%3c *'''RederWidgetHostViewWin::OnMouseEvent'''がブラウザの'''UI'''スレッドで呼ばれる。これは'''ForwardMouseEventToRenderer'''を呼ぶ。%0a%3c *このときマウス入力をプラットフォーム独立な'''WebMouseEvent'''にまとめ、'''RenderWidgetHost'''に送る。%0a%3c *'''RenderWidgetHost::ForwardInputEvent'''は'''IPC'''メッセージ'''ViewMsg_HandleInputEvent'''を作成、'''WebInputEvent'''をその中にシリアライズする。そして'''RenderWidgetHost::Send'''する。%0a%3c *'''RenderProcessHost::Send'''に送られ'''IPC::ChannelProxy'''で送られる。%0a%3c *内部的には'''IPC:ChannelProxy'''は'''IO'''スレッドへのプロキシで、そこで名前付きパイプでレンダラーに送られる。%0a%3c %0a%3c 他のタイプのメッセージは'''WebContents'''で作成されることに注意。例えばナビゲーション関連など。'''WebContents'''から'''RenderViewHost'''へは同じような経路をたどる。%0a%3c %0a---%0a> *RederWidgetHostViewWin::OnMouseEventがブラウザのUIスレッドで呼ばれる。これはForwardMouseEventToRendererを呼ぶ。%0a> *このときマウス入力をプラットフォーム独立なWebMouseEventにまとめ、RenderWidgetHostに送る。%0a> *RenderWidgetHost::ForwardInputEventはIPCメッセージViewMsg_HandleInputEventを作成、WebInputEventをその中にシリアライズする。そしてRenderWidgetHost::Sendする。%0a> *RenderProcessHost::Sendに送られIPC::ChannelProxyで送られる。%0a> *内部的にはIPC:ChannelProxyはIOスレッドへのプロキシで、そこで名前付きパイプでレンダラーに送られる。%0a> %0a> 他のタイプのメッセージはWebContentsで作成されることに注意。例えばナビゲーション関連など。WebContentsからRenderViewHostへは同じような経路をたどる。%0a> %0a90,92c90,92%0a%3c *メインスレッドの'''IPC::Channel'''がメッセージを受信し、'''IPC::ChannelProxy'''がレンダラースレッドでのプロキシになる。%0a%3c *'''RenderView::OnMessageReceived'''がメッセージを受け取る。多くのメッセージはここで処理される。ただしマウスクリックは別で、'''RenderWidget::OnMessageReceived'''に転送されその後'''RederWidget::OnHandleInputEvent'''へ転送される。%0a%3c *'''WebWidgetImpl::HandleInputEvent'''へ進み、'''WebKit'''の'''PlatformMouseEvnet'''クラスへ変換される。その後、'''WebCore::Widget'''へ進む。%0a---%0a> *メインスレッドのIPC::Channelがメッセージを受信し、IPC::ChannelProxyがレンダラースレッドでのプロキシになる。%0a> *RenderView::OnMessageReceivedがメッセージを受け取る。多くのメッセージはここで処理される。ただしマウスクリックは別で、RenderWidget::OnMessageReceivedに転送されその後RederWidget::OnHandleInputEventへ転送される。%0a> *WebWidgetImpl::HandleInputEventへ進み、WebKitのPlatformMouseEvnetクラスへ変換される。その後、WebCore::Widgetへ進む。%0a
host:1531041208=192.168.3.2
author:1531040910=
diff:1531040910:1531040816:=24,25c24,25%0a%3c 最下位に我々の'''WebKit "port"'''がある。プラットフォーム固有の機能の実装でプラットフォーム独立の'''WebCore'''とのインターフェースになる。ファイルは'''WebKit'''ツリーにあり、'''chromium'''ディレクトリまたは'''Chromium'''サフィックスのファイルである。フォントレンダリングなどはプラットフォームごとに処理されなければならない。%0a%3c %0a---%0a> 最下位に我々のWebKit "port"がある。プラットフォーム固有の機能の実装でプラットフォーム独立のWebCoreとのインターフェースになる。ファイルはWebKitツリーにあり、chromiumディレクトリまたはChromiumサフィックスのファイルである。フォントレンダリングなどはプラットフォームごとに処理されなければならない。%0a> %0a27,28c27,28%0a%3c *グラフィックは'''Android'''用に開発された'''Skia'''グラフィックライブラリを利用する。これはクロスプラットフォームのグラフィックライブラリですべてのイメージと基本グラフィックを処理する（テキストは除く）。'''Skiaは/third_party/skia'''にある。%0a%3c %0a---%0a> *グラフィックはAndroid用に開発されたSkiaグラフィックライブラリを利用する。これはクロスプラットフォームのグラフィックライブラリですべてのイメージと基本グラフィックを処理する（テキストは除く）。Skiaは/third_party/skiaにある。%0a> %0a30c30%0a%3c '''Chromium'''と'''WebKit'''は型などを含め別のコーディングルールで記述されている。'''WebKit glue'''はその間に入り'''Chromium'''にとってやりやすいインターフェースを提供する。'''/WebKit/glue'''にある。ネーミングは'''WebKit'''オブジェクトと同じようになっているが'''"Web"'''が初めにつく。例えば'''WebCore::Frame'''は'''WebFrame'''になる。%0a---%0a> ChromiumとWebKitは型などを含め別のコーディングルールで記述されている。WebKit glueはその間に入りChromiumにとってやりやすいインターフェースを提供する。/WebKit/glueにある。ネーミングはWebKitオブジェクトと同じようになっているが"Web"が初めにつく。例えばWebCore::FrameはWebFrameになる。%0a
host:1531040910=192.168.3.2
author:1531040816=
diff:1531040816:1531040750:=21c21%0a%3c 我々はオープンソースの'''WebKit'''をウェブページのレイアウトに使っている。コードはアップルからプルされ、'''/third_party/WebKit'''ディレクトリにある。'''WebKit'''は主に'''WebCore'''から構成されコアレイアウト機能をもつ。'''Javascript'''を実行する'''JavaScriptCore'''ももつ。'''JavaScriptCore'''はテスト目的で実行する。通常これはハイパフォーマンスな'''V8 JavaScript'''エンジンに置き換えられている。Appleが'''WebKit'''と呼ぶレイヤで'''Safari'''などでは'''WebCore'''と'''OS X'''間の組み込みAPIは実際には使っていない。我々はAppleからプルしたコードを一般に'''WebKit'''と呼んでいる。%0a---%0a> 我々はオープンソースのWebKitをウェブページのレイアウトに使っている。コードはアップルからプルされ、/third_party/WebKitディレクトリにある。WebKitは主にWebCoreから構成されコアレイアウト機能をもつ。Javascriptを実行するJavaScriptCoreももつ。JavaScriptCoreはテスト目的で実行する。通常これはハイパフォーマンスなV8 JavaScriptエンジンに置き換えられている。AppleがWebKitと呼ぶレイヤでSafariなどではWebCoreとOS X間の組み込みAPIは実際には使っていない。我々はAppleからプルしたコードを一般にWebKitと呼んでいる。%0a
host:1531040816=192.168.3.2
author:1531040750=
diff:1531040750:1531040676:=15,18c15,18%0a%3c *'''Renderer / Render host''': '''Chromium'''のマルチプロセス組み込みレイヤ。相互の通知やコマンドのプロキシ。%0a%3c *'''WebContents''': '''Content'''モジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスの'''HTML'''レンダリングをビューへ容易に組み込み可能。[[開発者向け/コンテントモジュール]]のページ参照%0a%3c *'''Browser''': ブラウザウインドウを表す。多数の'''WebContents'''からなる。%0a%3c *'''Tab Helpers''': 個別のオブジェクトで'''WebContents'''と結びつく（'''WebContentsUserData'''混合）。ブラウザはこれらを'''WebContents'''に結び付ける（'''favicon'''や'''infobar'''など）%0a---%0a> *'''Renderer / Render host: Chromiumのマルチプロセス組み込みレイヤ。相互の通知やコマンドのプロキシ。%0a> *'''WebContents''': Contentモジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスのHTMLレンダリングをビューへ容易に組み込み可能。[[開発者向け/コンテントモジュール]]のページ参照%0a> *'''Browser''': ブラウザウインドウを表す。多数のWebContentsからなる。%0a> *'''Tab Helpers''': 個別のオブジェクトでWebContentsと結びつく（WebContentsUserData混合）。ブラウザはこれらをWebContentsに結び付ける（faviconやinfobarなど）%0a
host:1531040750=192.168.3.2
author:1531040676=
diff:1531040676:1530598083:=3,4c3,4%0a%3c '''Chromium'''がどのようにウェブページを表示するかをボトムアップに記述。[[マルチプロセスアーキテクチャ]]も読む。[[マルチプロセスリソースローディング]]も面白い。%0a%3c %0a---%0a> Chromiumがどのようにウェブページを表示するかをボトムアップに記述。[[マルチプロセスアーキテクチャ]]も読む。[[マルチプロセスリソースローディング]]も面白い。%0a> %0a13,14c13,14%0a%3c *'''WebKit''': '''Safari''', '''Chromium'''その他'''WebKit'''ベースのブラウザで使われる共用レンダリングエンジン。'''Port'''はWebKitの一部でプラットフォーム依存のシステムサービス（リソースロードやグラフィック）を統合する。%0a%3c *'''Glue''': '''WebKit'''の型を'''Chromium'''の型に変換する。これが我々の'''WebKit'''組み込みレイヤ。%0a---%0a> *'''WebKit''': Safari, Chromiumその他WebKitベースのブラウザで使われる共用レンダリングエンジン。'''Port'''はWebKitの一部でプラットフォーム依存のシステムサービス（リソースロードやグラフィック）を統合する。%0a> *'''Glue''': WebKitの型をChromiumの型に変換する。これが我々のWebKit組み込みレイヤ。%0a
host:1531040676=192.168.3.2
author:1530598083=
diff:1530598083:1530597912:=59,60c59,60%0a%3c RenderView/Widgetの上位にWebContentsオブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。WebContentsはウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[[開発者向け/コンテントモジュール]]のページを参照。%0a%3c %0a---%0a> RenderView/Widgetの上位にWebContentsオブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。WebContentsはウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[[コンテントモジュール]]のページを参照。%0a> %0a64c64%0a%3c ナビゲーションやスタートアップのさらなる実例は[[HowTo/Chromiumソースコードへの取り掛かり]]を参照。%0a---%0a> ナビゲーションやスタートアップのさらなる実例は[[Chromiumソースコードへの取り掛かり]]を参照。%0a
host:1530598083=192.168.3.2
author:1530597912=
diff:1530597912:1530597797:=16c16%0a%3c *'''WebContents''': Contentモジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスのHTMLレンダリングをビューへ容易に組み込み可能。[[開発者向け/コンテントモジュール]]のページ参照%0a---%0a> *'''WebContents''': Contentモジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスのHTMLレンダリングをビューへ容易に組み込み可能。[[コンテントモジュール]]のページ参照%0a
host:1530597912=192.168.3.2
author:1530597797=
diff:1530597797:1530427033:=7c7%0a%3c Attach:s1UD_M3hHfzYDGIEg7yotXQ.png%0a---%0a> Attach:ConceptualApplicationLayers.png%0a
host:1530597797=192.168.3.2
author:1530427033=
diff:1530427033:1530427033:=1,93d0%0a%3c https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome%0a%3c %0a%3c Chromiumがどのようにウェブページを表示するかをボトムアップに記述。[[マルチプロセスアーキテクチャ]]も読む。[[マルチプロセスリソースローディング]]も面白い。%0a%3c %0a%3c !概念的アプリケーションレイヤー%0a%3c %0a%3c Attach:ConceptualApplicationLayers.png%0a%3c (The original Google Doc for this illustration is http://goo.gl/MsEJX which is open for editing by any @chromium.org)%0a%3c %0a%3c %0a%3c %0a%3c 各階層は概念的アプリケーションレイヤー。下位レイヤーは上位レイヤに依存せず情報も持たない。%0a%3c *'''WebKit''': Safari, Chromiumその他WebKitベースのブラウザで使われる共用レンダリングエンジン。'''Port'''はWebKitの一部でプラットフォーム依存のシステムサービス（リソースロードやグラフィック）を統合する。%0a%3c *'''Glue''': WebKitの型をChromiumの型に変換する。これが我々のWebKit組み込みレイヤ。%0a%3c *'''Renderer / Render host: Chromiumのマルチプロセス組み込みレイヤ。相互の通知やコマンドのプロキシ。%0a%3c *'''WebContents''': Contentモジュールのメインクラスで再利用可能なコンポーネント。マルチプロセスのHTMLレンダリングをビューへ容易に組み込み可能。[[コンテントモジュール]]のページ参照%0a%3c *'''Browser''': ブラウザウインドウを表す。多数のWebContentsからなる。%0a%3c *'''Tab Helpers''': 個別のオブジェクトでWebContentsと結びつく（WebContentsUserData混合）。ブラウザはこれらをWebContentsに結び付ける（faviconやinfobarなど）%0a%3c %0a%3c !WebKit%0a%3c 我々はオープンソースのWebKitをウェブページのレイアウトに使っている。コードはアップルからプルされ、/third_party/WebKitディレクトリにある。WebKitは主にWebCoreから構成されコアレイアウト機能をもつ。Javascriptを実行するJavaScriptCoreももつ。JavaScriptCoreはテスト目的で実行する。通常これはハイパフォーマンスなV8 JavaScriptエンジンに置き換えられている。AppleがWebKitと呼ぶレイヤでSafariなどではWebCoreとOS X間の組み込みAPIは実際には使っていない。我々はAppleからプルしたコードを一般にWebKitと呼んでいる。%0a%3c %0a%3c !WebKit port%0a%3c 最下位に我々のWebKit "port"がある。プラットフォーム固有の機能の実装でプラットフォーム独立のWebCoreとのインターフェースになる。ファイルはWebKitツリーにあり、chromiumディレクトリまたはChromiumサフィックスのファイルである。フォントレンダリングなどはプラットフォームごとに処理されなければならない。%0a%3c %0a%3c *ネットワークトラフィックはマルチプロセスリソースローディングで処理され、レンダープロセスからOSを利用しない。%0a%3c *グラフィックはAndroid用に開発されたSkiaグラフィックライブラリを利用する。これはクロスプラットフォームのグラフィックライブラリですべてのイメージと基本グラフィックを処理する（テキストは除く）。Skiaは/third_party/skiaにある。%0a%3c %0a%3c !WebKit glue%0a%3c ChromiumとWebKitは型などを含め別のコーディングルールで記述されている。WebKit glueはその間に入りChromiumにとってやりやすいインターフェースを提供する。/WebKit/glueにある。ネーミングはWebKitオブジェクトと同じようになっているが"Web"が初めにつく。例えばWebCore::FrameはWebFrameになる。%0a%3c %0a%3c "test shell"はベアボーンのウェブブラウザでWebKit portとglueのテストをする。%0a%3c %0a%3c !レンダープロセス%0a%3c https://www.chromium.org/_/rsrc/1342584100941/developers/design-documents/displaying-a-web-page-in-chrome/Renderingintherenderer-v2.png%0a%3c Chromiumのレンダープロセスはglueインタフェースを使いWebKit portを組み込む。多量のコードは含んでいない。その仕事はブラウザとのIPCチャネルのレンダラーサイドになることである。%0a%3c %0a%3c レンダラーのもっとも重要なクラスはRenderViewである。/content/renderer/render_view_impl.ccにある。これがウェブページを表す。ブラウザから、またブラウザへのナビゲーション関連のコマンドを処理する。これはRenderWidgetから継承されるがこれは描画や入力を処理する。RenderViewはブラウザとの通信に（レンダープロセスごとに）グローバルなRenderProcessを使う。%0a%3c %0a%3c !FAQ:RenderWidgetとRenderViewの違いは？%0a%3c RenderWidgetはWebCore::Widgetオブジェクトとマップされる。それは抽象インターフェースWebWidgetDelegateを実装することにより行う。RenderWidgetは基本的に１つのウインドウであり、入力と受け取り、描画の出力になる。RenderViewはRenderWidgetから継承され、タブやポップアップウインドウのコンテンツになり、ナビゲーション関連の命令を受け取る。RenderViewなしにRenderWidgetが存在するケースが１つだけありウェブページ上のセレクトボックスである。%0a%3c %0a%3c !レンダラー内のスレッド%0a%3c レンダラーは２つのスレッドを持つ。１つはRenderViewやWebKitが動くものである。（途中）%0a%3c %0a%3c !ブラウザプロセス%0a%3c https://www.chromium.org/_/rsrc/1220197831473/developers/design-documents/displaying-a-web-page-in-chrome/rendering%2520browser.png%0a%3c %0a%3c !下位レベルのブラウザプロセスのオブジェクト%0a%3c ブラウザのIOスレッド上でレンダープロセスとのIPC通信が行われる。このスレッド上ですべてのネットワーク通信も扱われる。%0a%3c %0a%3c メインスレッド（UIが動いている）でRenderProcessHostが初期化されるとき、新しくレンダラープロセスとChannelProxyというIPCオブジェクト（名前付きパイプ）がつくられる。このIPCオブジェクトはブラウザのIOスレッドで動き、名前付きパイプをリッスンし、メッセージをRenderProcessHostに返す。ResourceMessageFilterがこのチャネルにインストールされれば、メッセージをフィルタ出来る。%0a%3c %0a%3c RenderProcessHostはビュー関連のメッセージを適切なRenderViewHostにディスパッチする責任がある。%0a%3c %0a%3c !上位レベルのブラウザプロセスのオブジェクト%0a%3c ビュー固有のメッセージはRenderViewHost::OnMessageReceivedに到着する。ほとんどのメッセージはここで処理され残りはRenderWidgetHostへ回される。それぞれのプラットフォームでビュークラスがあり(RenderWidgetHostView[Aura|Gtk|Mac|Win])、ネイティブのビューシステムを実装する。%0a%3c %0a%3c RenderView/Widgetの上位にWebContentsオブジェクトがある。ほとんどすべてのメッセージは結局のところこのオブジェクト上の関数コールに帰着する。WebContentsはウェブページのコンテンツを表す。コンテントオブジェクトの最上位モジュールである。矩形ビューにウェブページを表示する責任を持つ。詳しくは[[コンテントモジュール]]のページを参照。%0a%3c %0a%3c WebContentsオブジェクトはTabContentsWrapperに含まれる。chromeディレクトリにありタブに責任を持つ。%0a%3c %0a%3c !イラストでの実例%0a%3c ナビゲーションやスタートアップのさらなる実例は[[Chromiumソースコードへの取り掛かり]]を参照。%0a%3c %0a%3c !"set cursor"メッセージの生涯%0a%3c カーソルの切り替えはレンダラーからブラウザへ送られる典型的メッセージである。レンダラでは以下のことが起こる。%0a%3c *Set cursorメッセージは入力イベントへの応答として内部的にWebKitが生成する。set cursorメッセージはRenderWidget::SetCursorから始まる。%0a%3c *それはRenderWidget::Sendを呼び、メッセージをディスパッチする。このメソッドはRenderViewからもブラウザにメッセージを送るために使用される。そしてRenderThread::Sendを呼ぶ。%0a%3c *これはIPC::SyncChannelを呼びブラウザへ送られる。%0a%3c %0a%3c そしたらブラウザは次のことを行う。%0a%3c *RenderProcessHost内にあるIPC::ChannelProxyはIOスレッドでこのメッセージを受け取る。%0a%3c *RenderProcessHost::OnMessageReceivedがメッセージを受け取る。いくつかのメッセージはここで直接処理され、残りはRenderViewHostへ送られる。%0a%3c *RenderViewHost::OnMessageReceivedにメッセージが到着する。多くのメッセージはここで処理される、我々のメッセージはここでは処理されない。%0a%3c *処理されなかったメッセージは自動的にRenderWidgetHostに送られる。我々のメッセージもここに送られる。%0a%3c *メッセージマップがついにメッセージを受け取るりRenderWidgetHost::OnMsgSetCurorが呼ばれる。ここで適切なUI関数が呼ばれマウスカーソルがセットされる。%0a%3c %0a%3c !"mouse click"メッセージの生涯%0a%3c マウスクリックメッセージはブラウザからレンダラーに送られる典型的メッセージ。%0a%3c *RederWidgetHostViewWin::OnMouseEventがブラウザのUIスレッドで呼ばれる。これはForwardMouseEventToRendererを呼ぶ。%0a%3c *このときマウス入力をプラットフォーム独立なWebMouseEventにまとめ、RenderWidgetHostに送る。%0a%3c *RenderWidgetHost::ForwardInputEventはIPCメッセージViewMsg_HandleInputEventを作成、WebInputEventをその中にシリアライズする。そしてRenderWidgetHost::Sendする。%0a%3c *RenderProcessHost::Sendに送られIPC::ChannelProxyで送られる。%0a%3c *内部的にはIPC:ChannelProxyはIOスレッドへのプロキシで、そこで名前付きパイプでレンダラーに送られる。%0a%3c %0a%3c 他のタイプのメッセージはWebContentsで作成されることに注意。例えばナビゲーション関連など。WebContentsからRenderViewHostへは同じような経路をたどる。%0a%3c %0a%3c そしてレンダラーでは：%0a%3c *メインスレッドのIPC::Channelがメッセージを受信し、IPC::ChannelProxyがレンダラースレッドでのプロキシになる。%0a%3c *RenderView::OnMessageReceivedがメッセージを受け取る。多くのメッセージはここで処理される。ただしマウスクリックは別で、RenderWidget::OnMessageReceivedに転送されその後RederWidget::OnHandleInputEventへ転送される。%0a%3c *WebWidgetImpl::HandleInputEventへ進み、WebKitのPlatformMouseEvnetクラスへ変換される。その後、WebCore::Widgetへ進む。%0a%3c %0a
host:1530427033=192.168.3.2
